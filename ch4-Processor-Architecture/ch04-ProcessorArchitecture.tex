%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Welcome to the MAT320 Homework template on Overleaf -- just edit your
% LaTeX on the left, and we'll compile it for you on the right.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --------------------------------------------------------------
% Based on a homework template by Dana Ernst.
% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------

\documentclass[12pt]{article}

\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{textcomp} % cent symbol, such as \textcent
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{cancel}
\usepackage{mathtools} % ceiling function
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
% https://tex.stackexchange.com/questions/146306/how-to-make-horizontal-lists
\usepackage[inline]{enumitem} % allows using letters in enumerate list environment

% source: https://stackoverflow.com/questions/3175105/inserting-code-in-this-latex-document-with-indentation

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=C, % language for code listing
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4
}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\newenvironment{ex}[2][Exercise]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\newenvironment{sol}[1][Solution]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1:}]}{\end{trivlist}}


\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\noindent Sergio Garcia Tapia \hfill

\noindent{\small Computer Systems: A Programmer's Perspective, by Bryant and O'Hallaron} \hfill

\noindent{\small Chapter 4: Processor Architecture}
\noindent\today

\subsection*{Practice Problems}

\begin{ex}{4.1}
	Determine the byte encoding of the Y86-64 instruction sequence that follows.
	The line \texttt{.pos 0x100} indicates that the starting address of the object
	code should be \texttt{0x100}.
	
	\begin{lstlisting}[language={}]
.pos 0x100	# Start code at address 0x100
	irmovq	$15,%rbx
	rrmovq	%rbx,%rcx
loop:
	rmmovq	%rcx,-3(%rbx)
	addq	%rbx,%rcsx
	jmp		loop
	\end{lstlisting}
\end{ex}

\begin{sol}
	\
	The \texttt{irmovq} instruction has a code part of \texttt{0x3}
	and control part of \texttt{0x0}, which we put together as
	\texttt{0x30}. Its instruction format does not use a source register, and
	a \texttt{0x15} indicates; the destination register \texttt{\%rbx} is
	encoded as \texttt{0x3}. Finally, \text{\$15} is hexadecimal \texttt{0xf},
	which after extending to 64 bits gives \texttt{0x000000000000000f};
	we reserve the byte orders to get \texttt{0f00000000000000} for the
	encoding of the instruction. Altogether this  takes up 10 bytes, so
	the next instruction has address \texttt{0x10A}, an offset of \texttt{.pos}
	by 10.
	
	\
	The \texttt{rrmovq} is encodded as \texttt{0x20}. Its source register
	is \texttt{\%rbx} with encoding \texttt{0x3}, and its destination
	\texttt{\%rcx} with encoding \texttt{0x1}. Overall, this instruction
	takes up \texttt{2 bytes}, so the next instruction has address \texttt{0x10C}.
	
	\
	The \texttt{loop} is a placeholder for an address, so it will be
	replaced by the address \texttt{0x1c}.
	
	\
	The \texttt{rmmovq} has encoding \texttt{0x40}. Its source register is 
	\texttt{\%rcx} with \texttt{0x1}, and the destination is a memory
	reference with base address given by register \texttt{\%rbx} with
	encoding \texttt{0x3}, and offset \texttt{-3}, which is given by
	\texttt{0xfffffffffffffffd}. We reverse it to \texttt{0xfdffffffffffffff}
	for the instruction encoding. This instruction takes up 10 bytes, so the
	next one starts at address \texttt{0x116}.
	
	\
	The \texttt{addq} has encoding \texttt{0x60}. Its source and destination
	registers have encodings \texttt{0x3} and \texttt{0x1}, respectively.
	The whole instruction takes up 2 bytes, so the next starting address
	is \texttt{0x118}.
	
	\
	The \texttt{jmp} is encoded as \texttt{0x70}, and \texttt{loop} is
	replaced by the address \texttt{0x010c}, whose bytes we reverse to
	\texttt{0c01000000000000}. The entire translation is:
	\begin{lstlisting}[language={}]
0x100: 30 f3 0f00000000000000
0x10A: 20 31
0x10C: 40 13 fdffffffffffffff
0x116: 60 31
0x118: 70 0c01000000000000
	\end{lstlisting}
\end{sol}

\begin{ex}{4.2}
	For each byte sequence listed, determine the Y86-64 instruction
	sequence it encodes. IF there is some invalid byte in the sequence,
	show the instruction sequence up to that point, and indicate where
	the invalid byte occurs. For each sequence, we show the starting
	address then a colon, and then the byte sequence.
	\begin{enumerate}[label=(\alph*)]
		\item
			\texttt{0x100: 30f3fcffffffffffffff40630008000000000000}
		
		\item 
			\texttt{0x200: a06f800c020000000000000030f30a00000000000000}
		\item 
			\texttt{0x300: 5054070000000000000010f0b01f}
		\item 
			\texttt{0x400: 611373000400000000000000}
		\item 
			\texttt{0x500: 6362a0f0}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The initial \texttt{30} makes this a \texttt{irmovq}
		instruction. The following \texttt{f} represents that a source
		is not needed, and the \texttt{3} that the destination register
		is \texttt{\%rbx}. The 8-byte value is \texttt{fcffffffffffffff},
		which is \texttt{-4} in decimal. This instruction takes up 10 bytes.
		
		The \texttt{40} that follows means
		we have a \texttt{rmmovq} instruction expecting two registers an
		an offset. The \texttt{6} means the source is \texttt{\%rsi},
		and the \texttt{3} , means the destination if \texttt{\%rbx}.
		The \texttt{00080000000000} reverses to \texttt{00000000008000},
		completing the instruction and taking up 9 bytes.
		The last two \texttt{00} indicate the \texttt{halt} instruction.
		Altogether, we have:
		\begin{lstlisting}[language={}]
0x100: irmovq -4,%rbx
0x10C: rmmovq %rsi0x800(%rbx)
0x115: halt
		\end{lstlisting}
		\item The \texttt{a0} makes this a \texttt{pushq} instruction,
		the following \texttt{6} is source register \texttt{\%rsi}, and the
		following \texttt{f} that there is no destination register.
		
		Starting at \texttt{80}, we have the start of the encoding for
		a \texttt{call} instruction. The destination is encoded by
		the 8 bytes \texttt{0c02000000000000}, which we reverse to
		\texttt{000000000000020c}, or simply \texttt{0x020c}.
		
		The next \texttt{0x00} indicates a \texttt{halt} instruction.
		
		\
		The next \texttt{30} means we are parsing a \texttt{irmovq} command,
		with no source register instructed by the \texttt{f} and destination
		register \texttt{3} which is \texttt{\%rbx}. The constant in reverse
		is given by \texttt{0x0a00000000000000}, so we reverse it to
		\texttt{000000000000000a}. The program is:
		\begin{lstlisting}[language={}]
0x200:	pushq %rsi
0x202:	call 0x000000000000020c
0x20b:	halt
0x20c:	irmovq $10,%rbx
		\end{lstlisting} 
		\item The initial \texttt{50} makes this a \texttt{mrmovq}
		instruction. The following byte \texttt{54} means that the
		source and destination registers are \texttt{\%rsp} and
		\texttt{\%rbp}, respectively. The source is a memory reference
		with a an offset given by the following 8 bytes\texttt{0x0700000000000000},
		which we reverse to \texttt{0x0000000000000007}, or decimal \texttt{7}.
		
		\
		The \texttt{10} means we have a \texttt{nop}. The \texttt{f0}
		is an invalid byte. \texttt{b01f} means \texttt{popq} \texttt{\%rcx}.
		Altogether we have:
		\begin{lstlisting}[language={}]
0x300: mrmovq 7(%rsp),%rbp
0x30a: nop
0x30b: # invalid
0x30c: popq %rcx
		\end{lstlisting}
		
	
		\item The \texttt{61} makes this a \texttt{subq} instruction,
		with source register \texttt{\%rcx} and destination register
		\texttt{\%rbx}, as given by \texttt{0x13}. The instruction is
		\texttt{subq \%rcx, \%rbx}.
		
		000400000000000000
		The \texttt{73} that follows indicates a \texttt{je} instruction,
		followed by the reversed constant address \texttt{0004000000000000},
		which we reverse to \texttt{0000000000000400}. The last \texttt{00}
		indicates a \texttt{halt}:
		\begin{lstlisting}[language={}]
0x400: subq %rcx, %rbx
0x402: je 0x0000000000000400
0x40b: halt
		\end{lstlisting}
		\item The \texttt{63} makes this a \texttt{xorq} instruction,
		with source register \texttt{\%rsi} and destination register
		\texttt{\%rdx}, as indicated by the \texttt{62}. The instruction
		is \texttt{xorq \%rsi, \%rdx}. We then have \texttt{a0} for
		a \texttt{pushq} instruction, but the \texttt{f} says that
		there is no source register, which is invalid:
		\begin{lstlisting}[language={}]
0x500: xorq %rsi, %rdx
0x502: pushq f0 # invalid byte register f0
		\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{4.3}
	One common pattern in machine-level programs is to add a constant value to
	a register. With the Y86-64 presented thus far, this requires first using
	an \texttt{irmovq} to set a register to the constant, then an \texttt{addq}
	instruction to add this value to the destination register. Suppose we now
	want to add a new instruction \texttt{iaddq} with the following format:
	\begin{center}
		\begin{tabular}{l|l|l|l|l|llllllll}
			Byte & \texttt{0} & {} & \texttt{1} & {} & \texttt{2} & \texttt{3} & \texttt{4} & \texttt{5} & \texttt{6} & \texttt{7} & \texttt{8} & \texttt{9}\\
			\hline
			\texttt{iddq V, rB} & \texttt{C} & \texttt{0} & \texttt{F} & \texttt{rB} & \multicolumn{8}{c}{\texttt{V}}\\
			\hline
		\end{tabular}
	\end{center}
	This instruction adds the constant value \texttt{V} to register \texttt{rB}.
	\
	
	Re-write the Y86-64 \texttt{sum} function of Figure 4.6 to make use of the
	\texttt{iaddq} instruction. In the original version, we dedicate registers
	\texttt{\%r8} and \texttt{\%r9} to hold constant values. Now, we can avoid
	using those registers altogether.
\end{ex}

\begin{sol}
	\
	\begin{lstlisting}[language={}]
	long sum(long *start, long count)
	start in %rdi, count in %rsi
sum:
	xorq	%rax,%rax	# sum = 0
	andq	%rsi,%rsi	# Set condition code
	jmp test
loop:
	mrmovq	(%rdi),%r10	# Get *start
	addq	%r10,%rax	# Add to sum
	iaddq	$1,%rdi		# start++
	iaddq	$-1,%rsi	# count--, set condition code
test:
	jne		loop		# Stop when 0
	ret
	\end{lstlisting}
\end{sol}

\begin{ex}{4.4}
	Write Y86-64 code to implement a recursive sum function \texttt{rsum},
	based on the following code:
	
	\begin{lstlisting}
long rsum(long *start, long count)
{
	if (count <= 0)
		return 0;
	return *start + rsum(start+1, coount-1);
}
	\end{lstlisting}
	Use the same argument passing and register saving conventions as x86-64
	code does. You might find it helpful to compile the C code on an
	x86-64 machine and then translate the instructions to Y86-64.
\end{ex}

\begin{sol}
	I compiled \texttt{rsum.c} with the flags: \texttt{gcc -S -O1 rsum.c},
	and got the following x86-64 output:
	\lstinputlisting[language={}]{./04-recursive-sum/rsum.s}
	I used it as the based for the following Y86-64 code, which I have annotated:
	\begin{lstlisting}[language={}]
	long rsum(long *start, long count)
	start in %rdi, count in %rsi
rsum:
	irmovq	$0,%rax		# Set return value to 0
	iaddq	$0,%rsi		# Set condition code
	jle		.L5:		# if <= 0 goto .L5
	pushq	%rbx		# Callee-saved register
	rrmovq	%rdi,%rbx	# save start (memory address)
	iaddq	$1,%rsi		# count--
	iaddq	$8,%rdi		# start++ (add 8 bytes to pointer, pointing to next)
	call rsum			# rsum(start++, count--)
	mrmovq	(%rbx),%rax	# add *start to return value
	popq	%rbx		# restore register
	ret					# return
.L5:					
	ret					# return
	\end{lstlisting}	
\end{sol}

\begin{ex}{4.5}
	Modify the Y86-64 code for the \texttt{sum} function (Figure 4.6) to
	implement a function \texttt{absSum} that computes the sum of absolute
	values of an array. Use a \emph{conditional jump} instruction within your
	inner loop.
\end{ex}

\begin{sol}
	\
	My implementation uses the fact that if \texttt{x} is negative, then
	\texttt{\~{}x + 1} negates it, making it positive.
	\begin{lstlisting}[language={}]
	long absSum(long *start, long count)
	start in %rdi, count in %rsi
absSum:
	irmovq	$-1,%r11		# Constant -1
	xorq	%rax,%rax	# sum = 0
	andq	%rsi,%rsi	# Set condition code
	jmp test
loop:
	mrmovq	(%rdi),%r10	# Get *start
	iadd0	$0,%r10		# Set condition code
	jge		.nonneg		# if >= goto .nonneg
	xorq	%r11,%r10	# -1 XOR *start
	iaddq	$1,%r10		# finish computing abs(*start)
.nonneg:
	addq	%r10,%rax	# Add to sum
	iaddq	$1,%rdi		# start++
	iaddq	$-1,%rsi	# count--, set condition code
test:
	jne		loop		# Stop when 0
	ret
	\end{lstlisting}
\end{sol}

\begin{ex}{4.6}
	Modify the Y86-64 code for the \texttt{sum} function (Figure 4.6) to
	implement a function \texttt{absSum} that computes the sum of absolute
	values of an array. Use a \emph{conditional move} instruction within your
	inner loop.
\end{ex}

\begin{sol}
	\
	My implementation uses the fact that if \texttt{x} is negative, then
	\texttt{\~{}x + 1} negates it, making it positive.
\begin{lstlisting}[language={}]
		long absSum(long *start, long count)
		start in %rdi, count in %rsi
absSum:
		irmovq	$-1,%r11		# Constant -1
		xorq	%rax,%rax	# sum = 0
		andq	%rsi,%rsi	# Set condition code
		jmp test
loop:
		mrmovq	(%rdi),%r10	# Get *start
		xorq	%r10,%r11	# -1 XOR *start
		iaddq	$1,%r11		# Finishes computing -*start
		cmovge	%r11,%r10	# if %r11 is positive, then %r10 was negative
		addq	%r10,%rax	# Add to sum
		iaddq	$1,%rdi		# start++
		iaddq	$-1,%rsi	# count--, set condition code
		test:
		jne		loop		# Stop when 0
		ret
	\end{lstlisting}
\end{sol}

\begin{ex}{4.7}
	Let us determine the behavior of the instruction \texttt{pushq \%rsp}
	for an x86-64 processor. We could try reading the Intel documentation
	on this instruction, but a simpler approach is to conduct an experiment
	on an actual machine. The C compiler would not normally generate this
	instruction, so we must use hand-generated assembly code for this task.
	Here is a test function we have written (Web Aside ASM:EASM on page
	178 describes how to write programs that combine C code with handwritten
	assembly code):
	\begin{lstlisting}[language={}]
	.text
.global pushtest
pushtest:
	movq	%rsp,%rax	# Copy stack pointer
	pushq	%rsp		# Push stack pointer
	popq	%rdx		# Pop it back
	subq	%rdx,%rax	# Return 0 or 4
	ret
	\end{lstlisting}
	In our experiments, we find that \texttt{pushtest} always returns 0.
	What does this imply about the behavior of the instruction
	\texttt{pushq \%rsp} under x86-64?
\end{ex}

\begin{sol}
	\
	The first instruction stores the old value of the pointer in \texttt{\%rax}
	Since the output is always 0, this means that \texttt{pushq \%rsp}
	pushes the original value of \texttt{\%rsp}.
\end{sol}

\begin{ex}{4.8}
	The following assembly-code function lets us determine the behavior of
	\texttt{popq \%rsp} on x86-64:
	\begin{lstlisting}[language={}]
	.text
.global poptest
poptest:
	movq	%rsp,%rdi	# Save stack pointer
	pushq	$0xabcd		# Push test value
	popq	%rsp		# Pop to stack pointer
	movq	%rsp,%rax	# Set popped value as returned value
	movq	%rdi,%rsp	# Restore stack pointer
	ret
	\end{lstlisting}
	We find this function always returns \texttt{0xabcd}. What does this imply
	about the behavior of \texttt{pop \%rsp}? What other Y86-64 instruction would
	have the same behavior?
\end{ex}

\begin{sol}
	\
	It implies that \texttt{pop \%rsp} sets the stack pointer to the
	value read from memory. We could use \texttt{mrmovq} to read this
	value instead. This would give the correct return value; however,
	the value we pushed would remain on the stack, and would therefore
	point to a lower address than the \texttt{popq} approach.
\end{sol}

\begin{ex}{4.9}
	Write an HCL expression for a signal \texttt{xor}, equal to the
	\emph{exclusive-or} of inputs \texttt{a} and \texttt{b}. What is
	the relation between the signals \texttt{xor} and \texttt{eq} defined
	above?
\end{ex}

\begin{sol}
	\
	If we let $\oplus$ be the XOR symbol, we can define it to mean
	\begin{center}
	\texttt{a $\oplus$ b} = (\texttt{a \&\& !b}) \texttt{||} (\texttt{!a \&\& b})	
	\end{center}
	\texttt{xor} and \texttt{eq} are negations of one another, because
	\texttt{xor} is 1 when \texttt{a} and \texttt{b} are distinct, and 0
	otherwise. Meanwhile, \texttt{eq} is 1 when \texttt{a} and \texttt{b}
	are equal, and 0 otherwise.
\end{sol}

\end{document}