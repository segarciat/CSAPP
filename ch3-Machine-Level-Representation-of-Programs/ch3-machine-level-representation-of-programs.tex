%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Welcome to the MAT320 Homework template on Overleaf -- just edit your
% LaTeX on the left, and we'll compile it for you on the right.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --------------------------------------------------------------
% Based on a homework template by Dana Ernst.
% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------

\documentclass[12pt]{article}

\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{textcomp} % cent symbol, such as \textcent
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{cancel}
\usepackage{mathtools} % ceiling function
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
% https://tex.stackexchange.com/questions/146306/how-to-make-horizontal-lists
\usepackage[inline]{enumitem} % allows using letters in enumerate list environment

% source: https://stackoverflow.com/questions/3175105/inserting-code-in-this-latex-document-with-indentation

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=C, % language for code listing
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4
}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\newenvironment{ex}[2][Exercise]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\newenvironment{sol}[1][Solution]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1:}]}{\end{trivlist}}


\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\noindent Sergio Garcia Tapia \hfill

\noindent{\small Computer Systems: A Programmer's Perspective, by Bryant and O'Hallaron} \hfill

\noindent{\small Chapter 3: Machine-Level Representation of Programs
\noindent\today

\subsection*{Practice Problems}

\begin{ex}{3.1}
	Assume the following values are stored at the indicated memory addresses and registers:
	\begin{center}
		\begin{tabular}{cccc}
			Address & Value & Register & Value\\
			\hline
			\texttt{0x100} & \texttt{0xFF} & \texttt{\%rax} & \texttt{0x100}\\
			\texttt{0x104} & \texttt{0xAB} & \texttt{\%rcx} & \texttt{0x1}\\
			\texttt{0x108} & \texttt{0x13} & \texttt{\%rdx} & \texttt{0x3}\\
			\texttt{0x10C} & \texttt{0x11}
		\end{tabular}
	\end{center}
	Fill in the following table showing the values for the indicated operands:
	\begin{center}
		\begin{tabular}{cc}
			Operand & Value\\
			\hline
			\texttt{\%rax} & \makebox[1cm]{\hrulefill}\\
			\texttt{0x104} & \makebox[1cm]{\hrulefill}\\
			\texttt{\$0x108} & \makebox[1cm]{\hrulefill}\\
			\texttt{(\%rax)} & \makebox[1cm]{\hrulefill}\\
			\texttt{4(\%rax)} & \makebox[1cm]{\hrulefill}\\
			\texttt{9(\%rax, \%rdx)} & \makebox[1cm]{\hrulefill}\\
			\texttt{260(\%rcx, \%rdx)} & \makebox[1cm]{\hrulefill}\\
			\texttt{0xFC(,\%rcx,4)} & \makebox[1cm]{\hrulefill}\\
			\texttt{(\%rax,\%rdx,4)} & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	To start, \texttt{\%rax} is a 64-bit register conventionally used to store a return value.
	Its value is \texttt{0x100}. Next, \texttt{0x104} looks like an immediate but it is not preceded
	by \texttt{\$}, so it is in fact an absolute memory address. Its operand value is \texttt{0xAB}.
	Next is \texttt{\$0x108}, which is an immediate since it is preceded by a \texttt{\$}, so its
	value is \texttt{0x108}. The operand \texttt{(\%rax)} is a an type of memory reference, specifically
	an indirect one. Therefore, the value \texttt{0x100} of \texttt{\%rax} is used as an address,
	yielding \texttt{0xFF}. The \texttt{4(\%rax)} operand is a memory operand where \texttt{4} is an immediate
	treated as an offset, and \texttt{\%rax} is treated as the base. Therefore the address is
	\texttt{4} added to \texttt{0x100}, yielding \texttt{0x104}. Accessing the memory value
	at that address yields \texttt{0xAB}. Next, \texttt{9(\%rax, \%rdx)} is an indexed memory reference,
	where \texttt{\%rax} is the base, \texttt{\%rdx} is the 64-bit index register (normally used as a
	3rd argument for a procedure), and \texttt{9} is an immediate offset. The memory address is thus
	\texttt{9 + 0x100 + 0x3}. The resulting is memory address \texttt{0x10C}, and the corresponding value
	is \texttt{0x11}. Now \texttt{260(\%rcx, \%rdx)}, which is similar; the address is
	\texttt{260+0x1+0x3} which is \texttt{264} or \texttt{0x108}, and its value is
	\texttt{0x13}. Next \texttt{0xFC(,\%rcx,4)}, which is a scaled index memory reference.
	We scale the address in the index register \texttt{\%rcx} by \texttt{4}, so it becomes
	\texttt{0x4}, and then add to it the immediate \texttt{0xFC} to give an address \texttt{0x100}.
	The value is now determined to be \texttt{0xFF}. Finally, \texttt{(\%rax,\%rdx,4)} is a
	scaled indexed memory reference, with address \texttt{0x100} in the base register \texttt{\%rax}
	and value \texttt{0x3} in register \texttt{\%rdx} scaled by \texttt{4} to give address
	\texttt{0x10C}. The value is \texttt{0x11}.
	
	\begin{center}
		\begin{tabular}{cc}
			Operand & Value\\
			\hline
			\texttt{\%rax} & \texttt{0x100}\\
			\texttt{0x104} & \texttt{0xAB}\\
			\texttt{\$0x108} & \texttt{0x108}\\
			\texttt{(\%rax)} & \texttt{0xFF}\\
			\texttt{4(\%rax)} & \texttt{0xAB}\\
			\texttt{9(\%rax, \%rdx)} & \texttt{0x11}\\
			\texttt{260(\%rcx, \%rdx)} & \texttt{0x13}\\
			\texttt{0xFC(,\%rcx,4)} & \texttt{0xFF}\\
			\texttt{(\%rax,\%rdx,4)} & \texttt{0x11}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.2}
	For each of the following lines of assembly language, determine the appropriate suffix
	based on the operands. (For example, \texttt{mov} can be rewritten as \texttt{movb},
	\texttt{movw}, \texttt{movl}, or \texttt{movq}.)
	\begin{center}
		\begin{tabular}{ccc}
			\texttt{mov}\makebox[0.5cm]{\hrulefill} & \texttt{\%eax,} & \texttt{(\%rsp)}\\
			\texttt{mov}\makebox[0.5cm]{\hrulefill} & \texttt{(\%rax),} & \texttt{\%dx}\\
			\texttt{mov}\makebox[0.5cm]{\hrulefill} & \texttt{\$0xFF,} & \texttt{\%bl}\\
			\texttt{mov}\makebox[0.5cm]{\hrulefill} & \texttt{(\%rsp,\%rdx,4),} & \texttt{\%dl}\\
			\texttt{mov}\makebox[0.5cm]{\hrulefill} &\texttt{(\%rdx),} & \texttt{\%rax}\\
			\texttt{mov}\makebox[0.5cm]{\hrulefill} & \texttt{\%dx,} & \texttt{(\%rax)}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	The \texttt{\%eax} source register is 32-bit (a double word) and conventionally used as a return value,
	while the \texttt{\%rsp} destination register is 64-bit (a quad word) and conventionally used as
	the stack pointer. Therefore we can use the \texttt{movl} instruction, where the \texttt{l} suffix
	indicates we are moving a double word.
	
	\
	
	The \texttt{(\%rax)} is a n indirect memory reference using the address in the 64-bit (quad-word) \texttt{\%rax}
	source register (conventionally used as a return address), and the destination 16-bit (word)
	register \texttt{\%dx} (conventionally the 3rd argument in a procedure). This means we should use
	\texttt{movw}, since we are moving a single word.
	
	\
	
	The \texttt{\$0xFF} source operand is an 8-bit immediate, and the destination \texttt{\%bl} is an
	8-bit (byte) register (conventionally callee-saved). For this we use \texttt{movb}.
	
	\
	
	The \texttt{(\%rsp\%rdx,4)} is the source, and it is a scaled index memory reference using
	the 64-bit (quad word) stack pointer register \texttt{\%rsp} as the base address, the 64-bit
	(quad word) 3rd-argument register as the index register, and the scale factor \texttt{4}.
	The destination is \texttt{\%dl}, the 8-bit (byte) 3rd argument register. For this we must
	use \texttt{movb}.
	
	\
	
	The \texttt{(\%rdx)}  operand is an indirect memory reference using the 64-bit (quad word)
	register \texttt{\%rdx} (conventionally representing the 3rd argument) as the address.
	The destination is the 64-bit (quad word) register \texttt{\%rax} normally used for the
	return value. We can use \texttt{movq} in this case.
	
	\
	
	Finally, we have source operand \texttt{\%dx}, the 16-bit (word) third argument, and
	destination indirect memory reference using the address of the 64-bit (quad word)
	return value  register \texttt{\%rax}. We use \texttt{movw} in this case.
	\begin{center}
		\begin{tabular}{ccc}
			\texttt{movl} & \texttt{\%eax,} & \texttt{(\%rsp)}\\
			\texttt{movw} & \texttt{(\%rax),} & \texttt{\%dx}\\
			\texttt{movb}& \texttt{\$0xFF,} & \texttt{\%bl}\\
			\texttt{movb} & \texttt{(\%rsp,\%rdx,4),} & \texttt{\%dl}\\
			\texttt{movq} &\texttt{(\%rdx),} & \texttt{\%rax}\\
			\texttt{movw} & \texttt{\%dx,} & \texttt{(\%rax)}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.3}
	Each of the following lines of code generates an error when we invoke the assembler.
	Explain what is wrong with each line.
	\begin{center}
		\begin{tabular}{ccc}
			\texttt{movb} & \texttt{\$0xF,} & \texttt{(\%ebx)}\\
			\texttt{movl} & \texttt{\%rax,} & \texttt{(\%rsp)}\\
			\texttt{movw} & \texttt{(\%rax),} &\texttt{4(\%rsp)}\\
			\texttt{movb} & \texttt{\%al,} & \texttt{\%sl}\\
			\texttt{movq} & \texttt{\%rax,} & \texttt{\$0x123}\\
			\texttt{movl} & \texttt{\%eax,} & \texttt{\%dx}\\
			\texttt{movq} & \texttt{\%si,} & \texttt{8(\%rbp)}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	The instruction \texttt{movb} \texttt{\$0xF,} \texttt{(\%ebx)} has as a destination operand
	the indirect memory reference \texttt{(\%ebx)}, where \texttt{\%ebx} is a 32-bit register.
	When a register is used in a memory addressing mode, its must be 64-bit; see page 181.
	We could fix the instruction by changing the destination operand to \texttt{(\%rbx)}.
	
	\
	
	For \texttt{movl \%rax, (\%rsp)}, we have 64-bit (quad word) operands, but the \texttt{movl}
	instruction is meant to work with double words (32-bit, as indicated by the suffix \texttt{l}).
	
	
	\
	
	The instruction \texttt{movw (\%rax), 4(\%rsp)} is meant to work with 16-bit operands, as indicate
	by the word suffix \texttt{w}. However, its values are both 64-bit operands. Nevertheless,
	both operands are memory references, which is forbidden by x86-64; see page 183.
	
	\
	
	The instruction \texttt{movb \%al, \%sl} has an invalid register \texttt{\%sl}. The intention
	may have been \texttt{\%spl} for stack pointer or maybe \texttt{\%sil} for the second argument,
	but it's not clear.
	
	\
	
	The instruction \texttt{movq \%rax, \$0x123} has an immediate as a destination, which is not
	allowed; only a register or a memory reference may be used as a destination.
	
	\
	
	The instruction \texttt{movl \%eax, \%dx} has a 32-bit source register and a 16-bit destination
	register. The \texttt{movl} instruction works with double words (32-bit) operands, so the
	destination register is incompatible. A fix would be use to use \texttt{movw}, where the
	\texttt{w} suffix indicates a word (16-bits).
	
	The instruction \texttt{movq \%si, 8(\%rbp)} has an 8-bit (byte) source operand register,
	which is incompatible with \texttt{movq} which operates on quad words (64-bit).
\end{sol}

\begin{ex}{3.4}
	Assume variables \texttt{sp} and \texttt{dp} are declared with types
	\begin{lstlisting}
		src_t *sp;
		dest_t *dp;
	\end{lstlisting}
	where \texttt{src\_t} and \texttt{dest\_t} are types declared with \texttt{typedef}. We wish
	to use the appropriate pair of data movement instructions to implement the operation
	\begin{lstlisting}
		*dp = (dest_t) *sp;
	\end{lstlisting}
	Assume that the values of \texttt{sp} and \texttt{dp} are stored in registers \texttt{\%rdi} and
	\texttt{\%rsi}, respectively. For each entry in the table, show the two instructions that implement
	the specified data movement. The first instruction in the sequence should read from memory, do the
	appropriate conversion, and set the appropriate portion of register \texttt{\%rax}. The second
	instruction should then write the appropriate portion of \texttt{\%rax} to memory. In both cases,
	the portions may be \texttt{\%rax, \%eax, \%ax,} or \texttt{\%al}, and they may differ from one
	another.
	\
	Recall that when performing a cast that involves a size change and a change of ``signedness" in C,
	the operation should change the size first (Section 2.2.6).
	\begin{center}
		\begin{tabular}{ccc}
			\texttt{src\_t} & \texttt{dest\_t} & Instruction\\
			\hline
			\texttt{long} & \texttt{long} & \texttt{movq} \texttt{(\%rdi),} \texttt{\%rax}\\
			{} & {} & \texttt{movq} \texttt{\%rax,} \texttt{(\%rsi)} \\
			\texttt{char} & \texttt{int}  & \makebox[1cm]{\hrulefill}\\
			{} & {} & \makebox[1cm]{\hrulefill}\\
			\texttt{char} & \texttt{unsigned} & \makebox[1cm]{\hrulefill}\\
			{} & {} & \makebox[1cm]{\hrulefill}\\
			\texttt{unsigned char} & \texttt{long} & \makebox[1cm]{\hrulefill}\\
			{} & {} & \makebox[1cm]{\hrulefill}\\
			\texttt{int} & \texttt{char} & \makebox[1cm]{\hrulefill}\\
			{} & {} & \makebox[1cm]{\hrulefill}\\
			\texttt{unsigned} & \texttt{unsigned char} & \makebox[1cm]{\hrulefill}\\
			{} & {} & \makebox[1cm]{\hrulefill}\\
			\texttt{char} & \texttt{short} & \makebox[1cm]{\hrulefill}\\
			{} & {} & \makebox[1cm]{\hrulefill}\\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	We will take \texttt{long} to be signed and 64 bit (quad word, 8 bytes), \texttt{int}
	to be signed and 32 bit (double word, 4 bytes), \texttt{unsigned} to be 32-bit and unsigned,
	\texttt{char} to be signed and 1 byte (8-bit), and \texttt{unsigned char} to be unsigned and 1 byte,
	and \texttt{short} to be 1 word (2 bytes or 16-bits).
	
	\
	
	Going from a source \texttt{char} of 1 byte to a destination \texttt{int} of 4 bytes
	requires using \texttt{movzbl}, since both operands are signed. Since the destination
	is 4 bytes (two words, 32-bit), we use the 32-bit \texttt{\%eax} register.
	
	\
	From signed \texttt{char} of 1 byte to \texttt{unsigned} of 4 bytes requires
	using \texttt{movsbl}. This is because the operation should change the size first, so
	since \texttt{char} is signed, we keep its ``signness" by using \texttt{movsbl} and not
	\texttt{movzbl}. Since the destination is 4 bytes, we use \texttt{movl} for the second operation.
	
	\
	
	From \texttt{unsigned char} of 1 byte to \texttt{long} which is signed and has 8 bytes (64-bit)
	requires that we change the size first, maintaining the signness. This suggests we use a move
	with the \texttt{z} suffix, since the source is unsigned so we should zero extend.
	Since we want a 64-bit result, we could use \texttt{movzbq} with \texttt{\%rax} as the
	destination register. Then the last move simply uses \texttt{movq}. The book also
	uses \texttt{movzbl} \texttt{(\%rdi),} \texttt{\%eax}. This is valid because whenever
	the destination register of a \texttt{movl} instruction is a register, it also sets the
	high-order 4 bytes of the register to 0 (see page 183).
	
	\
	
	From signed \texttt{int} of 4 bytes to signed \texttt{char} of 1 byte, we truncate
	by using \texttt{movb} to move only the lowest order byte and the 8-bit \texttt{\%al} register.
	
	\
	
	From \texttt{unsigned} of 4 bytes to \texttt{unsigned char} of 1 byte, we truncate
	again by using \texttt{movb} and the \texttt{\%al} register.
	
	Finally, from (signed) \texttt{char} of 1 byte to (signed) \texttt{short} of 2 bytes,
	we sign-extend and we use \texttt{movsbw} with the \texttt{\%ax} register.
	\begin{center}
		\begin{tabular}{ccc}
			\texttt{src\_t} & \texttt{dest\_t} & Instruction\\
			\hline
			\texttt{long} & \texttt{long} & \texttt{movq} \texttt{(\%rdi),} \texttt{\%rax}\\
			{} & {} & \texttt{movq} \texttt{\%rax,} \texttt{(\%rsi)} \\
			
			\texttt{char} & \texttt{int}  & \texttt{movsbl} \texttt{(\%rdi),} \texttt{\%eax}\\
			{} & {} & \texttt{movl} \texttt{\%eax,} \texttt{(\%rsi)}\\
			
			
			\texttt{char} & \texttt{unsigned} & \texttt{movsbl} \texttt{(\%rdi),} \texttt{\%eax}\\
			{} & {} & \texttt{movl} \texttt{\%eax} \texttt{\%rsi}\\
			
			\texttt{unsigned char} & \texttt{long} & \texttt{movzbq} \texttt{(\%rdi),} \texttt{\%rax}\\
			{} & {} & \texttt{movq} \texttt{\%rax,} \texttt{(\%rsi)}\\
			
			\texttt{int} & \texttt{char} & \texttt{movb} \texttt{(\%rdi),} \texttt{\%al}\\
			{} & {} & \texttt{movb} \texttt{\%al,} \texttt{(\%rsi)}\\
			
			\texttt{unsigned} & \texttt{unsigned char} & \texttt{movb} \texttt{(\%rdi),} \texttt{\%al}\\
			{} & {} & \texttt{movb} \texttt{\%al,} \texttt{(\%rsi)}\\
			
			\texttt{char} & \texttt{short} & \texttt{movsbw} \texttt{(\%rdi),} \texttt{\%ax}\\
			{} & {} & \texttt{movw} \texttt{\%ax,} \texttt{(\%rsi)}\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.5}
	You are given the following information. A function with prototype
	\begin{lstlisting}[language={}]
			void decode1(long *xp, long *yp, long *zp)
			xp in \%rdi,
		decode1:
			movq	(%rdi),	%r8
			movq	(%rsi),	%rcx
			movq	(%rdx),	%rax
			movq	%r8,	(%rsi)
			movq	%rcx,	(%rdx)
			movq	%rax,	(%rdi)
			ret
	\end{lstlisting}
	Parameters \texttt{xp}, \texttt{yp}, and \texttt{zp} are stored in registers \texttt{\%rdi},
	\texttt{\%rsi}, and \texttt{\%rdx}, respectively. Write C code for \texttt{decode1} that will
	have an effect equivalent to the assembly code shown.
\end{ex}

\begin{sol}
	\
	The indirect memory reference \texttt{(\%rdi)} dereferences \texttt{xp}, yielding its value
	\texttt{*xp},and storing it in register \texttt{\%r8}, conventionally used as the 5th argument
	of a procedure. This amounts to storing the value in a local variable \texttt{t} 
	of the same type \texttt{long}. Similarly, \texttt{(\%rsi)} is an indirect memory references 
	that effectively dereferences \texttt{yp}, yielding its value \texttt{*yp} and storing it
	in register \texttt{\%rcx}, normally used for a procedure's 4th argument. In C, this might
	be storing its in a local variable \texttt{s} of type \texttt{long}. The third memory reference
	\texttt{(\%rdx)} serves to dereference \texttt{zp}, placing its value \texttt{*zp} in the
	\texttt{\%rax} register, conventionally used for a return value of a procedure. Now the
	value stored in register \texttt{\%r8} is stored at the location in memory pointed to by
	the \texttt{\%rsi} register. This is equivalent to the assignment statement \texttt{*yp = t}.
	Next, the value in register \texttt{\%rcx} is moved to the memory location pointed to by
	\texttt{\%rdx}, which is equivalent to the statement \texttt{*zp = s}. Finally, the value
	in the return register \texttt{\%rax} is placed at the memory location pointed to by register
	\texttt{\%rdi}, which is equivalent to setting \texttt{*xp} to the value initially held by
	\texttt{*zp}.
	
	The program below implements the C equivalent:
	\begin{lstlisting}
		void decode1(long *xp, long *yp, long *zp) {
			long t = *xp;
			long s = *yp;
			long r = *zp;
			*yp = t;
			*zp = s;
			*xp = r;
			return r;
		}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.6}
	Suppose register \texttt{\%rax} holds value $x$ and \texttt{\%rcx} holds value $y$. Fill in the
	table below with formulas indicating the value that will be stored in register \texttt{\%rdx}
	for each of the given assembly-code instructions.
	\begin{center}
		\begin{tabular}{cc}
			Instruction & Result\\
			\hline
			\texttt{leaq} \texttt{6(\%rax),} \texttt{rdx} & \makebox[1cm]{\hrulefill}\\
			\texttt{leaq} \texttt{(\%rax,\%rcx),} \texttt{\%rdx} & \makebox[1cm]{\hrulefill}\\
			\texttt{leaq} \texttt{(\%rax,\%rcx,4),} \texttt{\%rdx} & \makebox[1cm]{\hrulefill}\\
			\texttt{leaq} \texttt{7(\%rax,\%rax,8),} \texttt{\%rdx} & \makebox[1cm]{\hrulefill}\\
			\texttt{leaq} \texttt{0xA(,\%rcx,4),} \texttt{\%rdx} & \makebox[1cm]{\hrulefill}\\
			\texttt{leaq} \texttt{9(\%rax,\%rcx,2),} \texttt{\%rdx} & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	
	For \texttt{leaq} \texttt{6(\%rax),} \texttt{rdx}, the memory address used in the memory
	reference operand is that stored at \texttt{\%rax}, which has value $x$ offset by \texttt{6}.
	Therefore, the result is that register \texttt{\%rdx} has value $x+6$. The rest can be done
	similarly.
	\begin{center}
		\begin{tabular}{cc}
			Instruction & Result\\
			\hline
			\texttt{leaq} \texttt{6(\%rax),} \texttt{\%rdx} & $x+6$\\
			\texttt{leaq} \texttt{(\%rax,\%rcx),} \texttt{\%rdx} & $x+y$\\
			\texttt{leaq} \texttt{(\%rax,\%rcx,4),} \texttt{\%rdx} & $x+4y$\\
			\texttt{leaq} \texttt{7(\%rax,\%rax,8),} \texttt{\%rdx} & $7+x+8x=9x+7$\\
			\texttt{leaq} \texttt{0xA(,\%rcx,4),} \texttt{\%rdx} & $10+4y$\\
			\texttt{leaq} \texttt{9(\%rax,\%rcx,2),} \texttt{\%rdx} & $9+x+2y$
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.7}
	Consider the following code, in which we have omitted the expression being computed:
	
	\begin{lstlisting}
long scale2(long x, long y, long z) {
	long t = ___________;
	return t;
}
	\end{lstlisting}
	Compiling the actual function with \texttt{gcc} yields the following assembly code:
	\begin{lstlisting}[language={}]
	long scale2(long x, long y, long z)
	x in %rdi, y in %rsi, z in %rdx
scale2:
	leaq	(%rdi,%rdi,4),	%rax
	leaq	(%rax,%rsi,2),	%rax
	leaq	(%rax,%rdx,8),	%rax
	\end{lstlisting}
\end{ex}

\begin{sol}
	\
	The first line places $5x=x+4x$ in \texttt{\%rax}. The second line places $5x+2y$ in
	\texttt{\%rax}. The last line places $5x+2y+8z$ in \texttt{\%rax}. The function is therefore as follows:
	\begin{lstlisting}
long scale2(long x, long y, long z) {
	long t = 5x + 2y + 8z;
	return t;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.8}
	Assume the following values are stored at the indicated memory addresses and registers:
	\begin{center}
		\begin{tabular}{cccc}
			Address & Value & Register & Value \\
			\hline
			\texttt{0x100} & \texttt{0xFF} & \texttt{\%rax} & \texttt{0x100}\\
			\texttt{0x108} & \texttt{0xAB} & \texttt{\%rcx} & \texttt{0x1}\\
			\texttt{0x110} & \texttt{0x13} & \texttt{\%rdx} & \texttt{0x3}\\
			\texttt{0x118} & \texttt{0x11}
		\end{tabular}
	\end{center}
	Fill in the following table showing the effects of the following instructions in terms of
	both the register or memory location that will be updated and the resulting value:
	\begin{center}
		\begin{tabular}{ccc}
			Instruction & Destination & Value\\
			\hline
	\texttt{addq} \texttt{\%rcx,} \texttt{(\%rax)} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
	\texttt{subq} \texttt{\%rdx,} \texttt{8(\%rax)} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
	\texttt{imulq} \texttt{\$16,} \texttt{(\%rax,\%rdx,8)} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
	\texttt{incq} \texttt{16(\%rax)} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
	\texttt{decq} \texttt{\%rcx} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
	\texttt{subq} \texttt{\%rdx,} \texttt{\%rax} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	The \texttt{addq} \texttt{\%rcx,} \texttt{(\%rax)} instruction means that we add the quad
	stored in register \texttt{\%rcx}, namely \texttt{0x1}, to the value store at the memory location
	whose address is the value \texttt{0x100} stored at \texttt{\%rax}. This means we add \texttt{0x1}
	and \texttt{0xFF}, which results in \texttt{0x100}, and store its value at address \texttt{0x100}.
	
	\
	
	The \texttt{subq} \texttt{\%rdx,} \texttt{8(\%rax)} instruction means we subtract the quad stored
	in register \texttt{\%rdx}, which is \texttt{0x3}, from the value stored at the memory location
	whose address is the value stored at \texttt{\%rax} offset by 8. Since \texttt{\%rax} has value
	\texttt{0x100}, we add 8 to get \texttt{0x108}, and the value at that location is \texttt{0xAB}.
	Subtracting \texttt{0x3} results in \texttt{0xA8}.
	
	\
	
	The \texttt{imulq} \texttt{\$16,} \texttt{(\%rax,\%rdx,8)} instruction means we multiply by
	16 the value stored at the destination address. Since \texttt{\%rax} is \texttt{0x100} and
	\texttt{\%rdx} is 3, the destination address is \texttt{0x100 + 0x18}, which yields \texttt{0x118}.
	The value at that address is \texttt{0x11}, so multiplying by \texttt{16} yields \texttt{0x110}.
	
	\
	
	The \texttt{incq} \texttt{16(\%rax)} instruction says we increment by 1 the value stored at
	memory location whose address is that which is stored at \texttt{\%rax} offset by 16.
	The address is \texttt{0x100 + 16} or \texttt{0x110}, so we are incrementing \texttt{0x13} by
	1 to \texttt{0x14}.
	
	\
	
	The \texttt{decq} \texttt{\%rcx} instruction decrements the value held in the \texttt{\%rcx}
	register by 1, so \texttt{\%rcx} goes from being \texttt{0x1} to being \texttt{0x0}.
	
	\
	
	The \texttt{subq} \texttt{\%rdx,} \texttt{\%rax} instruction subtracts the value
	stored at \texttt{\%rdx} from the value at \texttt{\%rax}. That is, we subtract \texttt{0x3}
	from \texttt{0x100}, yielding \texttt{0xFD}.
	\begin{center}
		\begin{tabular}{ccc}
			Instruction & Destination & Value\\
			\hline
	\texttt{addq} \texttt{\%rcx,} \texttt{(\%rax)} & \texttt{0x100} & \texttt{0x100}\\
	\texttt{subq} \texttt{\%rdx,} \texttt{8(\%rax)} & \texttt{0x108} & \texttt{0xA8}\\
	\texttt{imulq} \texttt{\$16,} \texttt{(\%rax,\%rdx,8)} & \texttt{0x118} & \texttt{0x110}\\
	\texttt{incq} \texttt{16(\%rax)} & \texttt{0x110} & \texttt{0x14}\\
	\texttt{decq} \texttt{\%rcx} & \texttt{\%rcx} & \texttt{0x0} \\
	\texttt{subq} \texttt{\%rdx,} \texttt{\%rax} &\texttt{\%rax} & \texttt{0xFD}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.9}
	Suppose we want to generate assembly code for the following C function:
	\begin{lstlisting}
long shift_left4_rightn(long x, long n)
{
	x <<= 4;
	x >>= n;
	return x;
}
	\end{lstlisting}
	The code that follows is a portion of the assembly code that performs the actual shifts
	and leaves the final value in register \texttt{\%rax}. Two key instructions have been
	omitted. Parameters \texttt{x} and \texttt{n} are stored in registers \texttt{\%rdi}
	and \texttt{\%rsi}, respectively.
	\begin{lstlisting}[language={}]
	long shift_left4_rightn(long x, long n)
	x in %rdi, n in %rsi
shift_left4_rightn:
	movq	%rdi,	%rax	// Get x
	____________________	// x <<=4
	movl	%esi,	%ecx	// Get n (4 bytes)
	____________________	// x >>= n
	\end{lstlisting}
	Fill in the missing instructions, following the annotations on the right. The right shift
	should be performed arithmetically.
\end{ex}

\begin{sol}
	\
\begin{lstlisting}[language={}]
	long shift_left4_rightn(long x, long n)
	x in %rdi, n in %rsi
shift_left4_rightn:
	movq	%rdi,	%rax	// Get x
	salq	$4,		%rax	// x <<=4
	movl	%esi,	%ecx	// Get n (4 bytes)
	sarq	%cl,		%rax	// x >>= n
\end{lstlisting}
\end{sol}

\begin{ex}{3.10}
	In the following variant of the function of Figure 3.11(a), the expressions have been replaced
	by blanks:
	\begin{lstlisting}
long arith2(long x, long y, long z)
{
	long t1 = ________;
	long t2 = ________;
	long t3 = ________;
	long t4 = ________;
	return t4;
}
	\end{lstlisting}
	The portion of the generated assembly code implementing these expressions is as follows:
\begin{lstlisting}[language={}]
	long arith2(long x, long y, long z)
	x in %rdi, y in %rsi, z in %rdx
arith2:
	orq		%rsi,	%rdi
	sarq	$3,		%rdi
	notq	%rdi
	movq	%rdx,	%rax
	subq	%rdi,	%rax
	ret
\end{lstlisting}
	Based on this assembly code, fill in the missing portions of
	the C code.
\end{ex}

\begin{sol}
	\
	The instruction \texttt{orq \%rsi, \%rdi} calculates \texttt{t1 = x | y}.
	The instruction \texttt{sarq \$3, \%rdi} calculates \texttt{t2 = t1 >> 3},
	or equivalently \texttt{t2 = 8 * t1}. The instruction \texttt{notq \%rdi}
	calculates \texttt{t3 = \~{}t2}. The instructions \texttt{movq \%rdx, \%rax}
	and \texttt{subq \%rdi, \%rax} together transform to
	\texttt{t4 = z - t3}. The resulting C program is below:
	\begin{lstlisting}
		long arith2(long x, long y, long z)
		{
			long t1 = x | y;
			long t2 = 8 * t1;
			long t3 = ~t2;
			long t4 = z - t3;
			return t4;
		}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.11}
	It is common to find assembly-code lines of the form
	\begin{lstlisting}[language={}]
xorq \%rdx \%rdx
	\end{lstlisting}
	in the code that was generated from C where no \emph{exclusive OR} operations
	were present.
	\begin{enumerate}[label=(\alph*)]
		\item Explain the effect of this particular \emph{exclusive-OR} instruction
		and what useful operation it implements.
		\item What would be the more straightforward way to express this operation
		in assembly code?
		\item Compare the number of bytes to encode these two different implementations
		of the same operation.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Noting that \texttt{0\^{}0} and \text{1\^{}1} are both 0, the resulting operation is to yield a value 0 and place it in \texttt{\%rdx}.
		This is essentially zeroing the register.
		\item The straightforward way to write this would be
		\texttt{imul \$0, \texttt{\%rdx}}, or \texttt{movq \$0 \%rdx}.
		\item 
	\end{enumerate}
\end{sol}

\begin{ex}{3.12}
	Consider the following function for computing the quotient and remainder of two unsigned
	64-bit numbers:
	\begin{lstlisting}
void uremdiv(unsigned long x, unsigned long y,
			 unsigned long *qp, unsigned long *rp) {
	unsigned long q = x/y;
	unsigned long r = x%y;
	*qp = q;
	*rp = r;
}
	\end{lstlisting}
	Modify the assembly code shown for signed division to implement this function.
\end{ex}

\begin{sol}
	\
	The text presented an function \texttt{remdiv} that was mostly equivalent to \texttt{uremdiv}, but with
	arguments of type \texttt{long} instead. In other words, it operated with signed numbers.
	To achieve it, the following assembly instructions were carried out:
	\begin{lstlisting}[language={}]
	void remdiv(long x, long y, long *qp, long *rp)
	x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
	movq	%rdx,	%r8		// Copy qp
	movq	%rdi,	%rax	// Move x to lower 8 bytes of dividend
	cqto					// Sign-extend to upper 8 bytes of dividend
	idivq	%rsi			// Divide by y
	movq	%rax,	(%r8)	// Store quotient at qp
	movq	%rdx,	(%rcx)	// Store remainder at rp
	ret
	\end{lstlisting}
	The key instruction is \texttt{cqto}, which reads the sign bit from \texttt{\%rax}
	and copies it across all of \texttt{\%rdx}. For unsigned division, we instead want
	all zeros in register \texttt{\%rdx}, so we replace \texttt{\%cqto} with
	\texttt{movq \$0, \%rdx}:
		\begin{lstlisting}[language={}]
	void remdiv(unsigned long x, unsigned long y, unsigned long *qp, unsigned long *rp)
	x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
uremdiv:
	movq	%rdx,	%r8		// Copy qp
	movq	%rdi,	%rax	// Move x to lower 8 bytes of dividend
	moveq	$0,		%rdx	// Zero the register to signify unsigned arithmetic
	idivq	%rsi			// Divide by y
	movq	%rax,	(%r8)	// Store quotient at qp
	movq	%rdx,	(%rcx)	// Store remainder at rp
	ret
	\end{lstlisting}
\end{sol}

\begin{ex}{3.13}
	The C code
	\begin{lstlisting}
int comp(data_t a, data_t b) {
	return a COMP b;
}
	\end{lstlisting}
	shows a general comparison between arguments \texttt{a} and \texttt{b}, where \texttt{data\_t},
	the data type of the arguments, is defined (via \texttt{typedef}) to be one of the integer types
	listed in Figure 3.1 (\texttt{char}, \texttt{short}, \texttt{int}, \texttt{long}, or \texttt{char *})
	and either signed or unsigned. The comparison \texttt{COMP} is defined via \texttt{\#define}.
	
	\
	Suppose \texttt{a} is in some portion of \texttt{\%rdi} while \texttt{b} is in some portion of
	\texttt{\%rsi}. For each of the following instruction sequences, determine which data types
	\texttt{data\_t} and which comparisons \texttt{COMP} could cause the compiler to generate this code.
	(There can be multiple correct answers; you should list them all.)
	\begin{enumerate}[label=(\alph*)]
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{cmpl} & \texttt{\%esi,} & \texttt{\%edi}\\
				\texttt{setl} & \texttt{\%al}
			\end{tabular}
		\end{center}
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{cmpw} & \texttt{\%si,} & \texttt{\%di}\\
				\texttt{setge} & \texttt{\%al}
			\end{tabular}
		\end{center}
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{cmpb} & \texttt{\%sil,} & \texttt{\%dil}\\
				\texttt{selbe} & \texttt{\%al}
			\end{tabular}
		\end{center}
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{cmpq} & \texttt{\%rsi,} & \texttt{\%rdi}\\
				\texttt{selne} & \texttt{\%al}
			\end{tabular}
		\end{center}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The registers \texttt{\%esi} and \texttt{\%edi} are the lower 32-bit portions of
		\texttt{\%rsi} and \texttt{\%rdi}, respectively. Therefore, \texttt{data\_t} is a 32-bit
		integer. Moreover, the \texttt{setl} suggests a signed \texttt{<} comparison. Therefore,
		\texttt{COMP} is \texttt{<} and \texttt{data\_t} is \texttt{int}.
		\item Here, \texttt{cmpw} deals with 16-bit values, which is consistent with the
		fact that \texttt{\%si} and \texttt{\%di} are the lower 16-bit portions of \texttt{\%rsi}
		and \texttt{\%rdi}, respectively. Therefore, \texttt{data\_t} is \texttt{short}. Also,
		\texttt{setge} is the signed \texttt{>=} instruction.
		\item Here, \texttt{cmpb} deals with 8-bit values, and \texttt{\%sil} and \texttt{\%dil} are
		the lower 8-bit portions of the \texttt{\%rsi} and \texttt{\%rdi} registers, respectively.
		Since \texttt{setbe} is the unsigned \texttt{<=} instruction, it follows that \texttt{data\_t}
		is \texttt{unsigned char}.
		\item Here \texttt{selne} is the \texttt{!=} comparison operator, which applies to both signed
		and unsigned. Since \texttt{\%rsi} and \texttt{\%rdi} are 64-bit registers, it follows that
		\texttt{data\_t} can be, signed or unsigned \texttt{long}, or any pointer type.
	\end{enumerate}
\end{sol}

\begin{ex}{3.14}
	The C code
	\begin{lstlisting}
int test(data_t a) {
	return a TEST 0;
}
	\end{lstlisting}
	shows a general comparison between \texttt{a} and 0, where we can set the data type of the argument by
	declaring \texttt{data\_t} with a \texttt{typedef}, and the nature of the comparison by declaring
	\texttt{TEST} with a \texttt{\#define} declaration. The following instruction sequences implement the
	comparison, where \texttt{a} is held in some portion of registers \texttt{\%rdi}. For each sequence,
	determine which data types \texttt{data\_t} and which comparisons \texttt{TEST} could cause the compiler
	to generate this code. (There can be multiple correct answers; list all correct ones.)
	\begin{enumerate}[label=(\alph*)]
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{testq} & \texttt{\%rdi,} &\texttt{\%rdi}\\
				\texttt{setge} & \texttt{\%al}
			\end{tabular}
		\end{center}
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{testw} & \texttt{\%di,} &\texttt{\%di}\\
				\texttt{sete} & \texttt{\%al}
			\end{tabular}
		\end{center}
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{testb} & \texttt{\%dil,} &\texttt{\%dil}\\
				\texttt{seta} & \texttt{\%al}
			\end{tabular}
		\end{center}
		\item \begin{center}
			\begin{tabular}{ccc}
				\texttt{testl} & \texttt{\%edi,} &\texttt{\%edi}\\
				\texttt{setle} & \texttt{\%al}
			\end{tabular}
		\end{center}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The \texttt{setge} indicates signed comparison, so \texttt{TEST} is \texttt{>=}.
		The \texttt{testq} suggests we are using a quad (64-bit), so \texttt{data\_t} is
		a \texttt{long}.
		\item The \texttt{sete} is used for signed or unsigned equality checks, so \texttt{TEST} is
		\texttt{=}. The \texttt{testw} suggests we are operating on a word (16-bit), so
		\texttt{data\_t} is either \texttt{short} or \texttt{unsigned short}.
		\item The \texttt{seta} is used for unsigned above comparison, so \texttt{TEST} is \texttt{>}.
		The \texttt{testb} is used for 8-bit comparison, and \texttt{\%dil} is an 8-bit portion of
		\texttt{\%rdi} register, so \texttt{data\_t} is an \texttt{unsigned char}.
		\item The \texttt{setle} is used for signed less than or equal comparison, so \texttt{TEST}
		is \texttt{<=}. The \texttt{\%edi} is the lower 32-bit portion of the \texttt{\%rdi} register,
		so \texttt{data\_t} is \texttt{int}.
	\end{enumerate}
\end{sol}

\begin{ex}{3.15}
	In the following excerpts from a disassembled binary, some of the information has been replaced
	by \texttt{X}'s. Answer the following questions about the instructions:
	\begin{enumerate}[label=(\alph*)]
		\item What is the target of the \texttt{je} instruction below? (You do not need to know
		anything about the \texttt{callq} instruction here.)
		\begin{lstlisting}[language={}]
4003fa: 74 02				je		XXXXXX
4003fc: ff d0				callq	*%rax
		\end{lstlisting}
		\item What is the target of the \texttt{je} instruction below?
		\begin{lstlisting}[language={}]
40042f: 74 f4				je		XXXXXX
400431: 5d					pop 	%rbp
		\end{lstlisting}
		\item What is the address of the \texttt{ja} and \texttt{pop} instructions?
		\begin{lstlisting}[language={}]
XXXXXX: 77 02				ja		400547
XXXXXX: 5d					pop		%rbp
		\end{lstlisting}
		\item In the code that follows, the jump target is encoded in PC-relative form
		as a $4$-byte two's complement number. The bytes are listed from least to most,
		reflecting the little-endian byte ordering of x86-64. What is the address of
		the jump target?
		\begin{lstlisting}[language={}]
4005e8:	e9 73 ff ff ff		jmp		XXXXXX
4005ed: 90					nop		XXXXXX
		\end{lstlisting}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The \texttt{0x02} in \texttt{74 02} must be added to \texttt{4003fc}, the
		address of the following instruction, to yield \texttt{4003fe} as the jump target
		of \texttt{je}.
		\item The \texttt{f4} in \texttt{74 f4} must be added to \texttt{400431}, the
		address of the next instruction. Since \texttt{f4} is a single byte has decimal
		value $-12$ (in two's complement), we subtract 12 from the hex address \texttt{400431}
		and obtain \texttt{400425}.
		\item Adding \texttt{0x02} from \texttt{77 02} to \texttt{XXXXXX} should give
		\texttt{400547}, and since \texttt{0x02} is decimal 2, we get that the \texttt{XXXXXX}
		that follows the jump instruction must be \texttt{400545}. Since the instruction
		\texttt{5d} at that location is 2 bytes after the first instruction in the
		\texttt{ja} line, we subtract 2 bytes to get \texttt{400543} for the byte address
		instruction of the \texttt{ja} line.
		\item The \texttt{73 ff ff ff} is written in little-endian (least to most significant)
		bit, so we can re-write it as \texttt{ff ff ff 73} (from most to least significant).
		This is a negative number since the most significant bit is 1, and it is a sign
		extension of \texttt{01 73}. Since \texttt{01 00} is 256 and \texttt{00 73} is 115,
		this means we have $-256+115=-141$. Therefore we add $-141$ to the following address,
		\texttt{4005ed}, to get the jump target address which. The \texttt{ed} portion 237,
		and $237-141=96$, or \texttt{0x60}. Therefore the jump target address is \texttt{400560}.
		has value 
	\end{enumerate}
\end{sol}

\begin{ex}{3.16}
	When given the C code
	\begin{lstlisting}
void cond(long a, long *p)
{
	if (p && a > &p)
		*p = a;
}
	\end{lstlisting}
	\texttt{gcc} generates the following code:
	\begin{lstlisting}[language={}]
	void cond(long a, long *p)
	a in %rdi, p in %rsi
cond:
	testq	%rsi,	%rsi
	je		.L1
	cmpq	%rdi,	(%rsi)
	jge		.L1
	movq	%rdi,	(%rsi)
.L1:
	rep; ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item Write a goto version in C that performs the same computation and mimics the control flow
		of the assembly code, in the style shown in Figure 3.16(b). You might find it helpful to first
		annotate the assembly code as we have done in our examples.
		\item Explain why the assembly code contains two conditional branches even though the C code
		has only one \texttt{if} statement.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item
		The annotated assembly is below:
	\begin{lstlisting}[language={}]
	void cond(long a, long *p)
	a in %rdi, p in %rsi
cond:
	testq	%rsi,	%rsi	// Test p
	je		.L1				// If p != NULL (meaning 0) go to done
	cmpq	%rdi,	(%rsi)	// comp (*p):a
	jge		.L1				// if >= goto done
	movq	%rdi,	(%rsi)	// *p = a;
.L1:
	rep; ret				// return
	\end{lstlisting}
	The goto version is below:
	\begin{lstlisting}
void goto_cond(long a, long *p)
{
	if (p == 0)
		goto done;
	if (*p >= a)
		goto done;
	*p=a;
	done:
		return;
	
}
	\end{lstlisting}
	\item There are two conditional branches because the condition
	expression in the \texttt{if} statement is the \texttt{AND} of
	two condition expressions.
	\end{enumerate}
\end{sol}

\begin{ex}{3.17}
	An alternate rule for translating \texttt{if} statements into goto
	code is as follows:
	\begin{lstlisting}[language={}]
	t = test-expr;
	if (t)
		goto true;
	else-statement
	goto done;
true:
	then-statement
done:
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item Rewrite the goto version of \texttt{absdiff\_se} based
		on this alternate rule.
		\item Can you think of any reasons for choosing one rule over
		the other?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item 
		\begin{lstlisting}
void gotov2_absdiff_se(long x, long y)
{
	long result;
	if (x < y)
		goto x_le_y;
	ge_cnt++;
	result = x - y;
	goto done;
x_le_y:
	le_cnt++;
	result = y - x;
done:
	return result;
}
		\end{lstlisting}
		\item I don't know! However the book mention that the first one is
		preferable when there is no else branch, since it's easier
		to translate.
	\end{enumerate}
\end{sol}

\begin{ex}{3.18}
	Starting with C code of the form
	\begin{lstlisting}
long test(long x, long y, long z) {
	long val = _______;
	if (________) {
		if (______)
			val = ______;
		else
			val = ______;
	} else if (______)
		val = _________;
	return val;
}
	\end{lstlisting}
	\texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
	long test(long x, long y, long z)
	x in %rdi, y in %rsi, z in %rdx
test:
	leaq	(%rdi, %rsi),	%rax
	addq	%rdx,	%rax
	cmpq	$-3,	%rdi
	jge		.L2
	cmpq	%rdx,	%rsi
	jge		.L3
	movq	%rdi,	%rax
	imulq	%rsi,	%rax
	ret
.L3:
	movq	%rsi,	%rax
	imulq	%rdx,	%rax
	ret
.L2:
	cmpq	$2,		%rdi
	jle		.L4
	movq	%rdi,	%rax
	imulq	%rdx,	%rax
.L4:
	rep; ret
	\end{lstlisting}
	Fill in the missing expressions in the C code.
\end{ex}

\begin{sol}
	\
	First we can annotate the assembly:
	\begin{lstlisting}[language={}]
	long test(long x, long y, long z)
	x in %rdi, y in %rsi, z in %rdx
test:
	leaq	(%rdi, %rsi),	%rax	// long t = x + y;
	addq	%rdx,	%rax			// long val = t + z;
	cmpq	$-3,	%rdi			// Compare x:-3
	jge		.L2						// if >= go to .L2
	cmpq	%rdx,	%rsi			// Compare y:z
	jge		.L3						// if >= goto .L3
	movq	%rdi,	%rax			// val = x;
	imulq	%rsi,	%rax			// val *= y;
	ret								// return val;
.L3:
	movq	%rsi,	%rax			// val = y;
	imulq	%rdx,	%rax			// val *= z;
	ret								// return val;
.L2:
	cmpq	$2,		%rdi			// Compare x:2
	jle		.L4						// if <= goto .L4
	movq	%rdi,	%rax			// val = x;
	imulq	%rdx,	%rax			// val *= z;
.L4:
	rep; ret						// return val;
\end{lstlisting}
	From this, the C code is
	\begin{lstlisting}
long test(long x, long y, long z) {
	long val = x + y + z;
	if (x < -3) {
		if (y < z)
			val = x * y;
		else
			val = y * z;
	} else if (x > 2)
		val = x * z;
	return val;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.19}
	Running on an older processor model, our code required around 16
	cycles when the branching pattern was highly predictable, and around
	31 cycles when the pattern was random.
	\begin{enumerate}[label=(\alph*)]
		\item What is the appropriate miss penalty?
		\item How many cycles would the function require when the branch
		was mispredicted?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item As discussed in the text, if $p$ is the probability
		of misprediction, $T_{OK}$ is the time to execute the code
		without misprediction, and $T_{MP}$ is the misprediction penalty,
		then the average time to execute the code is given by
		\begin{align*}
		T_{avg}(p)&=(1-p)T_{OK}+p(T_{OK}+T_{MP})=T_{OK}+pT_{MP}\\
		T_{MP}&=\frac{1}{p}\left(T_{avg}(p)-T_{OK}\right)
		\end{align*}
		We are given $T_{OK}=16$, and $T_{ran}=T_{avg}(p)=31$, so
		\begin{align*}
			T_{MP}&=2(31-16)=30
		\end{align*}
		\item If mispredicted, the function would require $T_{OK}+T{MP}=46$
		cycles.
	\end{enumerate}
\end{sol}

\begin{ex}{3.20}
	In the following C function, we have left the definition of \texttt{OP} incomplete:
	\begin{lstlisting}
#define OP	_______	/* Unknown operator */

long arith(long x) {
	return x OP 8;
}
	\end{lstlisting}
	When compiled, \texttt{gcc} generated the following assembly code:
	\begin{lstlisting}[language={}]
	long arith(long x)
	x in %rdi
arith:
	leaq	7(%rdi),	%rax
	testq	%rdi,		%rdi
	cmovns	%rdi,		%rax
	sarq	$3,			%rax
	ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item What operation is \texttt{OP}?
		\item Annotate the code to explain how it works.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The book explains that \texttt{OP} is \texttt{/} because dividing
		by a power of $2$ involves first biasing the number so that it rounds towards 0.
		\item 
	\begin{lstlisting}[language={}]
	long arith(long x)
	x in %rdi
arith:
	leaq	7(%rdi),	%rax	// int t = x + 7
	testq	%rdi,		%rdi	// test x
	cmovns	%rdi,		%rax	// if >=0 then t = x
	sarq	$3,			%rax	// t >>= 3; or equivalently t /= 8;
	ret							// return t;
\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{3.21}
	Starting with C code of the form
	\begin{lstlisting}
long test(long x, long y) {
	long val = ___________;
	if (___________) {
		if (_________)
			val = ____________;
		else
			val = ____________;
	} else if (__________)
		val = ________;
	return val;
}
	\end{lstlisting}
	\texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
	long test(long x, long y)
	x in %rdi, y in %rsi
test:
	leaq	0(,%rdi,8),	%rax
	testq	%rsi,		%rsi
	jle		.L2
	movq	%rsi,		%rax
	subq	%rdi,		%rax
	movq	%rdi,		%rdx
	andq	%rsi,		%rdx
	cmpq	%rsi,		%rdi
	cmovge	%rdx,		%rax
	ret
.L2:
	addq	%rsi,		%rdi
	cmpq	$-2,		%rsi
	cmovle	%rdi,		%rax
	ret
	\end{lstlisting}
	Fill in the missing expressions in the C code.
\end{ex}

\begin{sol}
	\
	We can first annotate the assembly:
	\begin{lstlisting}[language={}]
	long test(long x, long y)
	x in %rdi, y in %rsi
test:
	leaq	0(,%rdi,8),	%rax	// long r = x * 8;
	testq	%rsi,		%rsi	// test y
	jle		.L2					// if <= 0 goto .L2
	movq	%rsi,		%rax	// r = y;
	subq	%rdi,		%rax	// r -= x;
	movq	%rdi,		%rdx	// long s = x;
	andq	%rsi,		%rdx	// s &= y;
	cmpq	%rsi,		%rdi	// compare x:y
	cmovge	%rdx,		%rax	// if >= then r = s;
	ret							// return r;
.L2:
	addq	%rsi,		%rdi	// x += y;
	cmpq	$-2,		%rsi	// compare y:-2
	cmovle	%rdi,		%rax	// if y <= -2 then r = x;
	ret							// return r;
	\end{lstlisting}
	This reveals that the C code is as follows:
	\begin{lstlisting}
long test(long x, long y) {
	long val = x * 8;
	if (y > 0) {
		if (x >= y)
			val = x & y;
		else
			val = y - x;
	} else if (y <= -2)
		val = x + y;
	return val;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.22}
	\
	\begin{enumerate}[label=(\alph*)]
		\item What is the maximum value of $n$ for which we can represent $n!$ with
		a 32-bit \texttt{int}?
		\item What about a 64-bit \texttt{long}?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	I thought to print a table of values, but not how to determine overflow. The solution
	provided in the book was to use \texttt{tmult\_ok} from practice problem 2.35 to check
	for overflow. I have provided this in \texttt{./22-factorial} for the case of \texttt{int},
	which shows that $n=12$ is the maximum before overflow, meaning $12!$ is ok, but $13!$
	overflows.
\end{sol}

\begin{ex}{3.23}
	For the C code
	\begin{lstlisting}
long dw_loop(long x) {
	long y = x*x;
	long *p = &x;
	long n = 2*x;
	do {
		x += y;
		(*p)++;
		n--;
	} while (n > 0);
	return x;
}
	\end{lstlisting}
	\texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
	long dw_loop(long x)
	x initially in %rdi
dw_loop:
	movq	%rdi,			%rax
	movq	%rdi,			%rcx
	imulq	%rdi,			%rcx
	leaq	(%rdi,%rdi),	%rdx
.L2:
	leaq	1(%rcx,%rax),	%rax
	subq	$1,				%rdx
	testq	%rdx,			%rdx
	jg		.L2
	rep; ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item Which registers are used to hold program values \texttt{x}, \texttt{y},
		and \texttt{n}?
		\item How has the compiler eliminated the need for pointer variable \texttt{p}
		and the pointer dereferencing implied by the expression \texttt{(*p)++}?
		\item Add annotations to the assembly code describing the operation of the program,
		similar to those shown in Figure 3.19(c).
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Initially, \texttt{x} is in \texttt{\%rdi}, but then it is placed
		in \texttt{\%rax} since it is to be returned after modification.
		The variable \texttt{y} is placed in the \texttt{\%rcx} register,
		and \texttt{n} is placed in the \texttt{\%rdx} register.
		\item It has done so through the use of the \texttt{leaq} instruction
		to both increment \texttt{x} by 1 (the effect of \texttt{(*p)++}) in
		addition to increment \texttt{x} by \texttt{y}.
		\item The annotations are below:
\begin{lstlisting}[language={}]
	long dw_loop(long x)
	x initially in %rdi
dw_loop:
	movq	%rdi,			%rax	// long result = x;
	movq	%rdi,			%rcx	// y = x;
	imulq	%rdi,			%rcx	// y *= x;
	leaq	(%rdi,%rdi),	%rdx	// long n = 2 * x;
.L2:
	leaq	1(%rcx,%rax),	%rax	// result += y + 1;
	subq	$1,				%rdx	// n -= 1
	testq	%rdx,			%rdx	// test n
	jg		.L2						// if > 0 goto .L2
	rep; ret						// return result
\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{3.24}
	For C code having the general form
	\begin{lstlisting}
long loop_while(long a, long b)
{
	long result = _________;
	while (________) {
		result = ________;
		a = ________;
	}
	return result;
}
	\end{lstlisting}
	\texttt{gcc}, run with command-line option \texttt{-Og}, produces the
	following code:
	\begin{lstlisting}[language={}]
	long loop_while(long a, long b)
	a in %rdi, b in %rsi
loop_while:
	movl	$1,				%eax
	jmp		.L2
.L3:
	leaq	(%rdi,%rsi),	%rdx
	imulq	%rdx,			%rax
	addq	$1,				%rdi
.L2:
	cmpq	%rsi,			%rdi
	jl		.L3
	rep; ret
	\end{lstlisting}
	We can see that the compiler used a jump-to-middle translation using
	the \texttt{jmp} instruction on line 3 to jump to the test starting
	with label \texttt{.L2}. Fill int he missing parts of the C code.
\end{ex}

\begin{sol}
	\
	Below is my annotation of the assembly produced by \texttt{gcc}:
	\begin{lstlisting}[language={}]
	long loop_while(long a, long b)
	a in %rdi, b in %rsi
loop_while:
	movl	$1,				%eax	// long result = 1;
	jmp		.L2						// goto .L2
.L3:
	leaq	(%rdi,%rsi),	%rdx	// long t = a + b;
	imulq	%rdx,			%rax	// result *= t;
	addq	$1,				%rdi	// a += 1;
.L2:
	cmpq	%rsi,			%rdi	// compare a:b
	jl		.L3						// if < goto .L3
	rep; ret
	\end{lstlisting}
	Based on this, I filled in the C code as shown below:
	\begin{lstlisting}
long loop_while(long a, long b)
{
	long result = 1;
	while (a < b) {
		result = result * (a + b);
		a = a + 1;
	}
	return result;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.25}
	For C code having the general form
	\begin{lstlisting}
long loop_while2(long a, long b)
{
	long result = ___________;
	while (___________) {
		result = __________;
		b = ___________;
	}
	return result;
}
	\end{lstlisting}
	\texttt{gcc}, when run with command-line option \texttt{-O1}, produces
	the following code:
	\begin{lstlisting}[language={}]
	a in %rdi, b in %rsi
loop_while2:
	testq	%rsi,	%rsi
	jle		.L8
	movq	%rsi,	%rax
.L7:
	imulq	%rdi,	%rax
	subq	%rdi,	%rsi
	testq	%rsi,	%rsi
	jg		.L7
	rep; ret
.L8:
	movq	%rsi,	%rax
	ret
	\end{lstlisting}
	We can see that the compiler used a guarded-do translation, using the \texttt{jle}
	instruction on line 3 to skip over the loop code when the initial test fails.
	Fill in the missing parts of the C code. Note that the control structure in the
	assembly code does not exactly match what would be obtained by a direct translation
	of the C code according to our translation rules. In particular, it has two different
	\texttt{ret} instructions (lines 10 and 13). However, you can fill out the missing
	portions of the C code in a way that it will have equivalent behavior to the
	assembly code.
\end{ex}

\begin{sol}
	\
	First I annotated the assembly like so:
\begin{lstlisting}[language={}]
	a in %rdi, b in %rsi
loop_while2:
	testq	%rsi,	%rsi	// test b
	jle		.L8				// if <= 0 goto .L8
	movq	%rsi,	%rax	// long result = b;
.L7:
	imulq	%rdi,	%rax	// result *= a;
	subq	%rdi,	%rsi	// b -= a;
	testq	%rsi,	%rsi	// test b
	jg		.L7				// if > 0 goto .L7
	rep; ret				// return result;
.L8:
	movq	%rsi,	%rax	// result = b;
	ret						// return result;
\end{lstlisting}
	The corresponding C then becomes:
		\begin{lstlisting}
long loop_while2(long a, long b)
{
	long result = result = b;
	while (b > 0) {
		result = result * a;
		b = b - a;
	}
	return result;
}
		\end{lstlisting}
\end{sol}

\begin{ex}{3.26}
	A function \texttt{fun\_a} has the following overall structure:
	\begin{lstlisting}
long fun_a(unsigned long x) {
	long val = 0;
	while ( ... ) {
		.
		.
		.
	}
	return ...;
}
	\end{lstlisting}
	The \texttt{gcc} C compiler generates the following assembly code:
	\begin{lstlisting}[language={}]
	long fun_a(unsigned long x)
	x in %rdi
fun_a:
	movl	$0,		%eax
	jmp		.L5
.L6:
	xorq	%rdi,	%rax
	shrq	%rdi			// Shift right by 1
.L5:
	testq	%rdi,	%rdi
	jne		.L6
	andl	$1,		%eax
	ret
	\end{lstlisting}
	Reverse engineer the  operation of this code and then do the following:
	\begin{enumerate}[label=(\alph*)]
		\item Determine what loop translation method was used.
		\item Use the assembly-code version to fill in the missing parts of
		the C code.
		\item Describe in English what this function computes.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	I first annotated the assembly as follows:
\begin{lstlisting}[language={}]
	long fun_a(unsigned long x)
	x in %rdi
fun_a:
	movl	$0,		%eax	// long result = 0;
	jmp		.L5				// goto .L5
.L6:
	xorq	%rdi,	%rax	// result = result ^ x;
	shrq	%rdi			// x >>= 1;
.L5:
	testq	%rdi,	%rdi	// test x
	jne		.L6				// if != 0 goto .L6
	andl	$1,		%eax	// result = result & 1;
	ret						// return result;
\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item The \texttt{jmp .L5} instruction and the tests and jump
		in the lines that proceed label \texttt{.L5} suggests a
		jump-to-middle strategy.
		\item The C code can be filled in as follows:
		\begin{lstlisting}
long fun_a(unsigned long x) {
	long val = 0;
	while ( x != 0 ) {
		val = val ^ x;
		x = x >> 1;
	}
	return val & 1;
}
		\end{lstlisting}
		\item Since \texttt{val} is 0, \texttt{0 \^{} 0} is \texttt{0}, and
		\texttt{0 \^{} 1} is \texttt{1}, it follows that the initial \texttt{val \^{} x}
		sets \texttt{val} equal to \texttt{x}. Then, shifting \texttt{x} results in
		the least significant bit of \texttt{val} being XORed with the least significant
		bit of \texttt{x} after the shift. When the loop ends, the least significant
		bit of \texttt{val} will have the result of XORing all of the bits in \texttt{x},
		and the \texttt{val \& 1} yields that value. Since the \texttt{x} is an
		\texttt{unsigned long}, which has an even number of bits, and since the
		\texttt{XOR} of an even number of bits yields 0 if a number has an even number
		of 1 bits (or no 1 bits at all) and 1 otherwise, it follows that this function
		returns 1 if \texttt{x} has an odd number of 1 bits, and 0 otherwise.
		
	\end{enumerate}
\end{sol}

\begin{ex}{3.27}
	Write goto code for \texttt{fact\_for} based on first transforming it to
	a \texttt{while} loop and then applying the guarded-do transformation.
\end{ex}

\begin{sol}
	\
	The \texttt{fact\_for} function is given below:
	\begin{lstlisting}
long fact_for(long n)
{
	long i;
	long result = 1;
	for (i = 2; i <= n; i++)
		result += i;
	return result;
}
	\end{lstlisting}
	The \texttt{while} loop version is below:
	\begin{lstlisting}
long fact_while(long n)
{
	long result = 1;
	long i = 2;
	while (i <= n) {
		result *= i;
		i++;
	}
	return result;
}
	\end{lstlisting}
	The guarded-do translation follows:
	\begin{lstlisting}
long fact_while_guarded_do(long n)
{
	long result = 1;
	long i = 2;
	if (i > n)
		goto done;
loop:
	result *=  i;
	i++;
	if (i <= n)
		goto loop;
done:
	return result;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.28}
	A function \texttt{fun\_b} has the following overall structure:
	\begin{lstlisting}
long fun_b(unsigned long x) {
	long val = 0;
	long i;
	for ( ... ; ... ; ... ) {
		.
		.
		.
	}
	return val;
}
	\end{lstlisting}
	The \texttt{gcc} C compiler generates the following assembly code:
	\begin{lstlisting}[language={}]
	long fun_b(unsigned long  x)
	x in %rdi
fun_b:
	movl	$64,	%edx
	movl	$0,		%eax
.L10:
	movq	%rdi,	%rcx
	andl	$1,		%ecx
	addq	%rax,	%rax
	orq		%rcx,	%rax
	shrq	%rdi			// Shift right by 1
	subq	$1,		%rdx
	jne		.L10
	rep; ret
	\end{lstlisting}
	Reverse engineer the operation of this code and then do the following:
	\begin{enumerate}[label=(\alph*)]
		\item Use the assembly-code version to fill in the missing parts of
		the C code.
		\item Explain why there is neither an initial test before the loop
		nor an initial jump to the test portion of the loop.
		\item Describe in English what this function computes.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	I began by annotating the assembly code as follows:
	\begin{lstlisting}[language={}]
long fun_b(unsigned long  x)
x in %rdi
fun_b:
	movl	$64,	%edx	// unsigned long t = 64;
	movl	$0,		%eax	// long result = 0;
.L10:
	movq	%rdi,	%rcx	// long v = x;
	andl	$1,		%ecx	// v = v & 1;
	addq	%rax,	%rax	// result = result + result;
	orq		%rcx,	%rax	// result = result | v;
	shrq	%rdi			// x = x >> 1;
	subq	$1,		%rdx	// t = t - 1;
	jne		.L10			// if t != 0 goto .L10
	rep; ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item Based on my annotations of the assembly, I deduced the C code to be:
			\begin{lstlisting}
long fun_b(unsigned long x) {
	long val = 0;
	long i;
	for ( i = 64 ; i != 0 ; i-- ) {
		long xlsb = x & 1;	// Get least significant bit of x
		val = (2 * val) | xlsb;
		x = x >> 1;
	}
	return val;
}
			\end{lstlisting}
		\item Neither test is present because the loop always iterates 64 times.
		\item In the first iteration, the least significant bit of \texttt{val}
		has the least significant bit of \texttt{x}, and all of its other bits
		are 0. In the next iteration, multiplying \texttt{val} by 2 shifts all
		of the bits of \texttt{val} left by 2 while copying in the next-least
		significant bit of \texttt{x} into the least significant position of
		\texttt{val}. The apparent effect is that it reverses the bits
		of \texttt{x}.
	\end{enumerate}
\end{sol}

\begin{ex}{3.29}
	Executing a \texttt{continue} statement in C causes the program to jump to the
	end of the current loop iteration. The stated rule for translating a \texttt{for}
	loop into a \texttt{while} loop needs some refinement when dealing with \texttt{continue}
	statements. For example, consider the following code:
	\begin{lstlisting}
/* Example of for loop containing a continue statement */
/* Sum even numbers between 0 and 9 */
long sum = 0;
long i;
for (i = 0; i < 10; i++) {
	if (i & 1)
		continue;
	sum += i;
}
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item What would we get if we naively applied our rule for translating
		the \texttt{for} loop into a \texttt{while} loop? What would be wrong with
		this code?
		\item How could you replace the \texttt{continue} statement with a \texttt{goto}
		statement to ensure that the \texttt{while} loop correctly duplicates the
		behavior of the \texttt{for} loop?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}
		\item We would get the following if we ``naively" translated the for loop:
			\begin{lstlisting}
/* Naive translation of for loop with continue statement into while loop */
/* Sum even numbers between 0 and 9 */
long sum = 0;
long i = 0;
while (i < 10) {
	if (i & 1)
		continue;
	sum += i;
	i++;
}
			\end{lstlisting}
			The translation creates an infinite loop. In the first iteration, the
			test expression in the \texttt{if} statement evaluates to false, so
			\texttt{continue} is not evaluated, causing \texttt{i++} to execute,
			thus increasing \texttt{i} to 1. With this new value, the condition
			in the \texttt{if} statement now succeeds, causing \texttt{continue} to
			be executed. As a result, we go back to the top of the while loop, but we
			never reach the \texttt{i++} statement thereafter. Thus, the value of
			\texttt{i} remains at 1 indefinitely.
			\item We could replace the \texttt{continue} with a \texttt{goto next\_iter},
			where \texttt{next\_iter} is a label under which the \texttt{i++;} statement
			is present.
				\begin{lstlisting}
/* Translation of for loop with continue statement into while loop */
/* Sum even numbers between 0 and 9 */
long sum = 0;
long i = 0;
while (i < 10) {
	if (i & 1)
		goto next_iter;
	sum += i;
next_iter:
	i++;
}
				\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{3.30}
	In the C function that follows, we have omitted the body of the \texttt{switch}
	statement. In the C code, the case labels did not span a contiguous range, and
	some cases had multiple labels.
	\begin{lstlisting}
void switch2(long x, long *dest) {
	long val = 0;
	switch (x) {
		/* body of switch statement omitted */
	}
	*dest = val;
}
	\end{lstlisting}
	In compiling the function \texttt{gcc} generates the assembly code that follows
	for the initial part of the procedure, with variable \texttt{x} in \texttt{\%rdi}:
	\begin{lstlisting}[language={}]
	void switch2(long x, long *dest)
	x in %rdi
switch2:
	addq	$1,		%rdi
	cmpq	$8,		%rdi
	ja		.L2
	jmp		*.L4(,%rdi,8)
	\end{lstlisting}
	It generates the following code for the jump table:
	\begin{lstlisting}[language={}]
.L4:
	.quad	.L9
	.quad	.L5
	.quad	.L6
	.quad	.L7
	.quad	.L2
	.quad	.L7
	.quad	.L8
	.quad	.L2
	.quad	.L5
	\end{lstlisting}
	Based on this information, answer the following questions:
	\begin{enumerate}[label=(\alph*)]
		\item What were the values of the case labels in the \texttt{switch}
		statement?
		\item What cases had multiple labels in the C code?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Below I have annotated the initial part of the assembly for the
		procedure provided:
		\begin{lstlisting}[language={}]
	void switch2(long x, long *dest)
	x in %rdi
switch2:
	addq	$1,		%rdi	// x += 1
	cmpq	$8,		%rdi	// cmp x:8
	ja		.L2				// if > goto .L2 (default case)
	jmp		*.L4(,%rdi,8)	// Go to *jt[index]
		\end{lstlisting}
		Based on the annotation, \texttt{x} was adjusted so that it would be
		an index between 0 and 8, inclusive by adding 1. Hence, \texttt{x}
		must have been between -1 and 7.  Based on this, we can annotate the
		jump table assembly snippet given:
			\begin{lstlisting}[language={}]
.L4:
.quad	.L9	// case -1
.quad	.L5	// case 0
.quad	.L6	// case 1
.quad	.L7	// case 2
.quad	.L2	// case 3 (default)
.quad	.L7	// case 4
.quad	.L8 // case 5
.quad	.L2	// case 6
.quad	.L5	// case 7
			\end{lstlisting}
		The \texttt{.L2} label is reserved for the \texttt{default} case. The
		\texttt{.L4} for the jump table addresses. The only \texttt{x} values
		with no matching \texttt{case} are when \texttt{x} is 3 or 6, because for
		those values, \texttt{switch} transfers control to the \texttt{default} branch.
		\item The labels that repeat constitute the cases with multiple labels
		(except for \texttt{.L2}, corresponding to the \texttt{default} branch)
		are the cases with multiple labels. These are \texttt{.L5} with cases
		\texttt{0} or \texttt{7}, and \texttt{.L7} with cases 2 or 4.
	\end{enumerate}
\end{sol}

\begin{ex}{3.31}
	For a C function \texttt{switcher} with the general structure
	\begin{lstlisting}
void switcher(long a, long b, long c, long *dest)
{
	long val;
	switch(a) {
		case ________:		/* Case A */
			c = _______;
			/* Fall through */
		case ________:		/* Case B */
			val = _________;
			break;
		case ________:		/* Case C */
		case ________:		/* Case D */
			val = __________;
			break;
		case ________:		/* Case E */
			val = __________;
			break;
		default:
			val = __________;
	}
	*dest = val;
}
	\end{lstlisting}
	\texttt{gcc} generates the assembly code below:
	\begin{lstlisting}[language={}]
	void switcher(long a, long b, long c, long *dest)
	a in %rdi, b in %rsi, c in %rdx, d in %rcx
switcher:
	cmpq	$7,				%rdi
	ja		.L2
	jmp		*.L4(,%rdi,8)
	.section				.rodata
.L7:
	xorq	$15,			%rsi
	movq	%rsi,			%rdx
.L3:
	leaq	112(%rdx),		%rdi
	jmp		.L6
.L5:
	leaq	(%rdx,%rsi),	%rdi
	salq	$2,				%rdi
	jmp		.L6
.L2:
	movq	%rsi,			%rdi
.L6:
	movq	%rdi,			(%rcx)
	ret
	\end{lstlisting}
	and it also generates the following jump table:
	\begin{lstlisting}[language={}]
.L4:
	.quad	.L3
	.quad	.L2
	.quad	.L5
	.quad	.L2
	.quad	.L6
	.quad	.L7
	.quad	.L2
	.quad	.L5
	\end{lstlisting}
	Fill in the missing parts of the C code. Except for the ordering
	of case labels \texttt{C} and \texttt{D}, there is only one way
	to fit the different cases into the template.
\end{ex}

\begin{sol}
	\
	I began by annotating the assembly:
		\begin{lstlisting}[language={}]
void switcher(long a, long b, long c, long *dest)
a in %rdi, b in %rsi, c in %rdx, d in %rcx
switcher:
	cmpq	$7,				%rdi	// compare a:7
	ja		.L2						// if > 7 goto .L2 (default branch)
	jmp		*.L4(,%rdi,8)			// Go to *jt[index]
	.section				.rodata
.L7:								// Case A
	xorq	$15,			%rsi	// b = b ^ 15;
	movq	%rsi,			%rdx	// c = b;
									// fall through
.L3:								// Case B
	leaq	112(%rdx),		%rdi	// a = c + 112;
	jmp		.L6						// break
.L5:								// Cases C and D
	leaq	(%rdx,%rsi),	%rdi	// a = c + b
	salq	$2,				%rdi	// a <<= 2;
	jmp		.L6						// break
.L2:								// default
	movq	%rsi,			%rdi	// a = b;
.L6:								// just after switch stament, or case E
	movq	%rdi,			(%rcx)	// *dest = a;
	ret
		\end{lstlisting}
		It seems there is no case E, from which I deduce that case E actually does
		the same thing as the last statement pf \texttt{*dest = val}. That is,
		case E just sets \texttt{val} equal to \texttt{a}. Based on this the
		case values corresponding to the jump table labels are as follows:
		\begin{lstlisting}[language={}]
.L4:
	.quad	.L3	// case 0 (case B)
	.quad	.L2	// case 1 (default)
	.quad	.L5	// case 2 (case C)
	.quad	.L2 // case 3 (default)
	.quad	.L6 // case 4 (case E)
	.quad	.L7 // case 5 (case A)
	.quad	.L2 // case 6 (default)
	.quad	.L5 // case 7 (case D)
		\end{lstlisting}
		Based on this, the C code is as follows:
	\begin{lstlisting}
void switcher(long a, long b, long c, long *dest)
{
	long val;
	switch(a) {
		case 5:		/* Case A */
			c = b ^ 15;
			/* Fall through */
		case 0:		/* Case B */
			val = c + 112;
			break;
		case 2:		/* Case C */
		case 7:		/* Case D */
			val = (c + b) << 2;
			break;
		case 4:		/* Case E */
			val = a;
			break;
		default:
			val = b;
	}
	*dest = val;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.32}
	The disassembled code for two functions \texttt{first} and \texttt{last} is
	shown below, along with the code for a call of \texttt{first} by function
	\texttt{main}:
	\begin{lstlisting}[language={}]
	Disassembly of last(long u, long v)
	u in %rdi, v in %rsi
0000000000400540 <last>:
	400540:  48 89 f8			mov		%rdi, %rax		// L1: u
	400543:  48 0f af c6		imul	%rsi, %rax		// L2: u*v
	400547:  c3					retq					// L3: Return

	Disassembly of first(long x)
	x in %rdi
0000000000400548 <last>:
	400548:  48 8d 77 01		lea		0x1(%rdi), %rsi	// F1: x+1
	40054c:  48 83 ef 01		sub		$0x1,      %rdi	// F2: x-1
	400550:  e8 eb ff ff ff		callq   400540 <last>   // F3: Call last(x-1,x+1)
	400555:  f3 c3				repz retq				// F4: Return
	.
	.
	.
	400560:  e8 e3 ff ff ff		callq	400540 <first>	// M1: Call first(10)
	400565:	 48 89 c2			mov		%rax,%rdx		// M2: Resume
	\end{lstlisting}
	Each of these instructions is given a label, similar to those in Figure 3.27(a).
	Starting with the calling of \texttt{first(10)} by \texttt{main}, fill in the following
	table to trace instruction execution through the point where the program returns back
	to \texttt{main}.
	\begin{center}
		\begin{tabular}{ccccccccc}
			\multicolumn{3}{c}{Instruction} & \multicolumn{5}{c}{State values (at beginning)} & {}\\
			\hline
			Label & PC & Instruction & \texttt{\%rdi} & \texttt{\%rsi} & \texttt{\%rax} &
			\texttt{\%rsp} & \texttt{*\%rsp} & Description\\
			\hline
			M1 & \texttt{0x400560} & \texttt{callq} & 10 & --- & --- &  \texttt{0x7fffffffe820} & --- & Call \texttt{first(10)}\\
			
			F1 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			F2 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			F3 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\

			L1 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			L2 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			L3 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			F4 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			M2 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	Each time a function call is made, the address is pushed onto the stack,
	so the stack pointer is moved down by 8 bytes. (since an address is 64-bit).
	For example, when \texttt{main} calls \texttt{first}, the return address on top
	of the stack goes from \texttt{0x7fffffffe820} to \texttt{0x7fffffffe818}, 
	a decrease by 8 bytes. Similarly, when \texttt{first} calls \texttt{last},
	it decreases to \texttt{0x7fffffffe810}.
	\begin{center}
		\begin{tabular}{ccccccccc}
			\multicolumn{3}{c}{Instruction} & \multicolumn{5}{c}{State values (at beginning)} & {}\\
			\hline
			Label & PC & Instruction & \texttt{\%rdi} & \texttt{\%rsi} & \texttt{\%rax} &
			\texttt{\%rsp} & \texttt{*\%rsp} & Description\\
			\hline
			
			M1 & \texttt{0x400560} & \texttt{callq} & 10 & --- & --- &  \texttt{0x7fffffffe820} & --- & Call \texttt{first(10)}\\
			
			F1 &\texttt{0x400548} & \texttt{lea} & 10
			& -- & --- & \texttt{0x7fffffffe818}
			& \texttt{0x400565} & Entry of \texttt{first} \\
			
			F2 & \texttt{0x40054c} & \texttt{sub} & 10
			& 11 & --- & \texttt{0x7fffffffe818}
			& \texttt{0x400565} & Subtract 1 from \texttt{x} \\
			
			F3 & \texttt{0x400550} & \texttt{callq} & 9
			& 11 & --- & \texttt{0x7fffffffe818}
			& \texttt{0x400565} & Call \texttt{last(9, 11)}\\
			
			L1 & \texttt{0x400540} & \texttt{mov} & 9
			& 11 & --- & \texttt{0x7fffffffe810}
			& \texttt{0x400555} & Entry of \texttt{last}\\
			
			L2 & \texttt{0x400543} & \texttt{imul} & 9
			& 11 & 9 & \texttt{0x7fffffffe810}
			& \texttt{0x400555} & Multiply \texttt{u*v} \\
			
			L3 & \texttt{0x400547} & \texttt{retq} & 9
			& 11 & 99 & \texttt{0x7fffffffe810}
			& \texttt{0x400555} & Return 99 from \texttt{last}\\
			
			F4 & \texttt{0x400555} & \texttt{repz retq} & 9
			& 11 & 99 & \texttt{0x7fffffffe818}
			& \texttt{0x400565} & Return 99 from \texttt{first} \\
			
			M2 & \texttt{0x400565} & \texttt{mov} & 9
			& 116 & 99 & \texttt{0x7fffffffe820}
			& --- & Resume \texttt{main} \\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.33}
	A C function \texttt{procprob} has four arguments \texttt{u}, \texttt{a},
	\texttt{v}, and \texttt{b}. Each is either a signed number or a pointer to
	a signed number, where the numbers have different sizes. The function has
	the following body:
	\begin{lstlisting}
*u += a;
*v += b;
return sizeof(a) + sizeof(b);
	\end{lstlisting}
	It compiles to the following x86-64 code:
	\begin{lstlisting}[language={}]
procprob:
	movslq	%edi,	%rdi
	addq	%rdi,	(%rdx)
	addb	%sil,	(%rcx)
	movl	$6,		%eax
	ret
	\end{lstlisting}
	Determine a valid ordering and types of the four parameters. There are two
	correct answers.
\end{ex}

\begin{sol}
	\
	The first argument is in \texttt{\%rdi}, the second in \texttt{\%rsi},
	the third in \texttt{\%rdx}, and the fourth in \texttt{\%rcx}.
	The \texttt{addq \%rdi, (\%rdx)} command corresponds to the statement \texttt{*u += a},
	so \texttt{a} is the first argument, and \texttt{u} is the third argument.
	Similarly, the \texttt{addb \%rsi, (\%rcx)} corresponds to the statement
	\texttt{*v += b}, and \texttt{\%sil} is the lower byte of \texttt{\%rsi},
	so \texttt{b} is the second argument and \texttt{v} is the 4th argument
	
	\
	We are given that all arguments are signed integers
	or pointers to signed integers. The \texttt{moveslq \%edi, \%rdi} sign extends the lower half
	register of \texttt{\%rdi}, in this  case from 32-bit to 64-bit. Hence,
	\texttt{a} must be a 32-bit integer (an \texttt{int}) and \texttt{v} must
	be a pointer to a 64-bit integer (a \texttt{long *}). Since \texttt{a} is 4 bytes,
	it must be that \texttt{b} is 2 bytes because \texttt{\%movl \$6, \%eax} implies
	the sum of their sizes is 6 bytes, so \texttt{b} is a \texttt{short}. The
	\texttt{addb \%sil, (\%rcx)} suggests an 8-bit operand, so \texttt{v} is a
	pointer to a \texttt{char} (a \texttt{char *}). This means the function
	signature would be
	\begin{lstlisting}
procprob(int a, short b, long *u, char *v);
	\end{lstlisting} 
\end{sol}

\begin{ex}{3.34}
	Consider a function \texttt{P}, which generates local values, named \texttt{a0-a8}.
	It then calls function \texttt{Q} using these generated values as arguments. \texttt{gcc}
	produces the following code for the first part of \texttt{P}:
	\begin{lstlisting}[language={}]
	long P(long x)
	x in %rdi
P:
	pushq	%r15
	pushq	%r14
	pushq	%r13
	pushq	%r12
	pushq	%rbp
	pushq	%rbx
	subq	$24, %rsp
	movq	%rdi, %rbx
	leaq	1(%rdi), %r15
	leaq	2(%rdi), %r14
	leaq	3(%rdi), %r13
	leaq	4(%rdi), %r12
	leaq	5(%rdi), %rbp
	leaq	6(%rdi), %rax
	movq	%rax, (%rsp)
	leaq	7(%rdi), %rdx
	movq	%rdx, 8(%rsp)
	movl	$0, %eax
	call	Q
	. . .
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item Identify which local values get stored in callee-saved registers.
		\item Identify which local values get stored on the stack.
		\item Explain why the program could not store all of the local variables
		in callee-saved registers.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The callee-saved registers are \texttt{\%rbx}, \texttt{\%rbp}, and
		\texttt{\%r12} through \texttt{\%r15}. After pushing these values onto
		the stack, \texttt{P} stores \texttt{x} at \texttt{\%rbx}, \texttt{x + 1}
		in \texttt{\%rx15}, \texttt{x + 2} in \texttt{\%rx14}, \texttt{x + 3} in
		\texttt{\%rx13}, \texttt{x + 4} in \texttt{\%rx12}, and \texttt{x + 5} in
		\texttt{\%rbp}.
		\item The value \texttt{x + 6} is saved at the top of the stack.
		The value \texttt{x + 7} is saved at an 8-byte offset of the top-of-stack.
		\item There are only 6 callee-saved registers, and to store \texttt{a0}
		through \texttt{a8} requires 9 registers. Therefore, \texttt{P} must store
		the remaining 3 on the stack. This explains the \texttt{subq \$24, \%rsp}
		instruction, which allocates space on the stack for 3 local variables.
	\end{enumerate}
\end{sol}

\begin{ex}{3.35}
	For a C function having the general structure
	\begin{lstlisting}
long rfun(unsigned long x) {
	if (__________)
		return ____________;
	unsigned long nx = ___________;
	long rv = rfun(nx);
	return _________;
}
	\end{lstlisting}
	\texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
	long rfun(unsigned long x)
	x in %rdi
rfun:
	pushq	%rbx
	movq	%rdi, %rbx
	movl	$0, %eax
	testq	%rdi, %rdi
	je		.L2
	shrq	$2, %rdi
	call	rfun
	addq	%rbx, %rax
.L2:
	popq	%rbx
	ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item What value does \texttt{rfun} store in the callee-saved register
		\texttt{\%rbx}?
		\item Fill in the missing expressions in the C code shown above.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item First we can annotate the assembly code:
	\begin{lstlisting}[language={}]
long rfun(unsigned long x)
x in %rdi
rfun:
	pushq	%rbx			// Save %rbx
	movq	%rdi, %rbx		// Store x in callee-saved register.
	movl	$0, %eax		// Set return val to 0
	testq	%rdi, %rdi		// Test x
	je		.L2				// if == 0 goto .L2
	shrq	$2, %rdi		// unsigned long nx = x >> 2; (logical right shift)
	call	rfun			// Call rfun(nx)
	addq	%rbx, %rax		// long rv = x + rfun(nx)
.L2:
	popq	%rbx			// Restore %rbx
	ret						// Return
	\end{lstlisting}
	We conclude that \texttt{rfun} stores \texttt{x}, its sole argument,
	in the callee-saved register \texttt{\%rbx}, after saving the existing value on
	the stack, and restoring it before returning.
	\item The C code is as follows:
		\begin{lstlisting}
long rfun(unsigned long x) {
	if (x == 0)
		return 0;
	unsigned long nx = x >> 2;
	long rv = rfun(nx);
	return x + rv;
}
		\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{3.36}
	Consider the following declarations 
	\begin{lstlisting}
short	  S[7];
short	 *T[3];
short	**U[6];
int		  V[8];
double	 *W[4];
	\end{lstlisting}
	Fill in the following table describing the element size, the total size, and
	the address of element $i$ for each of these arrays.
	\begin{center}
		\begin{tabular}{ccccc}
			Array & Element Size & Total size & Start address & Element $i$\\
			\hline
			\texttt{S} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $x_S$ & \makebox[1cm]{\hrulefill}\\
			
			\texttt{T} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $x_T$ & \makebox[1cm]{\hrulefill}\\
			
			\texttt{U} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $x_U$ & \makebox[1cm]{\hrulefill}\\
			
			\texttt{V} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $x_V$ & \makebox[1cm]{\hrulefill}\\
			
			\texttt{W} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $x_W$ & \makebox[1cm]{\hrulefill}\\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	The sizes in the brackets constitute the number of elements. The element
	size is given by the type, where \texttt{short} is 2 bytes, \texttt{int}
	is 4 bytes, and all pointer types are \texttt{8} bytes. From this, the
	table is as follows:
	\begin{center}
		\begin{tabular}{ccccc}
			Array & Element Size & Total size & Start address & Element $i$\\
			\hline
			\texttt{S} & 2 & 14 & $x_S$ & $x_S + 2i$\\
			
			\texttt{T} & 8 & 24 & $x_T$ & $x_T + 8i$\\
			
			\texttt{U} & 8 & 48 & $x_U$ & $x_U + 8i$\\
			
			\texttt{V} & 4 & 32 & $x_V$ & $x_V + 4i$\\
			
			\texttt{W} & 8 & 32 & $x_W$ & $x_W +  8i$\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.37}
	Suppose $x_S$, the address of short integer array \texttt{S}, and long
	integer index $i$ are stored in registers \texttt{\%rdx} and \texttt{\%rcx}, respectively.
	For each of the following expressions, give its type, a formula for its
	value, and an assembly-code implementation. The result should be stored
	in register \texttt{\%rax} if it is a pointer and register element \texttt{\%ax} if it
	has data type \texttt{short}.
	\begin{center}
		\begin{tabular}{cccc}
			Expression & Type & Value & Assembly code\\
			\hline
			\texttt{S+1} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			\texttt{S[3]} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			\texttt{\&S[i]} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			\texttt{S[4*i+1]} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			\texttt{S+i-5} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	I used the fact that \texttt{short} is 2 bytes, and \texttt{long} is 8 bytes.
	Since 2 bytes is a ``word", we use \texttt{movw} for data movements.
	\begin{center}
		\begin{tabular}{cccc}
			Expression & Type & Value & Assembly code\\
			\hline
			\texttt{S+1} & \texttt{short *} & $x_S+2$ & \texttt{leaq 2(\%rdx), \%rax}\\
			
			\texttt{S[3]} & \texttt{short} & M$[x_S+6]$ & \texttt{movw 6(\%rdx), \%ax}\\
			
			\texttt{\&S[i]} & \texttt{short *} & $x_S + 2i$ & \texttt{leaq (\%rdx,\%rcx,2), \%rax}\\
			
			\texttt{S[4*i+1]} & \texttt{short } & M$[x_S+8i+2]$ & \texttt{movw 2(\%rdx, \%rcx, 8), \%ax}\\
			
			\texttt{S+i-5} & \texttt{short *} & $x_S+2i-10$ & \texttt{leaq -10(\%rdx, \%rcx,2), \%rax}\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.38}
	Consider the following source code, where $M$ and $N$ are constants declared with
	\texttt{\#define}:
	\begin{lstlisting}
long P[M][N];
long Q[N][M];

long sum_element(long i, long j) {
	return P[i][j] + Q[j][i];
}
	\end{lstlisting}
	In compiling this program, \texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
	long sum_element(long i, long j)
	i in %rdi, j in %rsi
sum_element:
	leaq	0(,%rdi,8),	%rdx
	subq	%rdi, %rdx
	addq	%rsi, %rdx
	leaq	(%rsi,%rsi,4), %rax
	addq	%rax, %rdi
	movq	Q(,%rdi,8), %rax
	addq	P(,%rdx,8), %rax
	ret
	\end{lstlisting}
	Use your reverse engineering skills to determine the values $M$ and $N$ based on
	this assembly code.
\end{ex}

\begin{sol}
	\
	Note that \texttt{long} is of size 8 bytes. The address \texttt{\&P[i][j]}
	is given by $x_P + 8(N\cdot i + j)$, whereas \texttt{\&Q[j][i]} is given by
	$x_Q + 8(M\cdot j + i)$.
	First we can annotate the assembly:
		\begin{lstlisting}[language={}]
	long sum_element(long i, long j)
	i in %rdi, j in %rsi
sum_element:
	leaq	0(,%rdi,8),	%rdx		// long a = 8i
	subq	%rdi, %rdx				// a = a - i /* now a is 7i */
	addq	%rsi, %rdx				// a = a + j /* now a is 7i + j */
	leaq	(%rsi,%rsi,4), %rax		// long b = j + 4j /* now it is 5j */
	addq	%rax, %rdi				// long c = i + b /* c = i + 5j */
	movq	Q(,%rdi,8), %rax		// result = M[Q + 8*c]
	addq	P(,%rdx,8), %rax		// result += M[P + 8*a]
	ret
		\end{lstlisting}
		Based on the annotations, \texttt{\&Q[j][i]} is $x_Q + 8(5j+i)$, and
		\texttt{\&P[i][j]} is $x_P + 8(7i + j)$. Hence, $N=7$, and $M=5$.
\end{sol}

\begin{ex}{3.39}
	Use Equation 3.1 to explain how the computations of the initial values for
	\texttt{Aptr}, \texttt{Bptr}, and \texttt{Bend} in the C code in Figure 3.37(b)
	(lines 3-5) correctly describe their computations in the assembly code generated
	for \texttt{fix\_prod\_ele} (lines 3-5).
\end{ex}

\begin{sol}
	\
	Equation 3.1 says that if $T$ is a data type of size $L$, then given the array
	\begin{lstlisting}
T D[R][C];
	\end{lstlisting}
	with $R$ rows and $C$ columns, the array element \texttt{D[i][j]} is at memory
	address
	\[
	\&D[i][j]=x_D+L(C\cdot i+j)
	\]
	where $x_D$ is the address of $D$. Recall that \texttt{A} and \texttt{B} are
	of types \texttt{int[16][16]}. To access \texttt{A[i][0]}, the first element
	in the $i$-th row, we have $L=4$ because \texttt{int} takes up 4 bytes, and
	$C$ is 16, so
	\[
	\&A[i][0]=x_A+4(16\cdot i + 0)=x_A+64i
	\]
	Similarly, to access \texttt{B[0][k]}, the first element in the $k$-th column
	we have $L=4$ because \texttt{int} takes up 4 bytes, and $C$ is 16, so
	\[
	\&B[0][k]=x_B+4(16\cdot 0 + k)=x_B+4k
	\]
	Finally, to access the first element beyond the $k$-th column, namely, the
	first (thus marking the end of column $k$ of \texttt{B}), and recalling
	that $N=16$, we have
	\[
	\&B[N][k]=x_B+4(16\cdot N + k)=x_B+4(16\cdot 16+k)=x_B+1024+4k
	\]
\end{sol}

\begin{ex}{3.40}
	The following C code sets the diagonal elements of one of our fixed-sized arrays
	to \texttt{val}:
	\begin{lstlisting}
/* Set all diagonal elements to val */
void fix_set_diag(fix_matrix A, int val) {
	long i;
	for (i = 0; i < N; i++)
		A[i][i] = val;
}
	\end{lstlisting}
	When compiled with optimization level \texttt{-O1}, \texttt{gcc} generates the
	following assembly code:
	\begin{lstlisting}[language={}]
	void fix_set_diag(fix_matrix A, int val)
	A in %rdi, val in %rsi
fix_set_diag:
	movl	$0, %eax
.L13:
	movl	%esi, (%rdi,%rax)
	addq	$68, %rax
	cmpq	$1088, %rax
	jne		.L13
	rep; ret
	\end{lstlisting}
	Create a C code program \texttt{fix\_set\_diag\_opt} that uses optimizations similar
	to those in the assembly code, in the same style as the code in Figure 3.37(b). Use
	expressions involving the parameter $N$ rather than integer constants, so that your code
	will work correctly if $N$ is redefined.
\end{ex}

\begin{sol}
	\
	First we can annotate the assembly:
	\begin{lstlisting}[language={}]
	void fix_set_diag(fix_matrix A, int val)
	A in %rdi, val in %rsi
fix_set_diag:
	movl	$0, %eax			// i = 0
.L13:
	movl	%esi, (%rdi,%rax)	// M[A + i] = val
	addq	$68, %rax			// i += 16 * 4 + 4
	cmpq	$1088, %rax			// compare i:(4*(16*16 + 16)), N = 16
	jne		.L13				// if != go to .L13
	rep; ret					// Return
	\end{lstlisting}
	Based on the annotations, we can produce the following C code:
	\begin{lstlisting}
/* (Optimized) Set all diagonal elements to val */
void fix_set_diag_opt(fix_matrix A, int val) {
	int i = 0;				/* Running index */
	int last = N * N + N;	/* Index is one beyond end */
	do {
		A[i] = val;
		i += (N + 1);
	} while (i != last);
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.41}
	Consider the following structure declaration:
	\begin{lstlisting}
struct prob {
	int *p;
	struct {
		int x;
		int y;
	} s;
	struct prob *next;
};
	\end{lstlisting}
	This declaration illustrates that one structure can be embedded within another,
	just as arrays can be embedded within structures and arrays can be embedded within
	arrays. The following procedure (with some expressions omitted) operates on this
	structure:
	\begin{lstlisting}
void sp_init(struct prob *sp) {
	sp->s.x  = ________;
	sp->p    = ________;
	sp->next = ________;
}
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item What are the offsets (in bytes) of the following fields?
		\begin{center}
			\begin{tabular}{cc}
				\texttt{p}: & \makebox[1cm]{\hrulefill}\\
				\texttt{s.x}: & \makebox[1cm]{\hrulefill}\\
				\texttt{s.y}: & \makebox[1cm]{\hrulefill}\\
				\texttt{next}: & \makebox[1cm]{\hrulefill}\\
			\end{tabular}
		\end{center}
		\item How many total bytes does the structure require?
		\item The compiler generates the following assembly code for
		\texttt{sp\_init}:
		\begin{lstlisting}[language={}]
	void sp_init(struct prob *sp)
sp_init:
	movl	12(%rdi), %eax
	movl	%eax, 8(%rdi)
	leaq	8(%rdi), %rax
	movq	%rax, (%rdi)
	movq	%rdi, 16(%rdi)
	ret
		\end{lstlisting}
		On the basis of this information, fill in the missing expressions in the
		code for \texttt{sp\_init}.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The offsets are determined by the size of the type of each
		field, as follows:
		\begin{center}
			\begin{tabular}{cc}
				Field & Byte Offset\\
				\hline
				\texttt{p}: & 0 bytes\\
				\texttt{s.x}: & 8 bytes\\
				\texttt{s.y}: & 12 bytes\\
				\texttt{next}: & 16 bytes\\
			\end{tabular}
		\end{center}
		\item The structure required 24 bytes.
		\item The annotated assembly is
			\begin{lstlisting}[language={}]
	void sp_init(struct prob *sp)
	sp in %rdi
sp_init:
	movl	12(%rdi), %eax	// int y = sp->y;
	movl	%eax, 8(%rdi)	// sp->s.x = y;
	leaq	8(%rdi), %rax	// s = &(sp->s.x)
	movq	%rax, (%rdi)	// sp->p = s
	movq	%rdi, 16(%rdi)	// r->next = sp
	ret
			\end{lstlisting}
		The corresponding C code is:
			\begin{lstlisting}
void sp_init(struct prob *sp) {
	sp->s.x  = sp->y;
	sp->p    = &(sp->s.x);
	sp->next = sp;
}
			\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{3.42}
	The following code shows the declaration of a structure of type \texttt{ELE}
	and the prototype for a \texttt{fun}:
	\begin{lstlisting}
struct ELE {
	long 	v;
	struct ELE *p;
};

long fun(struct ELE *ptr);
	\end{lstlisting}
	When the code for \texttt{fun} is compiled, \texttt{gcc} generates the following
	assembly code:
	\begin{lstlisting}[language={}]
	long fun(struct ELE *ptr)
	ptr in %rdi
fun:
	movl	$0, %eax
	jmp		.L2
.L3:
	addq	(%rdi), %rax
	movq	8(%rdi), %rdi
.L2:
	testq	%rdi, %rdi
	jne		.L3
	rep; ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item Use your reverse engineering skills to write C code for \texttt{fun}.
		\item Describe the data structure that this structure implements and the
		operation performed by \texttt{fun}.
	\end{enumerate}
\end{ex}

\begin{sol}
	\begin{enumerate}[label=(\alph*)]
		\item The annotated assembly is below:
		\begin{lstlisting}[language={}]
	long fun(struct ELE *ptr)
	ptr in %rdi
fun:
	movl	$0, %eax		// long result = 0;
	jmp		.L2				// goto .L2
.L3:
	addq	(%rdi), %rax	// result += *ptr;
	movq	8(%rdi), %rdi	// ptr++;
.L2:
	testq	%rdi, %rdi		// test ptr
	jne		.L3				// if != NULL goto .L3
	rep; ret
		\end{lstlisting}
		The C implementation of \texttt{fun} is:
		\begin{lstlisting}
long fun (struct ELE *ptr) {
	long result = 0;
	while (ptr != NULL) {
		result += *ptr;
		ptr++;
	}
	return result;
}
		\end{lstlisting}
		\item The data type \texttt{struct ELE} implements a linked list, and the
		function \texttt{fun} computes the sum of all the elements in it.
	\end{enumerate}
\end{sol}

\begin{ex}{3.43}
	Suppose you are given the job of checking that a C compiler generates the proper
	code for structure and union access. You write the following structure declaration:
	\begin{lstlisting}
typedef union {
	struct {
		long	u;
		short	v;
		char 	w;
	} t1;
	struct {
		int a[2];
		char *p;
	} t2;
} u_type;
	\end{lstlisting}
	You write a series of functions of the form
	\begin{lstlisting}
void get(u_type *up, type *dest) {
	*dest = expr;
}
	\end{lstlisting}
	with different access expressions \texttt{expr} and with destination data type \texttt{type}
	set according to the type associated with \texttt{expr}. You then examine the code
	generated when compiling the functions to see if they match your expectations.
	
	\
	Suppose in these functions that  \texttt{up} and \texttt{dest} are loaded into registers
	\texttt{\%rdi} and \texttt{\%rsi}, respectively. Fill in the following table with data
	type \emph{type} and sequences of one to three instructions to compute the expression
	and store the result at \texttt{dest}.
	\begin{center}
		\begin{tabular}{ccc}
			\emph{expr} & \emph{type} & Code\\
			\hline
			\texttt{up->t1.u} & \texttt{long} & \texttt{movq (\%rdi), \%rax}\\
			{} & {} & \texttt{movq \%rax, (\%rsi)}\\
			
			\texttt{up->t1.v} & \makebox[1cm]{\hrulefill} & \makebox[3cm]{\hrulefill}\\
			{} & {} & \makebox[3cm]{\hrulefill}\\
			
			\texttt{\&up->t1.w} & \makebox[1cm]{\hrulefill} & \makebox[3cm]{\hrulefill}\\
			{} & {} & \makebox[3cm]{\hrulefill}\\
			
			\texttt{up->t2.a} & \makebox[1cm]{\hrulefill} & \makebox[3cm]{\hrulefill}\\
			{} & {} & \makebox[3cm]{\hrulefill}\\
			
			\texttt{up->t2.a[up->t1.u]} & \makebox[1cm]{\hrulefill} & \makebox[3cm]{\hrulefill}\\
			{} & {} & \makebox[3cm]{\hrulefill}\\
			
			\texttt{*up->t2.p} & \makebox[1cm]{\hrulefill} & \makebox[3cm]{\hrulefill}\\
			{} & {} & \makebox[3cm]{\hrulefill}\\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	The union structure of type \texttt{u\_type} has a size that is the maximum of its
	member fields, subject to proper alignment. Its field \texttt{t1} is a structure
	is a structure with a \texttt{long}, a \texttt{short}, and \texttt{char}, whose
	overall size is $8+2+1=11$ bytes. Its other field, \texttt{t2}, has an \texttt{int[2]}
	array and a \texttt{char *}, both of which take up 8 bytes, for a total of 16 bytes.
	Therefore, \texttt{u\_type} takes up 16 bytes.
	
	\
	In a union, the address of each field is the same as the union object itself. In practice,
	this means that \texttt{up->t1} and \texttt{up->t2} both reference the beginning of the
	data structure. This can be seen in the code for the first entry of the table provided,
	for the expression \texttt{up->t1.u}, whose first associated instruction is
	\texttt{movq (\%rdi), \%rax}. Because \texttt{up} and \text{up->t1} both refer to the
	beginning of the data structure, and because the offset of the first field \texttt{u}
	in the data structure for \texttt{t1} is also at the beginning of that data structure,
	we can see that their addresses are all the same (here, \texttt{\%rdi}).
	
	\
	Since the first field of \texttt{up->t1} is \texttt{up->t.u}, an 8-byte \texttt{long},
	this means that the next field \texttt{up->t1.v} is at an 8 byte offset. Next,
	since \texttt{u} and \texttt{v} in struct \texttt{t1} are an 8-byte \texttt{long} and
	a 2-byte \texttt{short}, respectively, it follows that \texttt{up->t1.w} is at a 10-byte
	offset. Moreover, the address operator \texttt{\&} causes the expression to return
	a pointer (in this case, a \texttt{char *}). The \texttt{up->t2.a} refers to the first location as \texttt{up}, as explained before. However, \texttt{a} is an \texttt{int *} pointer.
	The next expression, \texttt{up->t2.a[up->t1.u]}, requires
	three instructions: one to compute the index given by \texttt{up->t1.u}, a memory reference
	that is stored in a register, and then a move from the register to \texttt{(\%rsi)}.
	The latter steps must be broken into two because when a memory location is a destination in 
	an instruction, the source cannot also be a memory location. The last expression,
	\texttt{*up->t2.p}, dereferences the member pointer \texttt{p}, so the expression
	has type \texttt{char}. The reference \texttt{up->t2.p} is at an 8-byte offset since
	it follows the 8-byte \texttt{int[2]} array in \texttt{t2}. Once again we need three instructions,
	because we need one instruction to compute the value of \texttt{p} before the instruction to
	dereference it, and once again, we need to put its value at a register because a
	memory reference cannot be the source and destination of an instruction.
	\begin{center}
		\begin{tabular}{ccc}
			\emph{expr} & \emph{type} & Code\\
			\hline
			\texttt{up->t1.u} & \texttt{long} & \texttt{movq (\%rdi), \%rax}\\
			{} & {} & \texttt{movq \%rax, (\%rsi)}\\
			
			\texttt{up->t1.v} & \texttt{short} & \texttt{movw 8(\%rdi), \%ax} \\
			{} & {} & \texttt{movw \%ax, (\%rsi)}\\
			
			\texttt{\&up->t1.w} & \texttt{char *} & \texttt{leaq 10(\%rdi), \%rax} \\
			{} & {} & \texttt{movw \%rax, (\%rsi)}\\
			
			\texttt{up->t2.a} & \texttt{int *} & \texttt{leaq (\%rdi), \%rax}\\
			{} & {} & \texttt{movq \%rax, (\%rsi)}\\
			
			\texttt{up->t2.a[up->t1.u]} & \texttt{int} & \texttt{movq (\%rdi), \%rax}\\
			{} & {} & \texttt{movl (\%rdi, \%rax, 4), \%eax}\\
			{} & {} & \texttt{movl \%eax, (\%rsi)}\\
			
			\texttt{*up->t2.p} & \texttt{char} & \texttt{movq 8(\%rdi), \%rax} \\
			{} & {} & \texttt{movb (\%rax), \%al}\\
			{} & {} & \texttt{movb \%al, (\%rsi)}\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.44}
	For each of the following structure declarations, determine the offset of each field,
	the total size of the structures, and its alignment requirement for x86-64:
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{struct P1 \{ int i; char c; int j; char d; \};}
		\item \texttt{struct P2 \{ int i; char c; char d; long j; \};}
		\item \texttt{struct P3 \{ short w[3]; char c[3]; \};}
		\item \texttt{struct P4 \{ short w[5]; char *c[3]; \};}
		\item \texttt{struct P5 \{ struct P3 a[2]; struct P2 t; \};}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item For \texttt{struct P1}, the \texttt{int i} has 0 offset, the \texttt{char c}
		has offset 4, given that \texttt{i} takes up 4 bytes. The \texttt{int j} field
		has alignment 8, where 3 bytes of padding are added right after \texttt{char c}
		to ensure it has a proper 4-byte element. Finally, \texttt{char d} has
		offset 12, given that \texttt{int j} has an offset of 8 bytes and its size
		is 4 bytes. Since the last field is 1 byte, this would suggest a total of 13
		bytes, but to satisfy alignment requirements in arrays, a total of 3 bytes
		of adding is added at the end. Therefore, \texttt{struct P1} has 16 bytes total.
		It has 4 byte alignment to satisfy the 
		
		\item By a similar reasoning, in \texttt{struct P2}, the field \texttt{int i}
		has offset 0, \texttt{char c} has offset 4, \texttt{char d} has offset 5, \texttt{long j}
		has offset 8. Altogether, the structure takes up 16 bytes, with 2 bytes of padding
		between \texttt{char d} and \texttt{long j}. It requires 8 byte alignment to satisfy
		the restriction of all of it fields.
		
		\item The \texttt{short w[3]} field in \texttt{struct P3} has offset 0. Since
		\texttt{short} is 2 bytes, it takes up 6 bytes, so the \texttt{char c[3]} has
		an offset of 6 bytes, ensuring that the alignment for \texttt{w} is satisfied.
		Since \texttt{char c[3]} takes up 3 bytes, this would imply 9 byte alignment,
		but to ensure the alignment restrictions are satisfied by fields of \texttt{struct P3}
		when packed into an array, we need 1 byte of padding to achieve 2-byte alignment.
		Therefore, \texttt{struct P3} takes up 10 bytes overall, with 1 byte of padding at the end.
		It has 2 byte alignment to satisfy the restriction of all of its elements.
		
		\item In \texttt{struct P4}, the field \texttt{short w[5]} is at offset 0, and
		it takes up 10 bytes. Since \texttt{char *c[3]} has \texttt{char *} elements, 
		each taking up 8 bytes, the overall structure require 8 byte alignment. Therefore,
		6 bytes of padding are added after \texttt{short w[5]}, so that the offset of
		\texttt{char *c[3]} is 16 bytes. Since \texttt{c} has 3 elements, it takes up 24 bytes,
		and hence the overall structure takes up 40 bytes. Its alignment is 8 bytes.
		
		
		\item Since \texttt{P3} takes up 10 bytes, the field \texttt{struct P3 a[2]} takes up
		20 bytes. But \texttt{P2} takes up 16 bytes, and due to its field it has an 8-byte
		alignment restriction. Therefore, 4 bytes of padding are added so that \texttt{struct P2 t}
		has offset 24 bytes. Overall, the structure takes up 40 bytes and has 8 byte alignment.
	\end{enumerate}
\end{sol}

\begin{ex}{3.45}
	Answer the following for the following declaration
	\begin{lstlisting}
struct {
	char	*a;
	short	 b;
	double	 c;
	char	 d;
	float	 e;
	char	 f;
	long	 g;
	int		 h;
} rec;
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item What are the byte offsets of all the fields in the structure?
		\item What is the total size of the structure?
		\item Rearrange the fields of the structure to minimize wasted space, and then
		show the byte offsets and total size for the rearranged structure.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{char *a} has byte offset 0 and takes up 8 bytes. \texttt{short b} has byte offset 8
		and takes up 2 bytes. It requires 6 bytes of padding to ensure \texttt{double c}, the next field,
		has a required alignment of 8 bytes. Therefore, \texttt{double c} has a 16 byte offset and takes up
		8 bytes. The next field \texttt{char d} has 24 byte offset and takes up 1 byte. For properly
		aligning the next field, \texttt{float e} taking up 4 bytes, 3 bytes of padding are needed.
		Therefore \texttt{float e} has 28 byte offset. The next field, \texttt{char f}, has 32 byte offset.
		Since takes up 1 byte is followed by an 8 byte \texttt{long}, it requires 7 bytes of padding.
		Hence, \texttt{long g} has a 40 byte offset, and lastly, \texttt{int h} has a 48 byte offset.
		\item Since \texttt{int h} takes up 4 bytes, we require 4 bytes of padding at the end to ensure that
		an array of these structures satisfies the byte alignment for all of it fields. Therefore,
		the structure takes up 56 bytes.
		\item We can re-arrange the fields and compute the new offsets:
		\begin{lstlisting}
struct {
	char	*a;	// offset 0
	double	 c;	// offset 8
	long	 g;	// offset 16
	float	 e;	// offset 24
	int		 h;	// offset 28
	short	 b;	// offset 32
	char	 d;	// offset 34
	char	 f;	// offset 35
};
		\end{lstlisting}
		The offsets are shown above. There is no padding in between any of the offsets,
		and the sum of the sizes of the fields is 36 bytes. Since the structure has fields that
		require 8 byte alignment, we need to add 4 bytes of padding, making the structure 40
		bytes in size.
	\end{enumerate}
\end{sol}

\begin{ex}{3.46}
	The C code below: shows a (low-quality) implementation of a function that reads a line from standard input,
	copies the string to newly allocated storage, and returns a pointer to the result:
	\begin{lstlisting}
/* This is very low-quality code
   It is intended to illustrate bad programming practices.
   See Practice Problem 3.46 */
char *get_line()
{
	char buf[4];
	char *result;
	gets(buf);
	result = malloc(strlen(buf));
	strcpy(result, buf);
	return result;
}
	\end{lstlisting}
	The disassembly up through call to \texttt{gets} is below:
	\begin{lstlisting}[language={}]
//	char *get_line()
0000000000400720 <get_line>:
	400720:	53						push	%rbx
	400721:	48 83 ec 10				sub		$0x10,%rsp
//	Diagram stack at this point
	400725:	48 89 e7				mov		%rsp,%rdi
	400728: e8 73 ff ff ff			callq	4006a0 <gets>
// Modify diagram to show stack content at this point
	\end{lstlisting}
	Consider the following scenario. Procedure \texttt{get\_line} is called with the return address
	equal to \texttt{0x400776} and register \texttt{\%rbx} equal to \texttt{0x0123456789ABCDEF}.
	You type the string
	\begin{center}
		\texttt{0123456789012345678901234}
	\end{center}
	The program terminates with a segmentation fault. You run \texttt{gdb} and determine that the
	error occurs during the execution of the \texttt{ret} instruction of \texttt{get\_line}.
	\begin{enumerate}[label=(\alph*)]
		\item Fill in the diagram that follows, indicating as much as you can about the stack
		just after executing the instruction in line 3 in the disassembly. Label the quantities
		stored on the stack (e.g., ``Return address") on the right, and their hexadecimal values
		(if known) within the box. Each box represents 8 bytes. Indicate the position of \texttt{\%rsp}.
		Recall that the ASCII codes for characters \texttt{0-9} are \texttt{0x30}-\texttt{0x39}.
		\begin{center}
			\begin{tabular}{|cccccccc|c|}
				\hline
				\texttt{00} & \texttt{00} & \texttt{00} & \texttt{00} & \texttt{00} & \texttt{40}&
				\texttt{00} & \texttt{76} & Return Address\\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & \\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & \\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & \\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & \\
				\hline
			\end{tabular}
		\end{center}
		\item Modify your diagram to show the effect of the call to \texttt{gets} (line 5).
		\item To what address does the program attempt to return?
		\item What register(s) have corrupted value(s) when \texttt{get\_line} returns?
		\item Besides the potential for buffer overflow, what two other things are
		wrong with the code for \texttt{get\_line}?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item When \texttt{get\_line} is called, the return address of its caller is at the
		top of the stack, as indicated by the first entry in the diagram. The first instruction
		\texttt{pushq \%rbx} places the contents of \texttt{\%rbx} on the top of the stack.
		The next instruction, \texttt{\$0x10}, allocates \texttt{16} bytes of space on the stack,
		since hexadecimal \texttt{0x10} has decimal value 16. At this point, there may
		have been a pre-existing value we do not know about.
		\begin{center}
			\begin{tabular}{|cccccccc|c|}
				\hline
				\texttt{00} & \texttt{00} & \texttt{00} & \texttt{00} & \texttt{00} & \texttt{40}&
				\texttt{00} & \texttt{76} & Return Address\\
				\hline
				\texttt{01} & \texttt{23} & \texttt{45} & \texttt{67} & \texttt{89} & \texttt{AB}&
				\texttt{CD} & \texttt{EF} & Value of \texttt{\%rbx}\\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & Unused \\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & Address of \texttt{buf} (top of stack \texttt{\%rsp})\\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & \\
				\hline
			\end{tabular}
		\end{center}
		\item The instruction \texttt{mov \%rsp, \%rdi} on line 4 indicates that the address of
		\texttt{buf} is at the top of the stack, and passed as an argument to \texttt{gets}.
		Since \texttt{gets} reads in the string
		\begin{center}
			\texttt{0123456789012345678901234}
		\end{center}
		which is 25 bytes long, plus 1 extra byte due to the null terminator character used in C strings,
		we find that the space allocated for \texttt{buf} is exceeded. The diagram looks as follows now:
		\begin{center}
			\begin{tabular}{|cccccccc|c|}
				\hline
				\texttt{00} & \texttt{00} & \texttt{00} & \texttt{00} & \texttt{00} & \texttt{40}&
				\texttt{00} & \texttt{34} & Return Address\\
				\hline
				\texttt{33} & \texttt{32} & \texttt{31} & \texttt{30} & \texttt{39} & \texttt{38}&
				\texttt{37} & \texttt{36} & \texttt{\%rbx}, overwritten\\
				\hline
				\texttt{35} & \texttt{34} & \texttt{33} & \texttt{32} & \texttt{31} & \texttt{30}&
				\texttt{39} & \texttt{38} & Next 8 bytes in \texttt{buf} (8 through 9, 0 through 5) \\
				\hline
				\texttt{37} & \texttt{36} & \texttt{35} & \texttt{34} & \texttt{33} & \texttt{32}&
				\texttt{31} & \texttt{30} & Address of \texttt{buf} (top of stack \texttt{\%rsp}) \\
				\hline
				\texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{} & \texttt{}&
				\texttt{} & \texttt{} & \\
				\hline
			\end{tabular}
		\end{center}
		Note that \texttt{\%rbx} was completely overwritten, and so were the first two bytes of the
		return address.
		\item The return address is now \texttt{0x0000000000400034}.
		\item Register \texttt{\%rbx} was completely overwritten with the hexadecimal
		representation of characters \texttt{67890123} from the input string. Since this is a callee-saved
		register, the \texttt{get\_line} function will attempt to restore it right before it returns,
		and hence it will restore a value different than what the caller expects.
		
		
		The first byte in register \texttt{\%rsp} was overwritten with \texttt{0x34}, corresponding to the
		last input \texttt{4}, and the second byte \texttt{0x00} was overwritten by the same
		value \texttt{0x00} corresponding to the string null terminator.
		
		\item It does not provide the extra character necessary for the null terminator; that is, it should
		be \texttt{strlen(buf) + 1} It does not check the return value of \texttt{gets}, which
		may be \texttt{NULL}. The code does not check whether \texttt{malloc} was successful. When
		\texttt{malloc} does not execute successfully (may there is no more memory available),
		it returns \texttt{NULL}. Passing this to \texttt{strcpy} will result in a segmentation fault
		as it tries to dereference the point while copying bytes.
	\end{enumerate}
\end{sol}

\begin{ex}{3.47}
	Running our stack-checking code 10,000 times on a system running Linux version 2.6.16, we obtained
	addresses ranging from a minimum of \texttt{0xffffb754} to a maximum of \texttt{0xffffd754}.
	\begin{enumerate}[label=(\alph*)]
		\item What is the approximate range of addresses?
		\item If we attempted to overrun with a 128-byte nop slep, about how many attempts would it
		take to test all starting addresses?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Since \texttt{0xb754} is 46,932 decimal and \texttt{0xd754} is 55,124
		Subtracting the addresses yields around \texttt{0x2000}, which is around $2\cdot 16^3=2^{13}=8192$.
		\item Since $128=2^{7}$, and a nop-slep essentially starts goes from addresses 0 through 127 in
		the first attempt, then 128 through 255, and so on, we essentially have $\frac{2^{12}}{2^{7}}=2^6=64$.
		It would take 64 attempts to test all starting addresses.
	\end{enumerate}
\end{sol}

\begin{ex}{3.48}
	The function \texttt{intlen}, \texttt{len}, and \texttt{iptoa} provide a very convoluted way
	to compute the number of decimal digits required to represent an integer. We will use this as a
	way to study some of aspects of the \texttt{gcc} stack protector facility.
	\begin{lstlisting}
int len(char *s) {
	return strlen(s);
}

void iptoa(char *s, long *p) {
	long val = *p;
	sprintf(s, "%ld", val);
}

int intlen(long x) {
	long v;
	char buf[12];
	v = x;
	iptoa(buf, &v);
	return len(buf);
}
	\end{lstlisting}
	The following show portions of the code for \texttt{inlen}, compiled both with and without
	stack pointer protector. First, without protector:
	\begin{lstlisting}[language={}]
	// int intlen(long x)
	// x in %rdi
intlen:
	subq	$40,		%rsp
	movq	%rdi,		24(%rsp)
	leaq	24(%rsp), 	%rsi
	movq	%rsp,		%rdi
	call	iptoa
	\end{lstlisting}
	With protector:
	\begin{lstlisting}[language={}]
	int intlen(long x)
	x in %rdi
intlen:
	subq	$56,	%rsp
	movq	%fs:40,	%rax
	movq	%rax,	40(%rsp)
	xorl	%eax,	%eax
	movq	%rdi,	8(%rsp)
	leaq	8(%rsp), %rsi
	leaq	16(%rsp), %rdi
	call iptoa
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item For both versions: What are the positions in the stack for \texttt{buf}, \texttt{v},
		and (when present) the canary value?
		\item How does the rearranged ordering of the local variables in the protected code
		provide greater security against a buffer overrun attack?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item For the version without stack protector, the first instruction
		\texttt{subq \$40, \%rsp} indicates we are allocating 40 bytes on the stack.
		The \texttt{movq \%rdi, 24(\%rsp)} is the assignment of\texttt{x} to \texttt{v}.
		Therefore, \texttt{v} is as at an offset of 24 bytes from the top of the stack.
		The line \texttt{movq \%rsp, \%rdi} indicates that we are passing \texttt{buf}
		as the first argument of \texttt{iptoa}. This indicates that \texttt{buf} is
		at the top of the stack.
		
		\
		For the version with stack protector, space is allocated on the stack for 56 bytes.
		In this case, the canary value by the \texttt{movq \%fs:40, \%rax} instruction into
		the \texttt{\%rax} register, and its value is loaded into the memory location
		at a 40 byte offset of the top of the stack, as indicated by \texttt{movq \%rax, 40(\%rsp)}.
		In this case, \texttt{leaq 16(\%rsp), \%rdi} indicates that buf is at a 16 byte offset
		from the top of the stack, and \texttt{leaq 8(\%rsp), \%rsi} indicates that \texttt{v}
		is at an 8 byte offset from the top of the stack.
		
		\item Between the two versions, the location of \texttt{buf} and \texttt{r} relative
		to the top of the stack was changed. In particular, \texttt{r} is closer to the top
		of the stack in the version with the stack protector. This means that if \texttt{buf}
		overflows, the value of \texttt{v} will not be overwritten. Moreover, \texttt{buf} is
		followed by the canary value. If the canary value is overwritten due to a buffer overflow,
		the changed value in the canary will be picked up by the compiler, which will flag it as
		an error and abort.
	\end{enumerate}
\end{sol}

\begin{ex}{3.49}
	In this problem, we will explore the logic behind the code in lines 5--11 on Figure 3.43(b),
	where space is allocated for variable-size array \texttt{p}. As the annotations on the code
	indicate, let $s_1$ denote the address of the stack pointer after executing the \texttt{subq}
	instruction of line 4. This instruction allocates space for local variable \texttt{i}.
	Let $s_2$ denote the value of the stack pointer after executing the \texttt{subq}
	instruction on line 7. This instruction allocates the storage for local array \texttt{p}.
	Finally, let $p$ denote the value assigned to registers \texttt{\%r8} and \texttt{\%rcx}
	in the instructions of lines 10--11. Both of these registers are used to reference array
	\texttt{p}.
	
	\
	The right-hand side of Figure 3.44 diagrams the positions of the locations indicated
	by $s_1$, $s_2$, and $p$. It also shows that there may be an offset of $e_2$ bytes between
	the values of $s_1$ and $p$. This space will not be used. There may also be an offset of
	$e_1$ bytes between the end of array \texttt{p} and the position indicated by $s_1$.
	\begin{enumerate}[label=(\alph*)]
		\item Explain, in mathematical terms, the logic in the computation of $s_2$ on lines
		5--7. \emph{Hint}: Think about the bit-level representation of $-16$ and its effect
		in the \texttt{andq} instruction of line 6.
		\item Explain, in mathematical terms, the logic in the computation of $p$ on lines
		8--10. \emph{Hint}: You may want to refer to the discussion on division by powers of 2
		in Section 2.3.7.
		\item For the following values of $n$ and $s_1$, trace the execution of the code
		to determine what the resulting values would be for $s_2$, $p$, $e_1$, and $e_2$.
		\begin{center}
			\begin{tabular}{cccccc}
				$n$ & $s_1$ & $s_2$ & $p$ & $e_1$ & $e_2$\\
				\hline
				5 & $2,065$ & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
				
				6 & $2,064$ & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}& \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			\end{tabular}
		\end{center}
		\item What alignment properties does this guarantee for the values of $s_2$ and
		$p$?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The location $s_1$ is where the address of the stack pointer after allocating
		space for $i$. The instruction on line $5$ \texttt{leaq 22(,\%rdi, 8), \%rax} uses
		the value \texttt{n} is in register \texttt{\%rdi} to store the value $x=22+8n$
		in register \texttt{\%rax}. The instruction \texttt{andq \$-16, \%rax} on
		line 6 then computes the $x$ AND $-16$. Note that $-16=-1\cdot 16$, which
		is equivalent to \texttt{-1 << 4}. Since $-1$ has all 1s in its binary representation,
		it follows from the left shift operation that $-16$ has all 1s except for
		4 zeroes in its least significant bits. Therefore, the effect when involved
		in the AND operation is to remote the least significant byte. Put another way,
		suppose $r=x\mod 16$. Then the instruction on line $16$ subtracts the remainder $r$
		from $x$ and places it in \texttt{\%rax}. Now \texttt{\%rax} has value $y=x-r$ in
		its register. Note that
		\begin{align*}
			r&=x\mod 16\\
			&=(22+8n)\mod 16\\
			&=(6+8n)\mod 16
		\end{align*}
		If $n$ is even, then $n=2k$, and in that case we get
		\begin{align*}
			r=(6+8n)\mod 16=(6+16k)\mod 16=6
		\end{align*}
		If $n$ is odd, then $n=2k+1$ for some $k$, and we have
		\begin{align*}
			r=(6+16k+8)\mod 16=(14+16k)\mod 16=14
		\end{align*}
		Therefore, $r$ is $6$ or $14$. Since $x=22+8n$, this means that
		\begin{align*}
			y=\begin{cases}
				16 + 8n & \text{if $n$ is even}\\
				8 + 8n & \text{if $n$ is odd}
			\end{cases}
		\end{align*}
		Now, the instruction \texttt{subq \%rax, \%rsp} on
		line 7 subtracts $y=x$ from $s_1$, since $s_1$ is the current value on the stack,
		to compute $s_2$. Hence, the new value on top of the stack is
		\begin{align*}
			s_2=\begin{cases}
				s_1-(16+8n) & \text{if $n$ is even}\\
				s_1-(8+8n)& \text{if $n$ is odd}
			\end{cases}
		\end{align*}
		\item The instruction \texttt{leaq 7(\%rsp), \%rax} on line 8 and the instruction
		\texttt{shrq \$3, \%rax} takes the value $s_2$ in register \texttt{\%rax} and
		replaces it with $(s_2 + 7) >> 3 = (s_2 + (1 << 3) - 1) >> 3$, which is the computation
		for dividing a two's complement number by $2^3=8$. This computes $s_2/8$ and rounds up.
		The instruction \texttt{leaq 0(,\%rax,8), \%r8} on line 10 multiplies this value by 8.
		Now \texttt{\%r8} has value
		\begin{align*}
			p=\begin{cases}
				8\lceil s_1/8\rceil - (16+8n) & \text{if $n$ is even}\\
				8\lceil s_1/8\rceil - (8+8n) & \text{if $n$ is odd}
			\end{cases}
		\end{align*}		
		The result is that the address in $p$ is now a multiple of $8$, ensuring its aligned
		on 8 bytes, as required by its elements of type \texttt{long *}.
		Moreover, it is greater than $s_2$, so it is above $s_2$. In short, it is the address
		closes to $s_2$ that is a multiple of $8$.
		\item 
		\begin{center}
			\begin{tabular}{cccccc}
				$n$ & $s_1$ & $s_2$ & $p$ & $e_1$ & $e_2$\\
				\hline
				$5$ & $2,065$ & $2017$ &$2024$ & $1$ & $7$\\
				
				$6$ & $2,064$ & $2000$ & $2000$ & $16$ & $0$
			\end{tabular}
		\end{center}
		\item $p$ is aligned on 8 bytes with respect to \texttt{\%rbp} consistent
		with the fact that \texttt{long *} requires 8 byte alignment. Also,
		$s_2$ is aligned on 16 bytes with respect to \texttt{$s_1$}.
	\end{enumerate}
\end{sol}

\begin{ex}{3.50}
	For the following C code, the expressions \texttt{val1}--\texttt{val4} all map to the
	program values \texttt{i}, \texttt{f}, \texttt{d}, and \texttt{l}:
	\begin{lstlisting}
double fvct2(int *ip, float *fp, double *dp, long l)
{
	int i = *ip; float f = *fp; double d = *dp;
	*ip = (int)		val1;
	*fp = (float)	val2;
	*dp = (double)	val3;
	return (double)	val4;
}
	\end{lstlisting}
	Determine the mapping, based on the following x86-64 code for the function:
	\begin{lstlisting}[language={}]
	double fvct2(int *ip, float *fp, double *dp, long l)
	ip in %rdi, fp in %rsi, dp in %rdx, l in %rcx
	Result returned in %xmm0
fcvt2:
	movl		(%rdi),		%eax
	vmovss		(%rsi),		%xmm0
	vcvttsd2si	(%rdx),		%r8d
	movl		%r8d,		(%rdi)
	vcvtsi2ss	%eax,		%xmm1,	%xmm1
	vmovss		%xmm1,		(%rsi)
	vcvtsi2sdq	%rcx,		%xmm1,	%xmm1
	vmovsd		%xmm1,		(%rdx)
	vunpcklps	%xmm0,		%xmm0,	%xmm0
	vcvtps2pd	%xmm0,		%xmm0
	ret
	\end{lstlisting}
\end{ex}

\begin{sol}
	\
	We begin by annotating the assembly:
	\begin{lstlisting}[language={}]
	double fvct2(int *ip, float *fp, double *dp, long l)
	ip in %rdi, fp in %rsi, dp in %rdx, l in %rcx
	Result returned in %xmm0
fcvt2:
	movl		(%rdi),		%eax			// int i = *ip
	vmovss		(%rsi),		%xmm0			// float f = *fp;
	vcvttsd2si	(%rdx),		%r8d			// Convert *dp to an integer
	movl		%r8d,		(%rdi)			// *ip = (int) d;
	vcvtsi2ss	%eax,		%xmm1,	%xmm1	// Convert i to single-precision float
	vmovss		%xmm1,		(%rsi)			// *fp = (float) i;
	vcvtsi2sdq	%rcx,		%xmm1,	%xmm1	// Convert l to double-precision float
	vmovsd		%xmm1,		(%rdx)			// *dp = (float) l;
	vunpcklps	%xmm0,		%xmm0,	%xmm0	// 
	vcvtps2pd	%xmm0,		%xmm0			// Extend *fp to a double
	ret										// return (double) f;
	\end{lstlisting}
	
	The C code now looks like:
		\begin{lstlisting}
double fvct2(int *ip, float *fp, double *dp, long l)
{
	int i = *ip; float f = *fp; double d = *dp;
	*ip = (int)		d;
	*fp = (float)	i;
	*dp = (double)	l;
	return (double)	f;
}
		\end{lstlisting}
\end{sol}

\begin{ex}{3.51}
	The following C function converts an argument of type \texttt{src\_t} to a return value
	of type \texttt{dst\_t}, where these two types are defined using \texttt{typedef}:
	\begin{lstlisting}
dest_t cvt(src_t x)
{
	dest_t y = (dest_t) x;
	return y;
}
	\end{lstlisting}
	For an extension on x86-64, assume that argument \texttt{x} is either in \texttt{\%xmm0}
	or in the appropriately named portion of register \texttt{\%rdi} (i.e., \texttt{\%rdi} or
	\texttt{\%edi}). One or two instructions are to be used to perform the type conversion and
	to copy the value to the appropriately named portion of register \texttt{\%rax} (integer
	result) or \texttt{\%mm0} (floating-point result). Show the instruction(s), including the
	source and destination registers.
	\begin{center}
		\begin{tabular}{ccc}
			$T_{\texttt{x}}$ & $T_{\texttt{y}}$ & Instruction(s)\\
			\hline
			\texttt{long} & \texttt{double} & \texttt{vcvtsi2sdq \%rdi, \%mm0}\\
			\texttt{double} & \texttt{int} & \makebox[3cm]{\hrulefill}\\
			\texttt{double} & \texttt{float} & \makebox[3cm]{\hrulefill}\\
			\texttt{long} & \texttt{float} & \makebox[3cm]{\hrulefill}\\
			\texttt{float} & \texttt{long} & \makebox[3cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{ccc}
			$T_{\texttt{x}}$ & $T_{\texttt{y}}$ & Instruction(s)\\
			\hline
			\texttt{long} & \texttt{double} & \texttt{vcvtsi2sdq \%rdi, \%xmm0, \%xmm0} \\
			\texttt{double} & \texttt{int} & \texttt{vcvttsd2si \%xmm0, \%eax} \\
			\texttt{double} & \texttt{float} & \texttt{vcvtsd2ss \%xmm0, \%xmm0, \%xmm0} \\
			\texttt{long} & \texttt{float} & \texttt{vcvtsi2sdq \%rdi, \%xmm0, \%xmm0} \\
			\texttt{float} & \texttt{long} & \texttt{vcvttss2siq \%xmm0, \%rax}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{3.52}
	For each of the following function declarations, determine the register assignments for
	the arguments:
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{double g1(double a, long b, float c, int d);}
		\item \texttt{double g2(int a, double *b, float *c, long d);}
		\item \texttt{double g3(double *a, double b, int c, float d);}
		\item \texttt{double g4(float a, int *b, float c, double d);}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{a} in \texttt{\%xmm0}, \texttt{b} in \texttt{\%rdi}, \texttt{c} in
		\texttt{\%xmm1}, and \texttt{d} in \texttt{\%esi}.
		\item \texttt{a} in \texttt{\%edi}, \texttt{b} in \texttt{\%xmm0}, \texttt{c} in
		\texttt{\%rsi}, and \texttt{d} in \texttt{\%rdx}.
		\item \texttt{a} in \texttt{\%rdi}, \texttt{b} in \texttt{\%xmm0}, \texttt{c} in
		\texttt{\%esi}, and \texttt{d} in \texttt{\%xmm1}.
		\item \texttt{a} in \texttt{\%xmm0}, \texttt{b} in \texttt{\%rdi}, \texttt{c} in
		\texttt{\%xmm1}, and \texttt{d} in \texttt{\%xmm2}.
	\end{enumerate}
\end{sol}

\begin{ex}{3.53}
	For the following C function, the types of the four arguments are defined by \texttt{typdef}:
	\begin{lstlisting}
double funct1(arg1_t p, arg2_t q, arg3_t r, arg4_t s)
{
	return p/(q+r) - s;
}
	\end{lstlisting}
	When compiled, \texttt{gcc} generates the following code:
	\begin{lstlisting}[language={}]
	double funct1(arg1_t p, arg2_t q, arg3_t r, arg4_t s)
funct1:
	vcvtsi2ssq		%rsi,	%xmm2,	%xmm2
	vaddss			%xmm0,	%xmm2,	%xmm0
	vcvtsi2ss		%edi,	%xmm2,	%xmm2
	vdivss			%xmm0,	%xmm2,	%xmm0
	vunpcklps		%xmm0,	%xmm0,	%xmm0
	vcvtps2pd		%xmm0,	%xmm0
	vsubsd			%xmm1,	%xmm0,	%xmm0
	ret
	\end{lstlisting}
	Determine the possible combinations of types of the four arguments (there may be
	more than one).
\end{ex}

\begin{sol}
	\
	The annotated assembly is:
	\begin{lstlisting}[language={}]
	double funct1(arg1_t p, arg2_t q, arg3_t r, arg4_t s)
funct1:
	vcvtsi2ssq		%rsi,	%xmm2,	%xmm2	// Convert long to float
	vaddss			%xmm0,	%xmm2,	%xmm0	// Add two floats
	vcvtsi2ss		%edi,	%xmm2,	%xmm2	// Convert int to float
	vdivss			%xmm0,	%xmm2,	%xmm0	// Divide two floats
	// The next two instructions convert float to double
	vunpcklps		%xmm0,	%xmm0,	%xmm0
	vcvtps2pd		%xmm0,	%xmm0
	
	vsubsd			%xmm1,	%xmm0,	%xmm0	// Subtract two doubles
	ret
	\end{lstlisting}
	From the last instruction, we infer that \texttt{s} is in the \texttt{\%xmm1}
	register, since it is subtracted from the value computed so far in \texttt{\%xmm0}.
	Since it has undergone no conversions so far, we conclude that \texttt{arg4\_t}
	is \texttt{double}.
	
	From the \texttt{vdivss} instruction we see that \texttt{\%xmm2} must hold the
	numerator \texttt{p} of the division. The instruction right before is one
	that converts an integer stored in \texttt{\%edi} to a \texttt{float}. Therefore,
	we conclude that \texttt{p} must be a 32-bit integer (an \texttt{int}).
	
	\
	Based on the remaining annotations, the two remaining arguments are of type
	\texttt{long} and \texttt{float}, because they involve the \texttt{\%xmm0} register
	and the \texttt{\%rsi} register.
	Therefore, \texttt{arg2\_t} is a  \texttt{float} and \texttt{arg3\_t} is a \texttt{long},
	or viceversa.
\end{sol}

\begin{ex}{3.54}
	Function \texttt{funct2} has the following prototype:
	\begin{lstlisting}
double funct2(double w, int x, float y, long z);
	\end{lstlisting}
	\texttt{gcc} generates the following for the function:
	\begin{lstlisting}[language={}]
	double funct2(double w, int x, float y, long z);
	w in %xmm0, x in %edi, y in %xmm1, z in %rsi
funct2:
	vcvtsi2ss		%edi,	%xmm2,	%xmm2
	vmulss			%xmm1,	%xmm2,	%xmm1
	vunpcklpls		%xmm1,	%xmm1,	%xmm1
	vcvtps2pd		%xmm1,	%xmm2
	vcvtsi2sdq		%rsi,	%xmm1,	%xmm1
	vdivsd			%xmm1,	%xmm0,	%xmm0
	vsubsd			%xmm0,	%xmm2,	%xmm0
	ret
	\end{lstlisting}
	Write a C version of \texttt{funct2}.
\end{ex}

\begin{sol}
	\
	I have annotated the assembly below:
	\begin{lstlisting}[language={}]
	double funct2(double w, int x, float y, long z);
	w in %xmm0, x in %edi, y in %xmm1, z in %rsi
funct2:
	vcvtsi2ss		%edi,	%xmm2,	%xmm2	// Convert integer to float: (float) x
	vmulss			%xmm1,	%xmm2,	%xmm1	// y *= (float) x 
	// Convert y from float to double
	vunpcklpls		%xmm1,	%xmm1,	%xmm1
	vcvtps2pd		%xmm1,	%xmm2			// double s = y
	
	vcvtsi2sdq		%rsi,	%xmm1,	%xmm1	// double r = z  (long -> double)
	vdivsd			%xmm1,	%xmm0,	%xmm0	// w /= r;
	vsubsd			%xmm0,	%xmm2,	%xmm0	// return s - r;
	ret
	\end{lstlisting}
	The corresponding C code is below:
	\begin{lstlisting}
double funct2(double w, int x, float y, long z)
{
	double s = y * (float) x; // Convert y to float
	double r = w / z;
	return s - r;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.55}
	Show how the numbers declared at label \texttt{.LC3} encode the number \texttt{32.0}.
\end{ex}

\begin{sol}
	\
	At \texttt{.L3} we have:
	\begin{lstlisting}[language={}]
.LC3:
	.long	0				// Low-order 4 bytes of 32.0
	.long	1077936128		// High-order 4 bytes of 32.0
	\end{lstlisting}
	Converting \texttt{1077936128} by dividing by 16 yields:
	\begin{align*}
		1077936128&=16\cdot 67371008 + 0\\
		67371008&=16\cdot 4210688 + 0\\
		4,210,688 &= 16\cdot 263168 + 0\\
		263,168 &= 16 \cdot 16488 + 0\\
		16488&=16\cdot 1028 + 0\\
		1024&=16\cdot 64 + 4\\
		64 &= 16\cdot 4 + 0\\
		4 &= 16\cdot 0 + 4
	\end{align*}
	The corresponding number in hex is \texttt{0x40400000}. The \texttt{0x404}
	is equivalent to binary \texttt{0100 0000 0100}. The leading bit is the sign
	bit, and 0 indicates a positive number, which is true for \texttt{32.0}.
	The remaining 11 bits yield the number \texttt{1028}. Subtracting the bias
	\texttt{1023} yields an exponent of \texttt{5}. Since the exponent is nonzero,
	the number is a normalized floating point, so the significand is $M=1+f$,
	where $f$ is the fractional part. Since the rest of the bits in the
	binary sequence are 0, this means that $f=0$ and $M=1$. The value is
	therefore $V=2^E\cdot M=2^5\cdot 1=32$.
\end{sol}

\begin{ex}{3.56}
	Consider the following C function, where \texttt{EXPR} is a macro defined with a
	\texttt{\#define}:
	\begin{lstlisting}
double simplefun(double x) {
	return EXPR(x);
}
	\end{lstlisting}
	Below, we show the AVX2 code generated for different definitions of \texttt{EXPR},
	where value \texttt{x} is held in \texttt{\%xmm0}. All of them correspond to some
	useful operation on floating-point values. Identify what the operations are. Your
	answers will require you to understand the bit patterns of the constant words
	being retrieved from memory.
	\begin{enumerate}[label=(\alph*)]
		\item
		\
		\begin{lstlisting}[language={}]
	vmovsd	.LC1(%rip),		%xmm1
	vandpd	%xmm1,			%xmm0	%xmm0
.LC1:
	.long	4294967295
	.long	2147483647
	.long	0
	.long	0
		\end{lstlisting}
		\item 
		\
		\begin{lstlisting}[language={}]
	vxorpd	%xmm0,	%xmm0,	%xmm0
		\end{lstlisting}
		\item
		\
		\begin{lstlisting}[language={}]
	vmovsd	.LC2(%rip),		%xmm1
	vxorpd	%xmm1,			%xmm0,	%xmm0
.LC2:
	.long	0
	.long	-2147483648
	.long	0
	.long	0
		\end{lstlisting}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The \texttt{4294967295} is $2^{32}-1$, and corresponds to hex value \texttt{ff ff ff ff}.
		Meanwhile \texttt{2147483647} is $2^{31}-1$, and corresponds to hex value \texttt{7f ff ff ff}.
		The latter is the higher-order 4 bytes of a double precision number.
		The three leading bytes \texttt{0x7ff} correspond to binary \texttt{0111 1111 1111}.
		The sign bit is 0, and the remaining bits are 1. Since the lower ordered bytes (for the
		fractional part) are not 0, this number must be \texttt{NaN}. Noting the
		\texttt{vandpd} instruction, we must have \texttt{NaN \& x}. The value of the expression
		is a bit pattern that is the same as \texttt{x}, except that the most significant bit
		is 0. Therefore it returns the absolute value of \texttt{x}.
		\item This computes \texttt{x \^{} x}, which gives 0.
		\item The number \texttt{-2147483648} has hex representation \texttt{80 00 00 00}.
		Hence, the binary representation of the leading three bytes \texttt{0x800} is
		\texttt{1000 0000 0000}. This has a sign bit of 1, and all exponent bits are 0.
		The rest of the bits in the pattern are also 0. Since the operation is for \texttt{vxorpd},
		which computes exclusive or, this has the effect of flipping the leading bit (
		since \texttt{1\^{} 1} is 0 and \texttt{1\^{} 0} i s 1), and retaining the rest of the bits.
		This calculation negates \texttt{x}.
	\end{enumerate}
\end{sol}

\begin{ex}{3.57}
	Function \texttt{funct3} has the following prototype:
	\begin{lstlisting}
double funct2(int *ap, double b, long c, float *dp);
	\end{lstlisting}
	For this function, \texttt{gcc} generates the following code:
	\begin{lstlisting}
	double funct3(int *ap, double b, long c, float *dp)
	ap in %rdi, b in %xmm0, c in %rsi, dp in %rdx
funct3:
	vmovss		(%rdx),		%xmm1
	vcvtsi2sd	(%rdi),		%xmm2,	%xmm2
	vucomisd	%xmm2,		%xmm0
	jbe			.L8
	vcvtsi2ssq	%rsi,		%xmm0,	%xmm0
	vmulss		%xmm1,		%xmm0,	%xmm1
	vunpcklps	%xmm1,		%xmm1,	%xmm1
	vcvtps2pd	%xmm1,		%xmm0
	ret
.L8:
	vaddss		%xmm1,		%xmm1,	%xmm1
	vcvtsi2ssq	%rsi,		%xmm0,	%xmm0
	vaddss		%xmm1,		%xmm0,	%xmm0
	vunpcklps	%xmm0,		%xmm0,	%xmm0
	vcvtps2pd	%xmm0,		%xmm0
	ret
	\end{lstlisting}
	Write a C version of \texttt{funct3}.
\end{ex}

\begin{sol}
	\
	The annotated version of the assembly is:
		\begin{lstlisting}
	double funct3(int *ap, double b, long c, float *dp)
	ap in %rdi, b in %xmm0, c in %rsi, dp in %rdx
funct3:
	vmovss		(%rdx),		%xmm1			// float d = *dp;
	vcvtsi2sd	(%rdi),		%xmm2,	%xmm2	// double v = *ap;
	vucomisd	%xmm2,		%xmm0			// Compare b:v
	jbe			.L8							// if <=  go to .L8
	vcvtsi2ssq	%rsi,		%xmm0,	%xmm0	// float r = c;
	vmulss		%xmm1,		%xmm0,	%xmm1	// d *= r;
	vunpcklps	%xmm1,		%xmm1,	%xmm1	
	vcvtps2pd	%xmm1,		%xmm0
	ret										// return d;
.L8:
	vaddss		%xmm1,		%xmm1,	%xmm1	// d += d; // double d
	vcvtsi2ssq	%rsi,		%xmm0,	%xmm0	// float z = c;
	vaddss		%xmm1,		%xmm0,	%xmm0	// z += d;
	vunpcklps	%xmm0,		%xmm0,	%xmm0	
	vcvtps2pd	%xmm0,		%xmm0
	ret										// return z;
		\end{lstlisting}
		The corresponding C code is below:
		\begin{lstlisting}
double funct3(int *ap, double b, long c, float *dp)
{
	float d = *dp;
	double v = *ap;
	if (b > v) {
		return c * d
	} else {
		return 2 * d + c;
	}
}
		\end{lstlisting}
\end{sol}

\begin{ex}{3.58}
	For a function with prototype
	\begin{lstlisting}
long decode2(long x, long y, long z);
	\end{lstlisting}
	\texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
decode2:
	subq	%rdx,	%rsi
	imulq	%rsi,	%rdi
	movq	%rsi,	%rax
	salq	$63,	%rax
	sarq	$63,	%rax
	xorq	%rdi,	%rax
	ret
	\end{lstlisting}
	Parameters \texttt{x}, \texttt{y}, and \texttt{z} are
	passed in registers \texttt{\%rdi}, \texttt{\%rsi}, and
	\texttt{\%rdx}. The code stores the return value in register
	\texttt{\%rax}. Write C code for \texttt{decode2} that will
	have an effect equivalent to the assembly code shown.
\end{ex}

\begin{sol}
	\
	We can begin by annotating the assembly:
	\begin{lstlisting}[language={}]
decode2:
	subq	%rdx,	%rsi	// y = y - z;
	imulq	%rsi,	%rdi	// x = x * y;
	movq	%rsi,	%rax	// long result = y;
	salq	$63,	%rax	// result = result << 63;
	sarq	$63,	%rax	// result = result >> 63;
	xorq	%rdi,	%rax	// result = result ^ x;
	ret						// return result;
	\end{lstlisting}
	The corresponding C code is below:
	\begin{lstlisting}
long decode2(long x, long y, long z) {
	y = y - z;
	x = x * y;
	long result = y;
	result = result << 63;
	result = result >> 63;
	return result ^ x;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.59}
	The following code computes the 128-bit product of two 64-bit
	signed values $x$ and $y$ and stored the result in memory:
	\begin{lstlisting}
typedef __int128 int128_t;

void store_prod(int128_t *dest, int64_t x, int64_t y) {
	*dest = x * (int128_t) y;
}
	\end{lstlisting}
	\texttt{gcc} generates the following assembly implementing the
	computation:
	\begin{lstlisting}[language={}]
store_prod:
	movq	%rdx,	%rax
	cqto
	movq	%rsi,	%rcx
	sarq	$63,	%rcx
	imulq	%rax,	%rcx
	imulq	%rsi,	%rdx
	addq	%rdx,	%rcx
	mulq	%rsi
	addq	%rcx,	%rdx
	movq	%rax,	(%rdi)
	movq	%rdx,	8(%rdi)
	ret
	\end{lstlisting}
	This code uses three multiplications for the multiprecision arithmetic
	required to implement 128-bit arithmetic on a 64-bit machine. Describe
	the algorithm used to compute the product, and annotate the assembly
	code to show how it realizes your algorithm. \emph{Hint}: When
	extending arguments of $x$ and $y$ to 128 bits, they can be written
	as $x=2^{64}\cdot x_h+x_l$ and $y=2^{64}\cdot y_h + y_l$, where
	$x_h$, $x_l$, $y_h$, and $y_l$ are 64-bit values. Similarly, the
	128-bit product can be written as $p=2^{64}\cdot p_h+p_l$, where
	$p_h$ and $p_l$ are 64-bit values. Show how the code computes the
	values of $p_h$ and $p_l$ in terms of $x_h$, $x_l$, $y_h$, and $y_l$.
\end{ex}

\begin{sol}
	\
	The annotated assembly is below:
\begin{lstlisting}[language={}]
	void store_prod(int128_t *dest, int64_t x, int64_t y)
	dest in %rdi, x in %rsi, y in %rdx
store_prod:
	movq	%rdx,	%rax	// Copy y to %rax
	cqto					// Copy sign bits of %rax into %rdx to extend to 128
	movq	%rsi,	%rcx	// int64_t t = x;
	sarq	$63,	%rcx	// t = x >> 63; // shift right arithmetically
	imulq	%rax,	%rcx	// t = t * value in %rax; // sign of x times y
	imulq	%rsi,	%rdx	// y = y * x; // lower product of x and y
	addq	%rdx,	%rcx	// t = t + y; // 
	mulq	%rsi			// x * result; // store product in R[%rdx]:R[%rax]
	addq	%rcx,	%rdx	// y = y + t;
	movq	%rax,	(%rdi)	// Store least bits of product in result
	movq	%rdx,	8(%rdi)	// Store most significand bits of product in result
	ret						// return
\end{lstlisting}
	The algorithm simply uses the distributive property to compute the following:
	\begin{align*}
		x\cdot y&=(2^{64}x_h+x_l)(2^{64}y_h+y_l)\\
		&=2^{128}x_hy_h+2^{64}(x_hy_l+y_hx_l)+x_ly_l
	\end{align*}
	Here, $x_h$ and $y_h$ are each repeats of the sign bit $x_{63}$ and $y_{63}$,
	respectively. Note that $2^{128}x_hy_h$ is dropped since the product must be in
	two 64-bit registers. Moreover, since the operands $x$ and $y$ are 64-bit, the product
	truncating does not affect the value of the product. Put another way, the
	product $p$ is $p=(x\cdot y)\mod 128$.
	
	\
	Consider the algorithm described by the assembly.
	It begins by placing $y_l$ in \texttt{\%rax}, then sign extends it with
	the \texttt{cqto} command, replicating $y_{63}$ (the sign bit of $y$) across
	all of \texttt{\%rdx}, so its 64 bit make up $y_h$. Then, it computes the sign of
	\texttt{x} by using an arithmetic right shift by 63 bits, the value that would
	go in the higher 64 bit of \texttt{x} when it is sign-extended to 128 bits; we'll
	call it $\text{sgn}(x)$ or equivalently $x_h$. Then the algorithm places the product
	$y_l\cdot x_h$ in \texttt{\%rcx}. Similarly, it places the product $y_h\cdot x_l$ in
	\texttt{\%rdx}. Their sum is placed in \texttt{\%rcx}. It then computes $x_l\cdot y_l$
	and places the lower part of the result in \texttt{\%rax}, and the upper part of the
	result in \texttt{\%rdx}. Finally, the we add to the upper product the value stored
	in \texttt{\%rdx} the value $y_lx_h+y_hx_l$ currently in \texttt{\%rcx}. The last
	two \texttt{movq} instructions place the product in the memory location pointed to
	by \texttt{dest}
\end{sol}

\begin{ex}{3.60}
	Consider the following assembly code:
	\begin{lstlisting}[language={}]
	long loop(long x, int n)
	x in %rdi, n in %esi
loop:
	movl	%esi,	%ecx
	movl	$1,		%edx
	movl	$0,		%eax
	jmp		.L2
.L3:
	movq	%rdi,	%r8
	andq	%rdx,	%r8
	orq		%r8,	%rax
	salq	%cl,	%rdx
.L2:
	testq	%rdx,	%rdx
	jne		.L3
	rep; ret
	\end{lstlisting}
	The preceding code was generated by compiling C code that had the following overall form:
	\begin{lstlisting}
long loop(long x, long n)
{
	long result = _________;
	long mask;
	for (mask = ________; mask _________ ; mask = _______ ) {
		result |= ________;
	}
	return result;
}
	\end{lstlisting}
	Your task is to fill in the missing parts of the C code to get a program equivalent to the
	generated assembly code. Recall that the result of the function is returned in the register
	\texttt{\%rax}.  You will find it helpful to examine the assembly code before, during and
	after the loop to form a consistent mapping between the registers and the program variables.
	\begin{enumerate}[label=(\alph*)]
		\item Which registers hold program values \texttt{x}, \texttt{n}, \texttt{result}, and
		\texttt{mask}?
		\item What are the initial values of \texttt{result} and \texttt{mask}?
		\item What is the test condition for \texttt{mask}?
		\item How does \texttt{mask} get updated?
		\item How does \texttt{result} get updated?
		\item Fill in the missing parts of the C code.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	The annotated assembly is below:
	\begin{lstlisting}[language={}]
	long loop(long x, int n)
	x in %rdi, n in %esi
loop:
	movl	%esi,	%ecx	// long k = n;
	movl	$1,		%edx	// long mask = 1;
	movl	$0,		%eax	// long result = 0;
	jmp		.L2
.L3:
	movq	%rdi,	%r8		// long q = x
	andq	%rdx,	%r8		// q = x & mask;
	orq		%r8,	%rax	// result = result | q
	salq	%cl,	%rdx	// mask = mask << k // this is n with 0s in upper 32 bits
.L2:
	testq	%rdx,	%rdx	// test j
	jne		.L3				// if != 0 go to .L3
	rep; ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{x} is in the 64-bit register \texttt{\%rdi}, \texttt{n} is in the
		32-bit register \texttt{\%esi}, \texttt{result} is in the 64-bit register
		\texttt{\%rax}, and \texttt{mask} is in the 64-bit register \texttt{\%rdx}.
		\item \texttt{result} is initially 0, as given by the instruction \texttt{movl \$0, \%eax}.
		Then \texttt{mask} is initially \texttt{1}, as given by \texttt{movl \$1, \%edx}, which
		places 1 in the lower 32 bit portion of \texttt{\%rdx} and places 0s in the upper 32
		bit portion.
		\item The test condition is \texttt{mask != 0}.
		\item The mask is updated through a logical left shift with instruction \texttt{salq \$cl, \%rdx}.
		Specifically, it's \texttt{mask = mask << n}.
		\item It's \texttt{result = result | (x \& mask)}.
		\item The C code is below:
		\begin{lstlisting}
long loop(long x, long n)
{
	long result = 0;
	long mask;
	for (mask = 1; mask != 0 ; mask = mask << n ) {
		result |= x & mask;
	}
	return result;
}
		\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{3.61}
	In section 3.6.6, we examined the following code as a candidate for the use of conditional
	data transfer:
	\begin{lstlisting}
long cread(long *xp) {
	return (xp ? *xp : 0);
}
	\end{lstlisting}
	We showed a trial implementation using a conditional move instruction but argued that it was
	not valid, since it could attempt to read from a null address.
	
	\
	Write a C function \texttt{cread\_alt} that has the same behavior as \texttt{cread}, except
	that it can be compiled to use a conditional data transfer. When compiled, the generated code
	should use a conditional move instruction rather than one of the jump instructions.
\end{ex}

\begin{sol}
	\
	The reason why the trial implementation failed was because it evaluated \texttt{*xp}
	and \texttt{0} regardless of the value in \texttt{xp}, which could result in a null
	pointer exception when \texttt{xp} is dereferenced. The code below would work:
	\begin{lstlisting}
long cread(long *xp) {
	long zp = 0;
	if (xp != NULL)
		zp = *xp;
	return zp;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.62}
	The code that follows shows an example of branching on an enumerated type value in
	a switch statement. Recall that enumerated types in C are simply a way to introduce a
	set of names having associated integer values. By default, the values are assigned to
	the names count from zero upward. In our code, the actions associated with the different
	case labels have been  omitted.
	\begin{lstlisting}
/* Enumerated type creates a set of constants numbered 0 and upward */
typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t;

long switch3(long *p1, long *p2, mode_t action)
{
	long result = 0;
	switch(action) {
		case MODE_A:
		
		case MODE_B:
		
		case MODE_C:
		
		case MODE_D:
		
		case MODE_E:
		
		default:
		
	}
	return result;
}
	\end{lstlisting}
	The part of the generated assembly code implementing the different actions is shown
	below:
	\begin{lstlisting}[language={}]
	p1 in %rdi, p2 in %rsi, action in %edx
.L8:							MODE_E
	movl	$27,		%eax
	ret
.L3:							MODE_A
	movq	(%rsi),		%rax
	movq	(%rdi),		%rdx
	movq	%rdx,		(%rsi)
	ret
.L5:							MODE_B
	movq	(%rdi),		%rax
	addq	(%rsi),		%rax
	movq	%rax,		(%rdi)
	ret
.L6:							MODE_C
	movq	$59,		(%rdi)
	movq	(%rsi),		%rax
	ret
.L7:							MODE_D
	movq	(%rsi),		%rax
	movq	%rax,		(%rdi)
	movl	$27,		%eax
	ret
.L9:							default
	movl	$12,		%eax
	ret
	\end{lstlisting}
	The annotations indicated the argument locations, the register values, and the case labels
	for the different jump destinations. Fill in the missing parts of the C code. It contained
	one case that fell through to another --- try to reconstruct this.
\end{ex}

\begin{sol}
	\
	The annotated assembly is below:
		\begin{lstlisting}[language={}]
	p1 in %rdi, p2 in %rsi, action in %edx
.L8:							MODE_E
	movl	$27,		%eax	// result = 27
	ret
.L3:							MODE_A
	movq	(%rsi),		%rax	// result = *p2;
	movq	(%rdi),		%rdx	// long t = *p1;
	movq	%rdx,		(%rsi)	// *p2 = t;
	ret
.L5:							MODE_B
	movq	(%rdi),		%rax	// result = *p1;
	addq	(%rsi),		%rax	// result = result + *p2;
	movq	%rax,		(%rdi)	// *p2 = result;
	ret
.L6:							MODE_C
	movq	$59,		(%rdi)	// *p1 = 59;
	movq	(%rsi),		%rax	// result = *p2;
	ret
.L7:							MODE_D
	movq	(%rsi),		%rax	// result = *p2;
	movq	%rax,		(%rdi)	// *p1 = result;
	movl	$27,		%eax	// result = 27
	ret
.L9:							default
	movl	$12,		%eax	// result = 12
	ret
		\end{lstlisting}
		The corresponding C code is below. The fall-through happens in \texttt{case MODE\_D},
		which falls through to \texttt{case MODE\_E}:
		\begin{lstlisting}
/* Enumerated type creates a set of constants numbered 0 and upward */
typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t;

long switch3(long *p1, long *p2, mode_t action)
{
	long result = 0;
	switch(action) {
		case MODE_A:
			result = *p2;
			*p2 = *p1;
			break;
		case MODE_B:
			result = *p1 + *p2;
			*p2 = result;
			break;
		case MODE_C:
			*p1 = 59;
			result = *p2;
			break;
		case MODE_D:
			*p1 = *p2;
		case MODE_E:
			result = 27;
			break;
		default:
			result = 12;
			break;
		
	}
	return result;
}
		\end{lstlisting}
\end{sol}

\begin{ex}{3.63}
	This problem will give you a chance to reverse engineer a \texttt{switch} statement from
	disassembled machine code. In the following procedure, the body of the \texttt{switch} statement
	has been omitted:
	\begin{lstlisting}
long switch_prob(long x, long n) {
	long result = x;
	switch(n) {
			/* Fill in code here */
			
	}
	return result;
}
	\end{lstlisting}
	The disassembled machine code for the procedure follows:
	\begin{lstlisting}[language={}]
	long switch_prob(long x, long n)
	x in %rdi, n in %rsi
0000000000400590 <switch_prob>:
	400590:	48 83 ee 3c					sub		$0x3c,%rsi
	400594: 48 83 fe 05					cmp		$0x5,%rsi
	400598: 77 29						ja		4005c3 <switch_prob+0x33>
	40059a: ff 24 f5 f8 06 40 00		jmpq	*0x4006f8(,%rsi,8)
	4005a1: 48 8d 04 fd 00 00 00		lea		0x0(,%rdi,8),%rax
	4005a8: 00
	4005a9: c3							retq
	4005aa: 48 89 f8					mov		%rdi,%rax
	4005ad: 48 c1 f8 03					sar		$0x3,%rax
	4005b1: c3							retq
	4005b2: 48 89 f8					mov		%rdi,%rax
	4005b5: 48 c1 e0 04					shl		$0x4,%rax
	4005b9: 48 29 f8					sub		%rdi,%rax
	4005bc: 48 89 c7					mov		%rax,%rdi
	4005bf: 48 0f af ff					imul	%rdi,%rdi
	4005c3: 48 8d 47 4b					lea		0x4b(%rdi),%rax
	4005c7: c3							retq
	\end{lstlisting}
	The jump table resides in a different area of memory. We can see from the indirect
	jump on line 5 that the jump table begins at address \texttt{0x4006f8}. Using the
	\texttt{gdb} debugger, we can examine the six 8-byte words of memory comprising
	the jump table with the command \texttt{x/6gx 0x4006f8}. \texttt{gdb} prints
	the following:
	\begin{lstlisting}[language={}]
(gdb) x/6gx 0x4006f8
0x4006f8:	0x00000000004005a1	0x00000000004005c3
0x400708:	0x00000000004005a1	0x00000000004005aa
0x400718:	0x00000000004005b2	0x00000000004005bf
	\end{lstlisting}
	Fill in the body of the \texttt{switch} statement with C code that will have the
	same behavior as the machine code.
\end{ex}

\begin{sol}
	\
	The annotated assembly is below:
	\begin{lstlisting}[language={}]
	long switch_prob(long x, long n)
	x in %rdi, n in %rsi
0000000000400590 <switch_prob>:
	400590:	48 83 ee 3c					sub		$0x3c,%rsi					// n = n - 60;
	400594: 48 83 fe 05					cmp		$0x5,%rsi					// compare n:5
	400598: 77 29						ja		4005c3 <switch_prob+0x33>	// if > goto  400590 + 0x33 (4005c3)
	40059a: ff 24 f5 f8 06 40 00		jmpq	*0x4006f8(,%rsi,8)			// goto 0x4005a1 + 8*n;
	4005a1: 48 8d 04 fd 00 00 00		lea		0x0(,%rdi,8),%rax			// result = 8 * x;
	4005a8: 00
	4005a9: c3							retq								// return;
	4005aa: 48 89 f8					mov		%rdi,%rax					// result = x;
	4005ad: 48 c1 f8 03					sar		$0x3,%rax					// result >>= 3;
	4005b1: c3							retq								// return;
	4005b2: 48 89 f8					mov		%rdi,%rax					// result = x;
	4005b5: 48 c1 e0 04					shl		$0x4,%rax					// result <<= 4;
	4005b9: 48 29 f8					sub		%rdi,%rax					// result = result - x;
	4005bc: 48 89 c7					mov		%rax,%rdi					// x = result;
	4005bf: 48 0f af ff					imul	%rdi,%rdi					// x *= x;
	4005c3: 48 8d 47 4b					lea		0x4b(%rdi),%rax				// default: result = x + 75;
	4005c7: c3							retq								// return;
	\end{lstlisting}
	The corresponding C code follows. Notice the fall-through for \texttt{case 64} through to the
	\texttt{default} case, the multi-case for \texttt{60} and \texttt{62}, and the fact that
	there is no case matching \texttt{61}.
	\begin{lstlisting}
long switch_prob(long x, long n) {
	long result = x;
	switch(n) {
		case 60:
		case 62:
			result = 8 * x;
			break;
		case 63:
			result = result >> 3;
			break;
		case 64:
			result = (x << 4) - x;
			x = result;
			x *= x;
		default:
			result = x + 75;
			break;
	}
	return result;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{3.64}
	Consider the following source code, where $R$, $S$, and $T$ are constants declared with
	\texttt{\#define}:
	\begin{lstlisting}
long A[R][S][T];

long store_ele(long i, long j, long k, long *dest)
{
	*dest = A[i][j][k];
	return sizeof(A);
}
	\end{lstlisting}
	In compiling this program, \texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
	long store_ele(long i, long j, long k, long *dest)
	i in %rdi, j in %rsi, k in %rdx, dest in %rcx
store_ele:
	leaq	(%rsi, %rsi,2),		%rax
	leaq	(%rsi,%rax,4),		%rax
	movq	%rdi,				%rsi
	salq	$6,					%rsi
	addq	%rsi,				%rdi
	addq	%rax,				%rdi
	addq	%rdi,				%rdx
	movq	A(,%rdx,8),			%rax
	movq	%rax,				(%rcx)
	movl	$3640,				%eax
	ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item Extend Equation 3.1 from two dimensions to three to provide a formula for
		the location of array element \texttt{A[i][j][k]}.
		\item Use your reverse engineering skills to determine the values of $R$, $S$,
		and $T$ based on the assembly code.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Equation 3.1 says that if \texttt{T} is a C type, possibly defined by a
		\texttt{typedef}, then the array
		\begin{center}
			\texttt{T D[R][C];}
		\end{center}
		has elements \texttt{D[i][j]} at memory address
		\begin{center}
			\texttt{\&D[i][j]} = $x_D+L(C\cdot i + j)$
		\end{center}
		where $R$ is the number of rows, $C$ is the nubmer of columns, $x_D$ is the base
		address of $D$ (where the first element is), $L$ is the size of data type $T$
		in bytes, and $C$ is the number of columns. The extension for \texttt{A[R][S][T]} is as follows:
		\begin{center}
			\texttt{\&A[i][j][k]} = $x_A+L(T(S\cdot i + j) + k)$
		\end{center}
		where $x_A$ is the based address of $A$, $L$ is the data type of the elements in $A$,
		$T$ is the size specified in the last dimension, and $S$ is the size specified in the
		second dimension.
		\item Below I have annotated the assembly:
		\begin{lstlisting}[language={}]
	long store_ele(long i, long j, long k, long *dest)
	i in %rdi, j in %rsi, k in %rdx, dest in %rcx
store_ele:
	leaq	(%rsi, %rsi,2),		%rax	// result = j + 2j;			// 3j
	leaq	(%rsi,%rax,4),		%rax	// result = j + 4 * result;	// 13j;
	movq	%rdi,				%rsi	// long t = i;
	salq	$6,					%rsi	// t <<= 6;				// i * 64
	addq	%rsi,				%rdi	// i += t;				// i + 64i
	addq	%rax,				%rdi	// i += result;			// 65i + 13j
	addq	%rdi,				%rdx	// k += i;				// 65i + 13j + k
	movq	A(,%rdx,8),			%rax	// result = A[8*k];		// A[8*(65i+13j+k)]
	movq	%rax,				(%rcx)	// *dest = result
	movl	$3640,				%eax	// result = 3640;
	ret									// return
		\end{lstlisting}
		We can also see that
		the index of \texttt{A} is $8\cdot (65i+13j+k)=8\cdot (13\cdot (5\cdot i+j)+k))$. The
		$8$ is the size of \texttt{long}, $13$ is the value of $T$, and $5$ is the size
		of $S$. Since the value of the product is \texttt{3640}, this suggests that $R=(13\cdot 5)=56$.
	\end{enumerate}
\end{sol}

\begin{ex}{3.65}
	The following code transposes the elements of an $M\times M$ array, where $M$ is a constant
	defined by \texttt{\#define}:
	\begin{lstlisting}
void transpose(long A[M][M]) {
	long i, long j;
	for (i = 0; i < M; i++)
		for (j = 0; j < i; j++) {
			long t = A[i][j];
			A[i][j] = A[j][i];
			A[j][i] = t;
		}
}
	\end{lstlisting}
	When compiled with optimization level \texttt{-O1}, \texttt{gcc} generates the following
	for the inner loop of the function:
	\begin{lstlisting}[language={}]
.L6:
	movq	(%rdx),		%rcx
	movq	(%rax),		%rsi
	movq	%rsi,		(%rdx)
	movq	%rcx,		(%rax)
	addq	$8,			%rdx
	addq	$120,		%rax
	cmpq	%rdi,		%rax
	jne		.L6
	\end{lstlisting}
	We can see that \texttt{gcc} has converted the array indexing to pointer code.
	\begin{enumerate}[label=(\alph*)]
		\item Which register holds a pointer to array element \texttt{A[i][j]}?
		\item Which register holds a pointer to array element \texttt{A[j][i]}?
		\item What is the value of $M$?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item In the inner loop, $j$ increases while $i$ is fixed. Recall that the memory address
		of \texttt{A[i][j]} is given by
		\begin{center}
			\texttt{\&A[i][j]} = $x_A+8(M\cdot i+j)$
		\end{center}
		where $x_A$ is the base address of $A$ and $M$ is the number of columns in $A$.
		Then when $j$ is replaced by $j+1$, the formula suggests an increased in the address by
		$8$. Therefore, we expect \texttt{A[i][j]} to be the one whose memory address increases
		by 8. The assembly is annotated accordingly below:
\begin{lstlisting}[language={}]
.L6:
	movq	(%rdx),		%rcx	// long a = *Aij;
	movq	(%rax),		%rsi	// long b = *Aji;
	movq	%rsi,		(%rdx)	// *Aij = b;
	movq	%rcx,		(%rax)	// *Aji = a;
	addq	$8,			%rdx	// Aij = Aij + 8
	addq	$120,		%rax	// Aji = Aji + 120;
	cmpq	%rdi,		%rax	// compare Aji:A
	jne		.L6					// if != goto .L6
\end{lstlisting}
		From this we can conclude that \texttt{A[i][j]} is held in register \texttt{\%rdx}.
		\item A similar argument implies that when $i$ is increased to $i+1$, then
		the address of \texttt{A[i][j]} increases by $8M$. Keeping in mind that $i$
		is fixed and that $j$ is increasing, this suggests that \texttt{A[j][i]} corresponds
		to the register whose value is increasing by $8M$. In the assembly code above, this
		is register \texttt{\%rax}, increasing by 120.
		\item Since $8M=120$ see that $M=15$.
	\end{enumerate}
\end{sol}

\begin{ex}{3.66}
	Consider the following source code, where \texttt{NR} and \texttt{NC} are macro expressions
	declared with \texttt{\#define} that compute the dimensions of array \texttt{A} in terms of
	parameter $n$. This code computes the sum of the elements of column $j$ of the array.
	\begin{lstlisting}
long sum_col(long n, long A[NR(n)][NC(n)], long j) {
	long i;
	long result = 0;
	for (i = 0; i < NR(n); i++)
		result += A[i][j];
	return result;
}
	\end{lstlisting}
	In compiling this program, \texttt{gcc} generates the following assembly code:
	\begin{lstlisting}[language={}]
	long sum_col(long n, long A[NR(n)][NC(n)], long j)
	n in %rdi, A in %rsi, j in %rdx
sum_col:
	leaq	1(,%rdi,4),		%r8
	leaq	(%rdi,%rdi,2),	%rax
	movq	%rax,			%rdi
	testq	%rax,			%rax
	jle		.L4
	salq	$3,				%r8
	leaq	(%rsi,%rdx,8),	%rcx
	movl	$0,				%eax
	movl	$0,				%edx
.L3:
	addq	(%rcx),			%rax
	addq	$1,				%rdx
	addq	%r8,			%rcx
	cmpq	%rdi,			%rdx
	jne		.L3
	rep; ret
.L4:
	movl	$0,				%eax
	ret
	\end{lstlisting}
	Use your reverse engineering skills to determine the definitions of \texttt{NR} and
	\texttt{NC}.
\end{ex}

\begin{sol}
	\
	I have annotated the assembly below:
	\begin{lstlisting}[language={}]
	long sum_col(long n, long A[NR(n)][NC(n)], long j)
	n in %rdi, A in %rsi, j in %rdx
sum_col:
	leaq	1(,%rdi,4),		%r8		// long t = 1 + 4n;
	leaq	(%rdi,%rdi,2),	%rax	// long result = n + 2n;	// 3n
	movq	%rax,			%rdi	// n = result;	// 3n
	testq	%rax,			%rax	// test result
	jle		.L4						// if <=
	salq	$3,				%r8		// t <<= 3; // multiply by 8
	leaq	(%rsi,%rdx,8),	%rcx	// long q = A + 8*j;	// First in col j
	movl	$0,				%eax	// result = 0;
	movl	$0,				%edx	// j = 0;
.L3:
	addq	(%rcx),			%rax	// result += *q;
	addq	$1,				%rdx	// j++;	// used in comparison
	addq	%r8,			%rcx	// q += t;
	cmpq	%rdi,			%rdx	// compare j:n
	jne		.L3						// if != go to .L3
	rep; ret						// return;
.L4:
	movl	$0,				%eax	// result = 0;
	ret								// return;
	\end{lstlisting}
	We can see that \texttt{NR(n)} is $3n$, and \texttt{NC(n)} is $1+4n$.
\end{sol}

\begin{ex}{3.67}
	For this exercise, we will examine the code generated by \texttt{gcc} for functions that have
	structures as arguments and return values, and from this see how these language features are
	typically implemented.
	
	\
	The following C code has a function \texttt{process} having structures as argument and return
	values, and a function \texttt{eval} that calls \texttt{process}:
	\begin{lstlisting}
typedef struct {
	long a[2];
	long *p;
} strA;

typedef struct {
	long u[2];
	long q;
} strB;

strB process(strA s) {
	strB r;
	r.u[0] = s.a[1];
	r.u[1] = s.a[0];
	r.q = *s.p;
	return r;
}

long eval(long x, long y, long z) {
	strA s;
	s.a[0] = x;
	s.a[1] = y;
	s.p = &z;
	strB r = process(s);
	return r.u[0] + r.u[1] + r.q;
}
	\end{lstlisting}
	\begin{lstlisting}[language={}]
	strB process(strA s)
process:
	movq	%rdi,		%rax
	movq	24(%rsp),	%rdx
	movq	(%rdx),		%rdx
	movq	16(%rsp),	%rcx
	movq	%rcx,		(%rdi)
	movq	8(%rsp),	%rcx
	movq	%rcx,		8(%rdi)
	movq	%rdx,		16(%rdi)
	ret
	
	long eval(long x, long y, long z)
	x in %rdi, y in %rsi, z in %rdx
eval:
	subq	$104,		%rsp
	movq	%rdx,		24(%rsp)
	leaq	24(%rsp),	%rax
	movq	%rdi,		(%rsp)
	movq	%rsi,		8(%rsp)
	movq	%rax,		16(%rsp)
	leaq	64(%rsp),	%rdi
	call	process
	movq	72(%rsp),	%rax
	addq	64(%rsp),	%rax
	addq	80(%rsp),	%rax
	addq	$104,		%rsp
	ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item We can see on line 2 on function \texttt{eval} that it allocates 104 bytes on
		the stack. Diagram the stack frame for \texttt{eval}, showing the values that it stores
		on the stack prior to calling \texttt{process}.
		\item What value does \texttt{eval} pass in its call to \texttt{process}?
		\item How does the code for \texttt{process} access the elements of structure argument
		\texttt{s}?
		\item How does the code for \texttt{process} set the fields of result structure \texttt{r}?
		\item Complete your diagram of the stack frame for \texttt{eval}, showing how \texttt{eval}
		accesses the elements of structure \texttt{r}  following the return from \texttt{process}.
		\item What general principles can you discern about how structure values are passed as
		function arguments and how they are returned as function results?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	The annotated assembly is below:
	\begin{lstlisting}[language={}]

eval:
	subq	$104,		%rsp
	movq	%rdx,		24(%rsp)
	leaq	24(%rsp),	%rax
	movq	%rdi,		(%rsp)
	movq	%rsi,		8(%rsp)
	movq	%rax,		16(%rsp)
	leaq	64(%rsp),	%rdi
	call	process
	movq	72(%rsp),	%rax
	addq	64(%rsp),	%rax
	addq	80(%rsp),	%rax
	addq	$104,		%rsp
	ret
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item The annotated stack is below:
		\begin{lstlisting}[language={}]
	strB process(strA s)
process:
	movq	%rdi,		%rax			// return address received
	movq	24(%rsp),	%rdx			// long *p = s.p;
	movq	(%rdx),		%rdx			// long z = *p;
	
	movq	16(%rsp),	%rcx			// long a1 = s.a[1];
	movq	%rcx,		(%rdi)			// r.u[0] = a1;
	movq	8(%rsp),	%rcx			// long a0 = s.a[0];
	movq	%rcx,		8(%rdi)			// r.u[1] = a0;
	movq	%rdx,		16(%rdi)		// r.q = z;
	ret

long eval(long x, long y, long z)
x in %rdi, y in %rsi, z in %rdx
	long eval(long x, long y, long z)
	x in %rdi, y in %rsi, z in %rdx
eval:
	subq	$104,		%rsp		// Allocate 104 bytes on the stack
	movq	%rdx,		24(%rsp)	// Store z on the stack at 24 byte offset
	leaq	24(%rsp),	%rax		// Compute &z;
	movq	%rdi,		(%rsp)		// s.a[0] = x;
	movq	%rsi,		8(%rsp)		// s.a[1] = y;
	movq	%rax,		16(%rsp)	// s.p = &z;
	leaq	64(%rsp),	%rdi		// Pass address (64 byte stack offset) of r as argument
	call	process					// Call process
	movq	72(%rsp),	%rax		// long result = r.u[1]
	addq	64(%rsp),	%rax		// add r.u[0] to result
	addq	80(%rsp),	%rax		// add r.q to result
	addq	$104,		%rsp		// Deallocate stack memory
	ret
		\end{lstlisting}
		The stack frame looks as such:
		\begin{center}
			\begin{tabular}{cc}
				Contents & Stack Offset\\
				\hline
				Return address & 104\\
				\texttt{z} & 24\\
				\texttt{\&z} & 16\\
				\texttt{y} & 8\\
				\texttt{x} & 0\\
			\end{tabular}
		\end{center}
		\item The instruction \texttt{leaq	64(\%rsp),	\%rdi} assigns the first argument.
		This means \texttt{eval} passes the address of a 64 byte offset of the stack pointer.
		This is the address of \texttt{structB r}, the structure we wish to fill up with values.
		\item The \texttt{process} function accesses the elements of \texttt{s} through the stack.
		\item The code for \texttt{process} uses addressed received as an argument in register
		\texttt{\%rdi} to set the fields of \texttt{r}. For example, \texttt{r.u[0]} is at the
		address stored in register \texttt{\%rdi}.
		\item The updated diagram looks as follows:
		\begin{center}
			\begin{tabular}{cc}
				Contents & Stack Offset\\
				\hline
				Return address & 104\\
				\texttt{r.p} & 80\\
				\texttt{r.u[1]} & 72\\
				\texttt{r.u[0]} & 64\\
				\texttt{z} & 24\\
				\texttt{\&z} & 16\\
				\texttt{y} & 8\\
				\texttt{x} & 0\\
			\end{tabular}
		\end{center}
		\item When structure values are passed as arguments to a function, they are passed
		on the stack instead of the conventional argument registers. For example, \texttt{eval}
		places \texttt{s} at the top of the stack. When it calls \texttt{process} and its return
		address is pushed onto the stack, the \texttt{process} function now accesses its
		value at an 8 byte stack offset. Now consider how structure values are returned.
		It uses the address received in an argument register to store values, and then it
		returns this same address. In this case, \texttt{process} received
		the address where it should store the structure values in register \texttt{\%rdi},
		and it immediately places this value in \texttt{\%rax}.
	\end{enumerate}
\end{sol}

\begin{ex}{3.68}
	In the following code, $A$ and $B$ are constants defined with \texttt{\#define}:
	\begin{lstlisting}
typedef struct {
	int x[A][B];	/* Unknown constants A and B */
	long y;
} str1;

typedef struct {
	char array[B];
	int t;
	short s[A];
	long u;
} str2;

void setVal(str1 *p, str2 *q) {
	long v1 = q->t;
	long v2 = q->u;
	p->y = v1 + v2;
}
	\end{lstlisting}
	\texttt{gcc} generates the following code for \texttt{setVal}:
	\begin{lstlisting}[language={}]
	void setVal(str1 *p, str2 *q)
	p in %rdi, q in %rsi
setVal:
	movslq	8(%rsi),	%rax
	addq	32(%rsi),	%rax
	movq	%rax,		184(%rdi)
	ret
	\end{lstlisting}
	What are the values of $A$ and $B$ (The solution is unique.)
\end{ex}

\begin{sol}
	\
	I've annotated the assembly below:
	\begin{lstlisting}[language={}]
	void setVal(str1 *p, str2 *q)
	p in %rdi, q in %rsi
setVal:
	movslq	8(%rsi),	%rax		// long result = q->t;
	addq	32(%rsi),	%rax		// result += q->u;
	movq	%rax,		184(%rdi)	// p->y = result;
	ret
	\end{lstlisting}
	Since \texttt{struct str1} requires an 8-byte alignment for the
	\texttt{long y} member, and an \texttt{int} takes up 4 bytes,
	we may need 4 bytes of padding.  The last instruction indicates
	that $4AB=184$, suggesting that $AB=46$ or $AB=45$.
	
	Note that \texttt{B} must be a multiple of 4 to satisfy the
	4-byte alignment implied by \texttt{int t}. Since the first
	instruction accesses \texttt{q->t} at an 8 byte offset, it
	must be that $5\leq B\leq8$. Since none of these values are factors
	of $46$, it must be that $AB=45$. The only factor in range is
	$B=5$. Hence, $A=9$. To make sure this is consistent, note
	that $A$ must satisfy $8+4+2A+m=32$, where $m$ is some possible
	padding to ensure 8-byte alignment is satisfied for \texttt{struct str2}.
	Hence $8+4+2A$ must be between $26$ and $32$ to achieve the necessary
	8-byte alignment. The value $A=9$ falls right in, causing a padding
	of $m=2$ to be needed.
\end{sol}

\begin{ex}{3.69}
	You are charged with maintaining a large C program, and you come across
	the following code:
	\begin{lstlisting}
typedef struct {
	int first;
	a_struct a[CNT];
	int last;
} b_struct;

void test(long i, b_struct *bp)
{
	int n = bp->first + bp->last;
	a_struct *ap = &bp->a[i];
	ap->x[ap->idx] = n;
}
	\end{lstlisting}
	The declarations of the compile-time constant \texttt{CNT} and the
	structure \texttt{a\_struct} are in a file for which you do not have
	the necessary access privilege. Fortunately, you have a copy of the
	\texttt{.o} version of code, which you are able to disassemble with
	the \texttt{objdump} program, yielding the following disassembly:
	\begin{lstlisting}[language={}]
	void test(long i, b_struct *bp)
	i in %rdi, bp in %rsi
0000000000000000 <test>:
	0:	8b 8e 20 01 00 00	mov		0x120(%rsi),%ecx
	6:	03 0e				add		(%rsi),%ecx
	8:	48 8d 04 bf			lea		(%rdi,%rdi,4),%rax
	c:	48 8d 04 c6			lea		(%rsi,%rax,8),%rax
	10:	48 8b 50 08			mov		0x8(%rax),%rdx
	14:	48 63 c9			movslq	%ecx,%rcx
	17:	48 89 4c d0 10		mov		%rcx,0x10(%rax,%rdx,8)
	1c:	c3					retq
	\end{lstlisting}
	Use your reverse engineering skills to deduce the following:
	\begin{enumerate}[label=(\alph*)]
		\item The value of \texttt{CNT}.
		\item A complete declaration of structure \texttt{a\_struct}. Assume
		that the only fields in this structure are \texttt{idx} and \texttt{x},
		and that both of these contain signed values.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item I have annotated the assembly:
		\begin{lstlisting}[language={}]
	void test(long i, b_struct *bp)
	i in %rdi, bp in %rsi
0000000000000000 <test>:
	0:	8b 8e 20 01 00 00	mov		0x120(%rsi),%ecx	// int n = bp->last
	6:	03 0e				add		(%rsi),%ecx			// n += bp->first
	8:	48 8d 04 bf			lea		(%rdi,%rdi,4),%rax	// i + 4i = 5i
	c:	48 8d 04 c6			lea		(%rsi,%rax,8),%rax	// bp + 8*5i
	10:	48 8b 50 08			mov		0x8(%rax),%rdx	// long t = M[8+bp+40i]
	14:	48 63 c9			movslq	%ecx,%rcx			// Extend n to 64 bit
	17:	48 89 4c d0 10		mov		%rcx,0x10(%rax,%rdx,8) // M[16+bp+40i+8t]=n
	1c:	c3					retq
		\end{lstlisting}
		Note that \texttt{0x120} is $288$ in decimal, and it corresponds
		to the offset of \texttt{int last} in \texttt{struct b\_struct}.
		Line \texttt{0x10} computes \texttt{8+bp+40i}. This suggests that the
		size of each \texttt{a\_struct} is 40 bytes. Since the instruction loads a value from memory and not an address, this must be the value \texttt{ap->idx}. This suggests \texttt{idx} is the first member of \texttt{a\_struct}.
		The 8 byte offset includes the first 4 bytes to skip \texttt{int first}, and a 4 byte padding. Hence, \texttt{a[CNT]} begins at an offset of 8
		and ends at an offset of 288, so it takes up 280 bytes, making
		\texttt{CNT} 7.
		
		
		\item  On line \texttt{0x17}, the \texttt{16+bp+40i+8t} includes the
		4 byte padding, the 4 byte padding, and the \texttt{idx}, which must be
		an 8 byte \texttt{long} since it is used as an index. Finally, the $8t$ suggests an 8 byte alignment of \texttt{x}. Since \texttt{a\_struct} takes up
		40 bytes, the remaining 32 bytes come from \texttt{x}. Since it
		stores \texttt{n}, a type \texttt{long}, the elements must also be
		of type \texttt{long}. Hence \texttt{a\_struct} is as follows:
		\begin{lstlisting}
struct {
	long idx;
	long x[4];
} a_struct;
		\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{3.70}
	Consider the following union declaration:
	\begin{lstlisting}
union ele {
	struct {
		long *p;
		long y;
	} e1;
	struct {
		long x;
		union ele *next;
	} e2;
};
	\end{lstlisting}
	This declaration illustrates that structures can be embedded within
	unions. The following function (with some expressions omitted) operates
	on a linked list having these unions as list elements:
	\begin{lstlisting}
void proc (union ele *up) {
	up->_________ = *(___________) - ____________;
}
	\end{lstlisting}
	\begin{enumerate}[label=(\alph*)]
		\item What are the offsets (in bytes) of the following fields:
		\begin{center}
			\begin{tabular}{cc}
				\texttt{e1.p} & \makebox[2cm]{\hrulefill}\\
				\texttt{e1.y} & \makebox[2cm]{\hrulefill}\\
				\texttt{e2.x} & \makebox[2cm]{\hrulefill}\\
				\texttt{e2.next} & \makebox[2cm]{\hrulefill}
			\end{tabular}
		\end{center}
		\item How many total bytes does the structure require?
		\item The compiler generates the following assembly code for
		\texttt{proc}:
		\begin{lstlisting}[language={}]
	void proc (union ele *up)
	up in %rdi
proc:
	movq	8(%rdi), %rax
	movq	(%rax), %rdx
	movq	(%rdx), %rdx
	subq	8(%rax), %rdx
	movq	%rdx, (%rdi)
	ret
		\end{lstlisting}
		On the basis of this information, fill in the missing expressions in
		the code for \texttt{proc}. \emph{Hint}: Some union references can
		have ambiguous interpretations. These ambiguities get resolved as you
		see where the references lead. There is only one answer that does not
		perform any casting and does not violate any type constraints.
	\end{enumerate}
\end{ex}

\begin{sol}
	\begin{enumerate}[label=(\alph*)]
		\item The offsets are given as follows:
		\begin{center}
			\begin{tabular}{cc}
				\texttt{e1.p} & 0\\
				\texttt{e1.y} & 8\\
				\texttt{e2.x} & 0\\
				\texttt{e2.next} & 8
			\end{tabular}
		\end{center}
		\item Since pointers take up 8 bytes, the union takes up
		16 bytes.
		\item The annotated assembly follows:
		\begin{lstlisting}[language={}]
	void proc (union ele *up)
	up in %rdi
proc:
	movq	8(%rdi), %rax	// long *next = up->next;
	movq	(%rax), %rdx	// long *p = *next;
	movq	(%rdx), %rdx	// long r = *p;
	subq	8(%rax), %rdx	// r -= next->y;
	movq	%rdx, (%rdi)	// up->x= r;
	ret
		\end{lstlisting}
		This means the C code fills up to:
		\begin{lstlisting}
void proc (union ele *up) {
	up->x = *(up->next->p) - up->next->y;
}
		\end{lstlisting}
	\end{enumerate}
\end{sol}

\end{document}