%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Welcome to the MAT320 Homework template on Overleaf -- just edit your
% LaTeX on the left, and we'll compile it for you on the right.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --------------------------------------------------------------
% Based on a homework template by Dana Ernst.
% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------

\documentclass[12pt]{article}

\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{textcomp} % cent symbol, such as \textcent
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{cancel}
\usepackage{mathtools} % ceiling function
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
% https://tex.stackexchange.com/questions/146306/how-to-make-horizontal-lists
\usepackage[inline]{enumitem} % allows using letters in enumerate list environment

% source: https://stackoverflow.com/questions/3175105/inserting-code-in-this-latex-document-with-indentation

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=C, % language for code listing
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4
}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\newenvironment{ex}[2][Exercise]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\newenvironment{sol}[1][Solution]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1:}]}{\end{trivlist}}


\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\noindent Sergio Garcia Tapia \hfill

\noindent{\small Computer Systems: A Programmer's Perspective, by Bryant and O'Hallaron} \hfill

\noindent{\small Chapter 2: Representing and Manipulating Information} \hfill 

\noindent\today

\subsection*{Practice Problems}
\begin{ex}{2.1}
	Perform the following conversions:
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{0x39A7F8} to binary.
		\item binary $1100100101111011$ to hexadecimal.
		\item \texttt{0xD5E4C} to binary.
		\item binary $1001101110011110110101$ to hexadecimal.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Each hexadecimal digit corresponds to a 4-bit binary number:
		\begin{center}
			\begin{tabular}{c|cccccc}
				Hexadecimal & \texttt{3} & \texttt{9} & \texttt{A} & \texttt{7} & \texttt{F} & \texttt{8}\\
				\hline
				Binary & 0011 & 1001 & 1010 & 0111 & 1111 & 1000
			\end{tabular}
		\end{center}
		When concatenated, we find that $\texttt{0x39A7F8}=0011 1001 1010 0111 1111 1000_2$.
		\item We group the number into 4-bit groups:
		\begin{center}
			\begin{tabular}{c|cccc}
				Binary      & 1100 & 1001 & 0111 & 1011\\
				\hline
				Hexadecimal & \texttt{C} &  \texttt{9} &  \texttt{7} &  \texttt{B}
			\end{tabular}
		\end{center}
		Hence, $1100 1001 0111 1011_2=\texttt{0xC97B}$.
		\item We tabulate the values:
		\begin{center}
			\begin{tabular}{c|ccccc}
				Hexadecimal & \texttt{D} & \texttt{5} & \texttt{E} & \texttt{4} & \texttt{C} \\
				\hline
				Binary & 1101 & 0101 & 1110 & 0100 & 1100
			\end{tabular}
		\end{center}
		Hence, $\texttt{0xD5E4C}=1101 0101 1110 0100 1100_2$.
		\item The table is below:
		\begin{center}
			\begin{tabular}{c|cccccc}
				10 0110 1110 0111 1011 0101
				Binary      & 10 & 0110 & 1110 & 0111 & 1011 & 0101\\
				\hline
				Hexadecimal & \texttt{2} & \texttt{6} & \texttt{E} & \texttt{7} & \texttt{B} & \texttt{5}
			\end{tabular}
		\end{center}
		Hence, $10 0110 1110 0111 1011 0101_2=\texttt{0x26E7B5}$.
	\end{enumerate}
\end{sol}

\begin{ex}{2.2}
	Fill in the blank entries in the following table, giving the decimal and
	hexadecimal representations of different powers of $2$:
	\begin{center}
		\begin{tabular}{ccc}
			$n$ & $2^n$ (decimal) & $2^n$ (hexadecimal)\\
			\hline
			9 & 512 & \texttt{0x200}\\
			19 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & 16,384 & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \texttt{0x1000}\\
			17 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & 32 & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \texttt{0x80}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	As per the text, we write $n=i+4j$, where $0\leq i\leq 3$. The
	$i$ determines the leading hex bit to be $2^i$ (that is, 1, 2, 4, or 8).
	The $j$ determines the number of hexadecimal 0s thereafter. Some
	of the $n$ values from the table are below:
	\begin{align*}
		19&=3+4\cdot 4\\
		14&=2+4\cdot 3\\
		12&=0+4\cdot 3\\
		17&=1+4\cdot 4\\
		5 &=1+4\cdot 1\\
		7 &=3+4\cdot 1.
	\end{align*}
	The filled-in table follows:
	\begin{center}
		\begin{tabular}{ccc}
			$n$ & $2^n$ (decimal) & $2^n$ (hexadecimal)\\
			\hline
			9 & 512 & \texttt{0x200}\\
			19 & \textbf{524,288} & \textbf{\texttt{0x80000}}\\
			14 & 16,384 & \texttt{0x4000}\\
			12 & 4096 & \texttt{0x1000}\\
			17 & 131,072 & \texttt{0x20000}\\
			5 & 32 & \texttt{0x20}\\
			7 & 128 & \texttt{0x80}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.3}
	A single byte can be represented by 2 hexadecimal digits. Fill in the missing
	entries in the following table, giving the decimal, binary, and hexadecimal
	values of different byte patterns.
	\begin{center}
		\begin{tabular}{ccc}
			Decimal & Binary & Hexadecimal\\
			\hline
			0 & 0000 000 & \texttt{0x00}\\
			167 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			62 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			188 & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & 0011 0111 & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & 1000 1000 & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & 1111 0011 & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \texttt{0x52}\\
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \texttt{0xAC}\\
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \texttt{0xE7}		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	We proceed by repeatedly performing the division algorithm, taking each remainder:
	\begin{align*}
		167 &= 16\cdot 10 + 7\\
		10 &= 16 \cdot 0 +10
	\end{align*}
	Since $10_{16}=\texttt{0xA}$, we have $167_{10}=\texttt{0xA7}$. We proceed
	the same way:
	\begin{align*}
		62 &= 16 \cdot 3 + 14\\
		3 &= 16 \cdot 0 + 3
	\end{align*}
	So $62_{10}=\texttt{0x3E}$.
	\begin{align*}
		188&=16\cdot 11 + 12\\
		12 &=16\cdot 0 + 12
	\end{align*}
	So $188_{16}=\texttt{0xCC}$. By representing each hexadecimal digit with
	4 bits and concatenating them, we get the binary representation. To convert
	from hexadecimal to decimal, we multiply by the appropriate power of 16:
	\begin{align*}
		\texttt{0x37}&=3\cdot 16^1+7\cdot 16^0=55_{10}\\
		\texttt{0x88}&=7\cdot 16^1+8\cdot 16^0=136_{10}\\
		\texttt{0xF3}&=15\cdot16^1+3\cdot 16^0=243_{10}\\
		\texttt{0x52}&=5\cdot 16^1+2\cdot 16^0=82_{10}\\
		\texttt{0xAC}&=10\cdot16^1+12\cdot 16^0=172_{10}\\
		\texttt{0xE7}&=14\cdot16^1+7\cdot 16^0=231_{10}
	\end{align*}
	
	The complete table is below:
	\begin{center}
		\begin{tabular}{ccc}
			Decimal & Binary & Hexadecimal\\
			\hline
			0 & 0000 000 & \texttt{0x00}\\
			167 & 1010 0111& \texttt{0xA7}\\
			62 & 0011 1110 & \texttt{0x3E}\\
			188 & 1100 1100 & \texttt{0xCC}\\
			55 & 0011 0111 & \texttt{0x37}\\
			136 & 1000 1000 & \texttt{0x88}\\
			243 & 1111 0011 & \texttt{0xF3}\\
			82 & 0101 0010 & \texttt{0x52}\\
			172 & 1010 1100 & \texttt{0xAC}\\
			231 & 1110 0111 & \texttt{0xE7}	
		\end{tabular}
	\end{center}
\end{sol}


\begin{ex}{2.4}
	Without converting the numbers to decimal or binary, try to solve the following
	arithmetic problems, giving the answers in hexadecimal. \emph{Hint}: Just
	modify the methods you use for performing decimal addition and subtraction
	to use base 16.
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{0x503c} + \texttt{0x8} = \makebox[1cm]{\hrulefill}
		\item \texttt{0x503c} - \texttt{0x40} = \makebox[1cm]{\hrulefill}
		\item \texttt{0x503c} + 64 = \makebox[1cm]{\hrulefill} 
		\item \texttt{0x50ea} - \texttt{0x503c} = \makebox[1cm]{\hrulefill} 
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item 
		\
		\begin{center}
			\begin{tabular}{ccccc}
				{} & {}&{} & 1 & {}\\
				0x & 5 & 0 & 3 & c\\
				0x & {}& {}& 0 & 8\\
				+ & {} & {} & {} & {} \\
				\hline
				0x & 5 & 0 & 4 & 4
			\end{tabular}
		\end{center}
		\item
		\
		\begin{center}
			\begin{tabular}{ccccc}
				{} & 4 & F & {F3} & {}\\
				0x & $\cancel{5}$ & $\cancel{0}$ & $\cancel{3}$ & c\\
				0x & {}& {}& 4 & 0\\
				- & {} & {} & {} & {} \\
				\hline
				0x & 4 & F & F & C
			\end{tabular}
		\end{center}
		\item Note that $64_{10}=\texttt{0x40}$:
		\begin{center}
			\begin{tabular}{ccccc}
				0x & 5 & 0 & 3 & c\\
				0x & {}& {}& 4 & 0\\
				+ & {} & {} & {} & {} \\
				\hline
				0x & 5 & 0 & 7 & c
			\end{tabular}
		\end{center}
		\item
		\
		\begin{center}
			\begin{tabular}{ccccc}
				{} & {}&{} & D & FA\\
				0x & 5 & 0 & $\cancel{e}$ & $\cancel{a}$\\
				0x & 5 & 0 & 3 & c\\
				- & {} & {} & {} & {} \\
				\hline
				0x & 0 & 0 & A & E
			\end{tabular}
		\end{center}
	\end{enumerate}

\end{sol}

\begin{ex}{2.5}
	Consider the following three calls to \texttt{show\_bytes}:
\begin{lstlisting}
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;
show_bytes(valp, 1);  /* A. */
show_bytes(valp, 2);  /* B. */
show_bytes(valp, 3);  /* C. */
\end{lstlisting}
	Indicate the values that will be printed by each call on a little-endian
	machine and on a big-endian machine.
\end{ex}

\begin{sol}
	Recall \texttt{show\_bytes} function accepts an \texttt{unsigned char*} and
	the size of the data type, which it uses to know how many bytes to read.
	For example, we might pass \texttt{sizeof(int32\_t)}, which would pass
	4 because an \texttt{int32\_t} takes up 32 bits, or 4 bytes. With
	that out of the way:
	\begin{enumerate}[label=(\alph*)]
		\item The call with 1 means to take 1 byte, which on a little-endian will be
		the least significant byte and on big-endian machine will be the most
		significant byte. A byte is 8 bits, or two hexadecimal numbers. Hence,
		the most least significant byte is \texttt{21}, and the most significant is
		\texttt{87}.
		\item On little-endian, it would be \texttt{21} \texttt{43}, and on
		big-endian, it would be \texttt{87} \texttt{65}.
		\item On a little-endian it's \texttt{21} \texttt{43} \texttt{65}, and
		on big-endian it's \texttt{87} \texttt{65} \texttt{43}.
	\end{enumerate}
\end{sol}

\begin{ex}{2.6}
	Using \texttt{show\_int} and \texttt{show\_float}, we determine that the integer
	3510593 has hexadecimal representation \texttt{0x00359141}, while the
	floating-point number 3510593.0 has hexadecimal representation \texttt{0x4A564504}.
	\begin{enumerate}[label=(\alph*)]
		\item Write the binary representations of these two hexadecimal values.
		\item Shift these two strings relative to one another to maximize the number of
		matching bits. How many bits match?
		\item What parts of the strings do not match?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}
		\item \
		\begin{center}
			\begin{tabular}{c|c}
				Hexadecimal & Binary\\
				\hline
				\texttt{0x00359141} &  0000 0000 0011 0011 0101 0001 0100 0001\\
				\texttt{0x4A564504} & 0100 1010 0101 0110 0100 0101 0000 0100
			\end{tabular}
		\end{center}
		\item The shifted numbers are shown below, with the 21 matching bits shown in
		bold:
		\begin{align*}
					00000000001 &\textbf{101011001000101000001}\\
	        		  010010100 &\textbf{101011001000101000001}00
		\end{align*}
		\item The last two bits in the float do not match. Also, the leading bits
		in integer, $00000000001$, do not match the leading bits in the float:
		$010010100$.
	\end{enumerate}
\end{sol}

\begin{ex}{2.7}
	What would be printed as a result of the following call to \texttt{show\_bytes}?
	\begin{lstlisting}
const char *s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
	\end{lstlisting}
	Note that letters `\texttt{a}' through `\texttt{z}' have ASCII codes \texttt{0x61}
	through \texttt{0x7A}.
\end{ex}

\begin{sol}
	The output for the lowercase characters would be: \texttt{0x61 0x62 0x63 0x64 0x65 0x66 0x00}
	on any system using ASCII as its character code. The \texttt{0x00} is the null character
	used to terminate strings in C.
\end{sol}

\begin{ex}{2.8}
	Fill in the following table showing the results of evaluating Boolean operations on
	bit vectors.
	\begin{center}
		\begin{tabular}{cc}
			Operationg & Result\\
			\hline
			$a$ & [01101001]\\
			$b$ & [01010101]\\
			$\sim a$ & \makebox[1cm]{\hrulefill} \\
			$\sim b$ & \makebox[1cm]{\hrulefill} \\
			$a\, \& \,b$ & \makebox[1cm]{\hrulefill} \\
			$a \, | \, b$ & \makebox[1cm]{\hrulefill} \\
			$a ^\wedge b $ & \makebox[1cm]{\hrulefill} 
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	Treating the bit sequences as bit vectors and noting that $\sim$ is logical NOT,
	$\&$ is logical AND, $|$ is logical OR, and $^\wedge$ is logical XOR, we get:
	\begin{center}
		\begin{tabular}{cc}
			Operationg & Result\\
			\hline
			$a$ & [01101001]\\
			$b$ & [01010101]\\
			$\sim a$ & [10010110] \\
			$\sim b$ & [10101010] \\
			$a\, \& \,b$ & [01000001] \\
			$a \, | \, b$ & [01111101] \\
			$a ^\wedge b $ & [00111100]
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.9}
	Computers generate color pictures on a video screen or liquid crystal display by
	mixing three different colors of light: red, green, and blue. Imagine a simple
	scheme, with three different lights, each of which can be turned on or off,
	projecting onto a glass screen.
	\
	We can then create eight different colors based on the absence (0) or presence (1)
	of light sources $R$, $G$, and $B$:
	\begin{center}
		\begin{tabular}{cccc}
			$R$ & $G$ & $B$ & Color\\
			\hline
			0 & 0 & 0 & Black\\
			0 & 0 & 1 & Blue \\
			0 & 1 & 0 & Green\\
			0 & 1 & 1 & Cyan \\
			1 & 0 & 0 & Red \\
			1 & 0 & 1 & Magenta\\
			1 & 1 & 0 & Yellow\\
			1 & 1 & 1 & White
		\end{tabular}
	\end{center}
	Each of these colors can be represented as a bit vector of length 3, and we can
	apply Boolean operations to them.
	\begin{enumerate}[label=(\alph*)]
		\item The complement of a color is formed by turning off the lights that are
		on and turning on the lights that are off. What would be the complement of
		each of the eight colors listed above?
		\item Describe the effect of applying Boolean operations on the following
		colors:
		\begin{center}
			Blue $|$ Green = \makebox[1cm]{\hrulefill} \\
			Yellow \& Cyan = \makebox[1cm]{\hrulefill} \\
			Red $^\wedge$ Magenta = \makebox[1cm]{\hrulefill} 
		\end{center}
	\end{enumerate}
\end{ex}

\begin{sol}
	\begin{enumerate}[label=(\alph*)]
		\item The augmented table below shows the complementary colors, obtained by applying
		the logical NOT operation $\sim$ to each bit vector:
		\begin{center}
			\begin{tabular}{ccccc}
				$R$ & $G$ & $B$ & Color & Complement\\
				\hline
				0 & 0 & 0 & Black & White\\
				0 & 0 & 1 & Blue & Yellow \\
				0 & 1 & 0 & Green & Magenta\\
				0 & 1 & 1 & Cyan  & Red  \\
				1 & 0 & 0 & Red & Cyan \\
				1 & 0 & 1 & Magenta & Green\\
				1 & 1 & 0 & Yellow & Blue\\
				1 & 1 & 1 & White & Black
			\end{tabular}
		\end{center}
		\item Blue $|$ Green means we apply the logical OR operation to their corresponding bit
		vectors. We get 001 | 010 = 011, which is Cyan. Yellow \& Cyan means we apply the logical
		AND operator to the bit vectors, so 110 \& 011 = 010, which is Green. Finally,
		Red $^\wedge$ Magenta means apply logical XOR to the bit vectors, so 100 $^\wedge$ 101 = 001,
		which is Blue, so
		\begin{center}
			Blue $|$ Green = Cyan \\
			Yellow \& Cyan = Green \\
			Red $^\wedge$ Magenta = Blue
		\end{center}
	\end{enumerate}
\end{sol}

\begin{ex}{10}
	As an application of the property that $a ^\wedge a=0$ for any bit vector $a$, consider
	the following program:
	\begin{lstlisting}
void inplace_swap(int *x, int *y) {
   	*y = *x ^ *y;    /* Step 1 */
   	*x = *x ^ *y;    /* Step 2 */
   	*y = *x ^ *y;    /* Step 3 */
}
	\end{lstlisting}
	As the name suggests, we claim that the effect of this procedure is to swap the values
	stored at the locations denoted by pointer variables \texttt{x} and \texttt{y}. Note
	that unlike the usual technique for swapping two values, we do not need a third location
	to temporarily store one value while we are moving the other. There is no performance
	advantage to this way of swapping; it is merely an intellectual amusement.
	\
	
	\noindent Staring with values $a$ and $b$ in the locations pointed to by \texttt{x} and
	\texttt{y}, respectively, fill int he table that follows, giving the values stored at the
	two locations after each step of the procedure. Use the properties of $^\wedge$ to
	show that the desired effect is achieved. Recall that every element is its own additive
	inverse (that is, $a^\wedge a=0$).
	\begin{center}
		\begin{tabular}{ccc}
			Step & \texttt{*x} & \texttt{*y}\\
			\hline
			Initially & $a$ & $b$ \\
			Step 1 & \makebox[1cm]{\hrulefill}  & \makebox[1cm]{\hrulefill} \\
			Step 2 & \makebox[1cm]{\hrulefill}  & \makebox[1cm]{\hrulefill} \\
			Step 3 & \makebox[1cm]{\hrulefill}  & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	The completed table is below:
	
	\begin{center}
		\begin{tabular}{ccc}
			Step & \texttt{*x} & \texttt{*y}\\
			\hline
			Initially & $a$ & $b$ \\
			Step 1 & $a$  & $a ^\wedge b$ \\
			Step 2 & $a ^\wedge (a^\wedge b)$ & $a ^\wedge b$ \\
			Step 3 &  $a ^\wedge (a^\wedge b)$  & $[a ^\wedge (a^\wedge b)] ^\wedge [a ^\wedge b]$
		\end{tabular}
	\end{center}
	Since $a ^\wedge (a^\wedge b)=(a^\wedge a)\wedge b=0^\wedge b=b$, the table evaluates
	correctly.
\end{sol}

\begin{ex}{2.11}
	Armed with the function \texttt{inplace\_swap} from Problem 2.10, you decide to write
	code that will reverse the elements of an array by swapping from opposite ends of the
	array, working toward the middle:
	\begin{lstlisting}
void reverse_array(int a[], int cnt) {
	int first, last;
	for (first = 0, last = cnt-1;
	     first <= last;
	     first++, last--)
	     inplace_swap(&a[first], &a[last]);
}
	\end{lstlisting}
	When you apply your function to an array containing elements $1$, $2$, $3$, and $4$,
	you find that the array now has, as expected, elements $4$, $3$, $2$, and $1$. When
	you try it on an array with elements $1$, $2$, $3$, $4$, and $5$, however, you are
	surprised to see that the array now has elements $5$, $4$, $0$, $2$, and $1$. In
	fact, you discover that the code always works on arrays of even length, but it sets
	the middle element to 0 whenever the array has odd length.
	\begin{enumerate}[label=(\alph*)]
		\item For an array of odd length $\texttt{cnt}=2k+1$, what are the values of
		variables $\texttt{first}$ and $\texttt{last}$ in the final iteration of
		function \texttt{reverse\_array}?
		\item Why does this call to function \texttt{inplace\_swap} set the array element
		to 0?
		\item What simple modification to the code for \texttt{reverse\_array} would
		eliminate this problem?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Their values are the same, and their value is the one at
		the center of the array, namely, \texttt{a[cnt / 2]}.
		\item The XOR operation operates on the same number, and
		since every element is its own additive inverse with respect to
		this operation, the result is 0.
		\item Replace the comparison \texttt{first <= last} with
		\texttt{first < last}.
	\end{enumerate}
\end{sol}

\begin{ex}{2.12}
	Write C expressions, in terms of variable \texttt{x}, for the following values.
	Your code should work for any size $w\geq 8$. For reference, we show the result
	of evaluating the the expressions for \texttt{x = 0x87654321}, with $w=32$.
	\begin{enumerate}[label=(\alph*)]
		\item The least significant byte of \texttt{x}, with all other bits set
		to $0$. [\texttt{0x00000021}].
		\item All but the least significant byte of \texttt{x} complemented, with
		the least significant byte left unchanged. [\texttt{0x789ABC21}]
		\item The least significant byte set to all ones, and all other bytes
		of \texttt{x} left unchanged. [\texttt{0x876543FF}]
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{x \& 0xFF}
		\item  The expression is: \texttt{(x \& 0xFF) | (\~{}x \& \~{}0xFF)}. First,
		we use the \texttt{0xFF} mask to get the first byte of $x$. Then, we complement
		\texttt{x}, but mask with \texttt{\~{}0xFF} instead to get all bits except
		the last byte.
		\item The expression is: \texttt{x |{}0xFF}. By using the logical OR, we
		ensure the least significant byte is set to all 1s. The upper bytes are
		0, so they do not change. what's in \texttt{x}.
	\end{enumerate}
\end{sol}

\begin{ex}{2.13}
	The Digital Equipment VAX computer was a very popular machine from the late 1970s until
	the late 1980s. Rather than instructions for Boolean operations AND and OR, it had
	instructions \texttt{bis} (bit set) and \texttt{bic} (bit clear). Both instructions
	take a data word \texttt{x} and a mask word \texttt{m}. They generate a result
	\texttt{z} consisting of the bits of \texttt{x} modified according to the bits of
	\texttt{m}. With \texttt{bis}, the modification involves setting \texttt{z} to 1
	at each position where \texttt{m} is 1. With \texttt{bic}, the modification involves
	setting \texttt{z} to 0 at each bit position where \texttt{m} is 1.
	
	\
	To see how these operations relate to C bit-level operations, assume we have functions
	\texttt{bis} and \texttt{bis} implementing the bit set and bit clear operations, and
	that we want to use these to implement functions computing bitwise operations \texttt{|}
	and \texttt{\^}. Fill in the missing code below. Write C expressions for the operations
	\texttt{bis} and \texttt{bic}.
	
	\begin{lstlisting}
/* Declarations of functions implementing operatings bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/* Compute x|y using only calls to fucntions bis and bic */
int bool_or(int x, int y) {
	int result = __________;
	return result;
}

/* Compute x^y using only calls to functions bis and bic */
int bool_xor(int x, int y) {
	int result = ___________;
	return result;
}
	\end{lstlisting}
\end{ex}

\begin{sol}
	For the OR operation, suppose we start with $x$. The expression \texttt{bis(x, 0)} is
	equivalent to \texttt{x}. This is because 0 does not have any 1 bits. If \texttt{x} has
	1 bits, they remain 1; if they're 0, they remain 0. On the other hand, if
	\texttt{y} had all 1 bits, then \texttt{bit(x, y)} will be all 1 bits, regardless of what
	was in \texttt{x}. This suggests the correct way to implement \texttt{x} OR \texttt{y}
	is with \texttt{bis(x,y)}:
	\begin{enumerate}
		\item If the $i$-th bit of \texttt{x} is 1, then the result is 1 regardless
		of the value of the $i$-th bit of \texttt{y}.
		\item  If the $i$-th bit of \texttt{x} is 0, then the result is only 1 if the
		$i$-th bit of \texttt{y} is 1.
	\end{enumerate}
	Consider a truth table for the \texttt{bic(x, y)} operation:
	\begin{center}
		\begin{tabular}{cc|c}
			\texttt{x} & \texttt{y} & \texttt{bic(x, y)}\\
			\hline
			0 & 0 & 0 \\
			0 & 1 & 0 \\
			1 & 0 & 1 \\
			1 & 1 & 0 
		\end{tabular}
	\end{center}
	Note that if \texttt{x} is 0, then the result is 0. We could flip the inputs and get:
	\begin{center}
		\begin{tabular}{cc|c}
			\texttt{y} & \texttt{x} & \texttt{bic(y, x)}\\
			\hline
			0 & 0 & 0 \\
			0 & 1 & 0 \\
			1 & 0 & 1 \\
			1 & 1 & 0 
		\end{tabular}
	\end{center}
	Therefore, the $i$-th bit of \texttt{bic(x, y)} will be 1 only if the
	$i$-th bit of \texttt{x} is 1 and the $i$-th bit of \texttt{y} is 0.
	The opposite is true for \texttt{bic(y, x)}. We therefore get \texttt{x \^{} y}
	by applying the OR operation (which is just \texttt{bis}):
	\begin{lstlisting}
/* Declarations of functions implementing operatings bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/* Compute x|y using only calls to fucntions bis and bic */
int bool_or(int x, int y) {
	int result = bis(x, y);
	return result;
}

/* Compute x^y using only calls to functions bis and bic */
int bool_xor(int x, int y) {
	int result = bis(bic(x, y), bic(y, x));
	return result;
}
	\end{lstlisting}
\end{sol}

\begin{ex}{2.14}
	Suppose that \texttt{x} and \texttt{y} have byte values \texttt{0x66} and
	\texttt{0x39}, respectively. Fill in the following table indicating the byte
	values of the different C expressions:
	\begin{center}
		\begin{tabular}{cc|cc}
			Expression & Value & Expression & Value\\
			\hline
			\texttt{x \& y} & \makebox[1cm]{\hrulefill} & \texttt{x \&\& y} & \makebox[1cm]{\hrulefill}\\
			\texttt{x | y} & \makebox[1cm]{\hrulefill} & \texttt{x || y} & \makebox[1cm]{\hrulefill}\\
			\texttt{\~{} x | \~{}y} & \makebox[1cm]{\hrulefill} & \texttt{!x || !y} & \makebox[1cm]{\hrulefill}\\
			\texttt{x \& !y} & \makebox[1cm]{\hrulefill} & \texttt{x \&\& \~{}y} & \makebox[1cm]{\hrulefill}\\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	Note that \texttt{x = 0x66 = 0110 0110} and \texttt{y = 0x39 = 0011 1001}. Also
	\texttt{\~{}x = 1001 1001} and \texttt{\~{}y = 1100 0110}.
	\begin{center}
	
		\begin{tabular}{cc|cc}
			Expression & Value & Expression & Value\\
			\hline
			\texttt{x \& y} & \texttt{0010 0000} & \texttt{x \&\& y} & \texttt{0x01}\\
			\texttt{x | y} & \texttt{0111 1111} & \texttt{x || y} & \texttt{0x01}\\
			\texttt{\~{}x | \~{}y} & \texttt{1101 1111} & \texttt{!x || !y} & \texttt{0x00}\\
			\texttt{x \& !y} & \texttt{0100 0110} & \texttt{x \&\& \~{}y} & \texttt{0x01}\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.15}
	Using only bit-level and logical operations, write a C expression that is equivalent
	to \texttt{x == y}. That is, it will return 1 when \texttt{x} and \texttt{y} are equal
	and 0 otherwise.
\end{ex}

\begin{sol}
	We can use \texttt{!(x \& \~{}y)}. Suppose \texttt{x} and \texttt{y} are the same;
	then \texttt{x \& \~{}y} is 0, so the logical NOT operator \texttt{!} makes the result
	1. Now suppose they're different, say, they're $i$-th bit is different. Then
	the $i$-th bit of \texttt{x} \& \texttt{\~{}y} is the same, so \texttt{x \& \~{}y} is
	nonzero, which means that applying logical NOT gives a value of 0.
\end{sol}

\begin{ex}{2.16}
	Fill in the table below showing the effects of the different shift operations on
	single-byte quantities. The best way to think about shift operations is to work
	with binary representations. Convert the initial values to binary, perform the
	shifts, and then convert back to hexadecimal. Each of the answers should be 8
	binary digits or 2 hexadecimal digits.
	\begin{center}
		\begin{tabular}{c|cccc}
			\texttt{x} & \texttt{0xC3} & \texttt{0x75} & \texttt{0x87} & \texttt{0x66} \\
			\hline
			\texttt{x << 3} \\
			\texttt{x >> 2} (Logical) \\
			\texttt{x >> 2} (Arithmetic)
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	We begin by converting each hexadecimal to binary:
	\begin{align*}
		\texttt{0xC3} &= \texttt{1100 0011}\\
		\texttt{0x75} &= \texttt{0111 0101}\\
		\texttt{0x87} &= \texttt{1000 0111}\\
		\texttt{0x66} &= \texttt{0110 0110}
	\end{align*}
	From here, shifts are easy:
	\begin{center}
		\begin{tabular}{c|cccc}
			\texttt{x} (Hex) & \texttt{0xC3} & \texttt{0x75} & \texttt{0x87} & \texttt{0x66} \\
			\texttt{x} (Binary) & \texttt{1100 0011} & \texttt{0111 0101} & \texttt{1000 0111} & \texttt{0110 0110} \\
			\hline
			\texttt{x << 3} (Hex) & \texttt{0x18} & \texttt{0xA8} & \texttt{0x38} &  \texttt{0x30}\\
			\texttt{x << 3} (Binary) & \texttt{0001 1000} & \texttt{1010 1000} & \texttt{0011 1000} &  \texttt{0011 0000}\\
			\hline
			
			\texttt{x >> 2} (Logical, Hex) & \texttt{0x30} & \texttt{0x1D} & \texttt{0x21} & \texttt{0x19} \\
			\texttt{x >> 2} (Logical, Binary) & \texttt{0011 0000} & \texttt{0001 1101} & \texttt{0010 0001} & \texttt{0001 1001} \\
			\hline
			
			\texttt{x >> 2} (Arithmetic, Hex)  & \texttt{0xF0} & \texttt{0x1D} & \texttt{0xE1} & \texttt{0x19} \\
			\texttt{x >> 2} (Arithmetic, Binary)  & \texttt{1111 0000} & \texttt{0001 1101} & \texttt{1110 0001} & \texttt{0001 1001} 
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.17}
	Assuming $w=4$, we can assign a numeric value to each possible hexadecimal digit,
	assuming either an unsigned or a two's-complement interpretation. Fill in the following
	table according to these interpretations by writing out the nonzero powers of $2$
	in the summations shown in Equations~\ref{eq:b2u} and~\ref{eq:b2t}:
	\begin{equation}\label{eq:b2u}
		B2U_w(\vec{x})\doteq\sum_{i=0}^{w-1}x_i2^i
	\end{equation}
	\begin{equation}\label{eq:b2t}
		B2T_w(\vec{x})\doteq-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
	\end{equation}
	where $w$ is a positive integer, $x_i\in\{0,1\}$, and $\vec{x}=[x_{w-1},x_{w-2},\ldots,x_0]$.
	\begin{center}
		\begin{tabular}{cccc}
			Hexadecimal & Binary & $B2U_4(\vec{x})$ & $B2T_4(\vec{x})$ \\
			\hline
			\texttt{0xE} & \texttt{[1110]} & $2^3+2^2+2^1=14$ & $-2^3+2^2+2^1=-2$\\
			\texttt{0x0} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{0x5} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{0x8} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{0xD} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{0xF} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{cccc}
			Hexadecimal & Binary & $B2U_4(\vec{x})$ & $B2T_4(\vec{x})$ \\
			\hline
			\texttt{0xE} & \texttt{[1110]} & $2^3+2^2+2^1=14$ & $-2^3+2^2+2^1=-2$\\
			\texttt{0x0} & \texttt{[0000]} & $0$ & $0$\\
			\texttt{0x5} & \texttt{[0101]} & $2^2+2^0=5$ & $2^2+2^0=5$\\
			\texttt{0x8} & \texttt{[1000]} & $2^3=8$ & $-2^{-3}=-8$\\
			\texttt{0xD} & \texttt{[1101]} & $2^3+2^2+2^0=13$ & $-2^3+2^2+2^0=-3$\\
			\texttt{0xF} & \texttt{[1111]} & $2^3+2^2+2^1+2^0=15$ & $-2^{-3}+2^2+2^1+2^0=-1$
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.18}
	In Chapter 3, we will look at listings generated by a \emph{diassembler}, a program that
	converts an executable program file back to a more readable ASCII form. These
	files contain many hexadecimal numbers, typically representing values in two's-complement
	form. Being able to recognize these numbers and understand their significance
	(for example, whether they are negative or positive) is an important skill.
	
	\
	\noindent For lines labeled A-I (on the right) in the following listing, convert the
	hexadecimal values (in 32-bit two's complement form) shown to the right of the
	instruction names (\texttt{sub}, \texttt{mov}, and \texttt{add}) into their decimal
	equivalents:
	\begin{lstlisting}{}
4004d0:   48 81 ec e0 02 00 00     sub    $0x2e0,%rsp                 A.
4004d7:   48 8b 44 24 a8           mov    -0x58(%rsp),%rax            B.
4004dc:   48 03 47 28              add    0x28(%rdi),%rax             C.
4004e0:   48 89 44 24 d0           mov    %rax,-0x30(%rsp)            D.
4004e5:   48 8b 44 24 78           mov    %0x78(%rsp),%rax            E.
4004ea:   48 89 87 88 00 00 00     mov    %rax,0x88(%rdi)             F.
4004f1:   48 8b 84 24 f8 01 00     mov    0x1f8(%rsp),%rax            G.
4004f8:   00
4004f9:   48 03 44 24 08           add    0x8(%rsp),%rax
4004fe:   48 89 84 24 c0 00 00     mov    %rax,%0xc0(%rsp)            H.
400505:   00
400506:   48 8b 44 d4 b8           mov    -0x48(%rsp,%rdx,8),%rax     I.
	\end{lstlisting}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\Alph*)]
		\item We are given \texttt{\texttt{$\bar{x}$} = 0x2e0 = 0010 1110 0000}. Since the number
		is given in 32-bit two's complement form, the other 20 bits are 0. By using the $B2T_{32}$
		function, we get
		\begin{align*}
			B2T_{32}(\bar{x})=2^{9}+2^{7}+2^{6}+2^{5}=736
		\end{align*}
		\item Letting \texttt{$\bar{x}$ = 0x58 = 0101 1000}, we interpret the \texttt{-} as
		a negative sign and get
		\begin{align*}
			-B2T_{32}(\bar{x})=-\left(2^{6} + 2^{4} + 2^{3}=2,147,483,560\right)=-88
		\end{align*}
		\item Since \texttt{$\bar{x}$ = 0x28 = 0010 1000}, we get
		\begin{align*}
			B2T_{32}(\bar{x})=2^5+2^3=40
		\end{align*}
		\item Letting \texttt{$\bar{x}$ = 0x30 = 0011 0000}, we get
		\begin{align*}
			-B2T_{32}(\bar{x})=-\left(2^5+2^4\right) = -48
		\end{align*}
		\item Letting \texttt{$\bar{x}$ = 0x78 = 0111 1000}, we get
		\begin{align*}
			B2T_{32}(\bar{x})=2^6+2^5+2^4+2^3=120
		\end{align*}
		\item Letting \texttt{$\bar{x}$ = 0x88 = 1000 1000}, we get
		\begin{align*}
			B2T_{32}(\bar{x}) = 2^7 + 2^3 = 136
		\end{align*}
		\item Letting \texttt{$\bar{x}$ = 0x1f8 = 0001 1111 1000}, we get
		\begin{align*}
			B2T_{32}(\bar{x})=2^8 + 2^7 + 2^6 + 2^5 + 2^4 + 2^3 = 504
		\end{align*}
		\item Letting \texttt{$\bar{x}$ = 0xc0 = 1100 0000}, we get
		\begin{align*}
			B2T_{32}(\bar{x})=2^{7}+2^{6}=192
		\end{align*}
		\item Letting \texttt{$\bar{x}$ = 0x48 = 0100 1000}, we get
		\begin{align*}
			-B2T_{32}(\bar{x}) = -\left(2^6 + 2^3\right) = 72
		\end{align*}
	\end{enumerate}
\end{sol}

\begin{ex}{2.19}
	Using the table you filled when solving Problem 2.17, fill in the following table describing
	the function $T2U_4$:
	\begin{center}
		\begin{tabular}{cc}
			$x$ & $T2U_4(x)$\\
			\hline
			-8 & \makebox[1cm]{\hrulefill}\\
			-3 & \makebox[1cm]{\hrulefill}\\
			-2 & \makebox[1cm]{\hrulefill}\\
			-1 & \makebox[1cm]{\hrulefill}\\
			 0 & \makebox[1cm]{\hrulefill}\\
			 5 & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{cc}
			$x$ & $T2U_4(x)$\\
			\hline
			-8 & 8\\
			-3 & 13\\
			-2 & 14\\
			-1 & 15\\
			0 & 0\\
			5 & 5
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.20}
	Explain how Equation~\ref{eqn:t2u} applies to the entries in the table you generated when
	solving Problem 2.19.
	\begin{equation}\label{eqn:t2u}
		T2U_w(x)=\begin{cases}
			x + 2^w, & x < 0\\
			x,       & x\geq 0
		\end{cases}
	\end{equation}
\end{ex}

\begin{sol}
	In Problem 2.19, we had $w=4$. If the value on the left is non-negative, it remains unchanged.
	Otherwise, we add $2^4=16$ to the corresponding value on the left column.
\end{sol}

\begin{ex}{2.21}
	Assuming the expressions are evaluated when executing a 32-bit program on a machine that uses
	two's-complement arithmetic, fill in the following table describing the effect of casting
	and relational operations, in the style of Figure 2.19 (of text).
		\begin{center}
		\begin{tabular}{ccc}
			\hline
			Expression & Type & Evaluating \\
			\hline
			\texttt{-2147483647-1 == 2147483648U} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{-2147483647-1 == 2147483647} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{-2147483647-1U == 2147483647} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{-2147483647-1 == -2147483647} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{-2147483647-1U == -2147483647} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	\begin{center}
		Note that in the operation \texttt{-2147483647-1U}, the operand \texttt{1U} is unsigned,
		so C implicitly casts \texttt{-2147483647} to the unsigned number $2147483647+2^{32}=2147483649$.
		\begin{tabular}{ccc}
			\hline
			Expression & Type & Evaluating \\
			\hline
			\texttt{-2147483647-1 == 2147483648U} & Unsigned & \texttt{1}\\
			\texttt{-2147483647-1 == 2147483647} & Signed & \texttt{0}\\
			\texttt{-2147483647-1U == 2147483647} & Unsigned & \texttt{0} \\
			\texttt{-2147483647-1 == -2147483647} & Signed & \texttt{1}\\
			\texttt{-2147483647-1U == -2147483647} & Unsigned & \texttt{0}\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.22}
	Show that each of the following bit vectors is a two's-complement representation of -5
	by applying Equation~\ref{eq:b2t}:
	\begin{enumerate}[label=(\alph*)]
		\item {}[1011]
		\item {}[11011]
		\item {}[111011]
	\end{enumerate}
	Observe that the second and third bit vectors can be derived from the first by sign extension.
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item $w=4$, so $B2T_4([1011])=-2^3+2^1+2^0=-8+2+1=-5$.
		\item $w=5$, so $B2T_5([11011])=-2^4+2^3+2^1+2^0=-16+8+2+1=-5$.
		\item $w=6$, so $B2T_6([111011])=-2^5+2^4+2^3+2^1+2^0=-32+16+8+2+1=-5$.
	\end{enumerate}
\end{sol}

\begin{ex}2{2.23}
	Consider the following C functions:
	\begin{lstlisting}
int fun1(unsigned word) {
	return (int) ((word << 24) >> 24);
}

int fun2(unsigne dword) {
	return ((int) word << 24) >> 24;
}
	\end{lstlisting}
	Assume these are executed as a 32-bit program on a machine that uses two's-complement arithmetic.
	Assume also that right shifts og signed values are performed arithmetically, while right shifts
	of unsigned values are performed logically.
	\begin{enumerate}[label=(\alph*)]
		\item Fill in the following table showing the effect of these functions for several example
		arguments. You will find it more convenient to work with a hexadecimal representation. Just
		remember that hex digits \texttt{8} through \texttt{F} have their most significant bits
		equal to 1.
		\begin{center}
			\begin{tabular}{ccc}
				\texttt{w} & \texttt{fun1(w)} & \texttt{fun2(w)}\\
				\hline
				\texttt{0x00000076} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
				\texttt{0x87654321} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
				\texttt{0x000000C9} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
				\texttt{0xEDCBA987} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
			\end{tabular}
		\end{center}
		\item Describe in words the useful computation each of these functions perform.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item
		\
		\begin{center}
			\begin{tabular}{ccc}
				\texttt{w} & \texttt{fun1(w)} & \texttt{fun2(w)}\\
				\hline
				\texttt{0x00000076} & \texttt{0x00000076} & \texttt{0x00000076}\\
				\texttt{0x87654321} & \texttt{0x00000021} & \texttt{0x00000021}\\
				\texttt{0x000000C9} & \texttt{0x000000C9} & \texttt{0xFFFFFFC9}\\
				\texttt{0xEDCBA987} & \texttt{0x00000087} & \texttt{0xFFFFFF87}
			\end{tabular}
		\end{center}
		\item \texttt{fun1} computes the zero-extension of the least significant byte,
		whereas \texttt{fun2} computes the sign-extension of the least significant byte.
		and the 
	\end{enumerate}
\end{sol}

\begin{ex}{2.24}
	Suppose we truncate a 4-bit value (represented by hex digits \texttt{0} through
	\texttt{F}) to a 3-bit value (represented as hex digits \texttt{0} through \texttt{7}).
	Fill in the table below showing the effect of this truncation for some cases, in terms
	of the unsigned two's-complement interpretation of those bit patterns.
	\begin{center}
		\begin{tabular}{cccccc}
			\multicolumn{2}{c}{Hex} & \multicolumn{2}{c}{Unsigned} & \multicolumn{2}{c}{Two's Complement}\\
			Original & Truncated & Original & Truncated & Original & Truncated\\
			\hline
			0 & 0 & 0 & \makebox[1cm]{\hrulefill} & 0 & \makebox[1cm]{\hrulefill}\\
			2 & 2 & 2 & \makebox[1cm]{\hrulefill} & 2 & \makebox[1cm]{\hrulefill}\\
			9 & 1 & 9 & \makebox[1cm]{\hrulefill} & -7 & \makebox[1cm]{\hrulefill}\\
			B & 3 & 11 & \makebox[1cm]{\hrulefill} & -5 & \makebox[1cm]{\hrulefill}\\
			F & 7 & 15 & \makebox[1cm]{\hrulefill} & -1 & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
	Explain how Equations~\ref{eqn:trunc-b2u-k} and ~\ref{eqn:trunc-b2t-k} apply to these cases.
	\begin{equation}\label{eqn:trunc-b2u-k}
		B2U_k([x_{k-1}, x_{k-2},\ldots,x_0])=B2U_w([x_{w-1},x_{w-2},\ldots,x_0])\mod 2^k
	\end{equation}
	\begin{equation}\label{eqn:trunc-b2t-k}
		B2T_k([x_{k-1}, x_{k-2},\ldots,x_0])=U2T_k)(B2U_w([x_{w-1},x_{w-2},\ldots,x_0])\mod 2^k)
	\end{equation}
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{cccccc}
			\multicolumn{2}{c}{Hex} & \multicolumn{2}{c}{Unsigned} & \multicolumn{2}{c}{Two's Complement}\\
			Original & Truncated & Original & Truncated & Original & Truncated\\
			\hline
			0 & 0 & 0 & 0 & 0 & 0\\
			2 & 2 & 2 & 2 & 2 & 2\\
			9 & 1 & 9 & 1 & -7 & 1\\
			B & 3 & 11 & 3 & -5 & 3\\
			F & 7 & 15 & 7 & -1 & -1
		\end{tabular}
	\end{center}
	The value under the Unsigned  Truncated column is obtained by applying equation~\ref{eqn:trunc-b2u-k},
	where we take apply $x\mod (2^3)=x\mod8$ to all of the values. The value under the Two's Complement
	Truncated column ar obtained by mapping applying equation~\ref{eqn:trunc-b2t-k}, which means
	we just apply $U2T_3$ to the result of the Unsigned Truncated column.
\end{sol}

\begin{ex}{2.25}
	Consider the following code that attempts to sum the elements of an array \texttt{a},
	where the number of elements is given by parameter \texttt{length}:
	\begin{lstlisting}
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length) {
	int i;
	float result = 0;
	
	for (i = 0; i <= length-1; i++)
	    result += a[i];
	return result;
}
	\end{lstlisting}
	When run with argument \texttt{length} equal to 0, this code should return \texttt{0.0}.
	Instead, it encounters a memory error. Explain why this happens. Show how this can be
	corrected.
\end{ex}

\begin{sol}
	The argument \texttt{length} is unsigned, so in the operation \texttt{length-1} of
	the loop condition, the operation is equivalent to \texttt{length-1U} because C implicit
	casts the signed operand \texttt{-1} to unsigned. The result is \texttt{0+UINT\_MAX},
	where \texttt{UINT\_MAX} is the constant declared in \texttt{<limits.h>} that represents
	the maximum unsigned number that can be represented on the existing machine.
	When the unsigned comparison then happens, the loop condition is always true because
	no unsigned number exceeds this one. When the index \texttt{i} is then used to index
	into the array \texttt{a} inside the loop, an invalid memory location is accessed,
	causing the error. We can correct the by changing the condition to from
	\texttt{i <= length -1} to \texttt{i < length}.
\end{sol}

\begin{ex}{2.26}
	You are given the assignment of writing a function that determines whether one string is
	longer than another. You decide to make use of the string library function \texttt{strlen}
	having the following declaration:
	\begin{lstlisting}
/* Prototype for library function strlen */
size_t strlen(const char *s);
	\end{lstlisting}
	Here is your first attempt at the function:
	\begin{lstlisting}
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
	return strlen(s) - strlen(t) > 0;
}
	\end{lstlisting}
	When you test this on some simple data, things do not seem to work quite right. You
	investigate further and determine that, whe compiled as a 32-bit program, data type
	\texttt{size\_t} is defined (via \texttt{typedef}) in header file \texttt{stdio.h} to
	be \texttt{unsigned}.
	\begin{enumerate}[label=(\alph*)]
		\item For what cases will this function produce an incorrect result?
		\item Explain how this incorrect result comes about.
		\item Show how to fix the code so that it will work reliably.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The function will fail anytime the difference is negative, which is when
		\texttt{s} is shorter than \texttt{t}.
		\item The error occurs because when an expression contains unsigned operands,
		C will implicitly cast signed operands to unsigned. In this case, the result of \texttt{strlen(s) - strlen(t)} is cast to an unsigned number. Therefore, if the result is negative, it is
		cast to a positive number. If the result is negative, it is then cast to a positive
		number.
		\item We can fix the problem by replacing the expression after the \texttt{return} statement
		with \texttt{return strlen(s) > strlen(t)}.
	\end{enumerate}
\end{sol}

\begin{ex}{2.27}
	Write a function with the following prototype:
	\begin{lstlisting}
/* Determine whether arguments can be added without overflow */
int uadd_ok(unsigned x, unsigned y);
	\end{lstlisting}
	This function should return 1 if arguments \texttt{x} and \texttt{y} can be
	added without overflow.
\end{ex}

\begin{sol}
	See code listing below for \texttt{./27-unsigned-addition-overflow/uoverflow.c}:
	\lstinputlisting{./27-unsigned-addition-overflow/uoverflow.c}
\end{sol}

\begin{ex}{2.28}
	The presents shows that for any number $x$ such that $0\leq x<2^w$, its $w$-bit
	unsigned negation $-^u_w$ is given by the following:
	\begin{equation}\label{eqn:unsigned-negation}
		-^u_wx=\begin{cases}
			x, & x = 0\\
			2^w-x, & x > 0
		\end{cases}
	\end{equation}

	\noindent We can represent a bit pattern of length $w=4$ with a single hex digit. For an
	unsigned interpretation of these digits, use Equation~\ref{eqn:unsigned-negation}
	to fill in the following table giving the values and bit representations (in hex)
	of the unsigned additive inverses of the digits shown.
	\begin{center}
		\begin{tabular}{cccc}
			\multicolumn{2}{c}{$x$} & \multicolumn{2}{c}{$-^u_wx$}\\
			\hline
			Hex & Decimal & Decimal & Hex\\
			\hline
			\texttt{0} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{5} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{8} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{D} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\texttt{F} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{cccc}
			\multicolumn{2}{c}{$x$} & \multicolumn{2}{c}{$-^u_wx$}\\
			\hline
			Hex & Decimal & Decimal & Hex\\
			\hline
			\texttt{0} & 0 & 0 & \texttt{0x0}\\
			\texttt{5} & 5 & 11 & \texttt{0xB}\\
			\texttt{8} & 8 & 8 & \texttt{0x8}\\
			\texttt{D} & 13 & 3 & \texttt{0x3}\\
			\texttt{F} & 15 & 1 & \texttt{0x1}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.29}
	Fill in the following table in the style of Figure 2.25 (of book). Give the integer values
	of the 5-bit arguments, the values of both their integer and two's-complement sums,
	the bit-level representation of the two's-complement sum, and the case from the
	derivation of Equation 2.13.
	\begin{center}
		\begin{tabular}{ccccc}
			$x$ & $y$ & $x+y$ & $x+^t_5y$ & Case\\
			\hline
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			[10100] & [10001] & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			[11000] & [11000] & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			[10111] & [01000] & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			[00010] & [00101] & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			[01100] & [00100] & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} 
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{ccccc}
			$x$ & $y$ & $x+y$ & $x+^t_5y$ & Case\\
			\hline
			-12 & -15 & -27 & 5 & 1\\
			
			[10100] & [10001] & [100101] & [00101] \\
			
			-8 & -8 & -16 & -16 & 2\\
			
			[11000] & [11000] & [10000] & [10000] \\
			
			-9 & 8 & -1 & -1 & 2\\
			
			[10111] & [01000] & [11111] & [11111] \\
			
			2 & 5 & 7 & 7 & 3 \\
			
			[00010] & [00101] & [00111] & [00111] \\
			
			12 & 4 & 16 & -16 & 4\\
			
			[01100] & [00100] & [010000] & [10000]
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.30}
	Write a function with the following prototype
	\begin{lstlisting}
/* Determine whether arguments can be added without overflow */
int tadd_ok(int x, int y);
	\end{lstlisting}
	This function should return 1 if arguments \texttt{x} and \texttt{y} can be added without
	causing overflow.
\end{ex}

\begin{sol}
	See code listing below for \texttt{./30-signed-addition-overflow/toverflow.c}:
	\lstinputlisting{./30-signed-addition-overflow/toverflow.c}
\end{sol}

\begin{ex}{2.31}
	Your coworker gets impatient with your analysis of the overflow conditions for
	two's-complement addition and presents you with the following implementation
	of \texttt{tadd\_ok}:
	\begin{lstlisting}
/* Determine whether arguments can be added without overflow */
/* WARNING: This code is buggy */
int tadd_ok(int x, int y) {
	int sum = x + y;
	return (sum-x == y) && (sum-y == x);
}
	\end{lstlisting}
	You look at the code and laugh. Explain why.
\end{ex}

\begin{sol}
	\
	Recall that two's-complement numbers have the same bit-level representation
	as unsigned numbers. Therefore, two's-complement addition is characterized by
	converting to unsigned, performing unsigned addition, and converting back to
	two's-complement. As a result, \texttt{(x + y) - x} equals \texttt{y},
	because unsigned addition is just modulo addition. Converting back to
	signed, now we are comparing two signed numbers with the same bit-level
	representation. The result always true; that is, \texttt{sum-x == y} is as
	tautology. Similarly, \texttt{sum -y} always equals \texttt{x}. Therefore,
	the function always returns 1.
\end{sol}

\begin{ex}{2.32}
	You are assigned the task of writing code for a function \texttt{tsub\_ok}, with
	arguments \texttt{x} and \texttt{y}, that will return 1 if computing \texttt{x-y}
	does not cause overflow. Having just written the code for Problem 2.30, you write
	the following:
	\begin{lstlisting}
/* Determine whether arguemnts can be subtracted without overflow */
/* WARNING: This code is buggy */
int tsub_ok(int x, int y) {
	return tadd_ok(x, -y);
}
	\end{lstlisting}
	For what values of \texttt{x} and \texttt{y} will this function give incorrect
	results? Writing a correct version of this function is left as an exercise (Problem 2.74).
\end{ex}

\begin{sol}
	Subtraction overflow occurs when \texttt{x >= 0, y < 0}, and \texttt{x - y < 0},
	or when \texttt{x <= 0, y > 0}, and \texttt{x - y > 0}. Suppose that
	\texttt{$TMin_w$ < y <= $TMax_w$}; then \texttt{-$TMax_w$ <= -y < $-TMin_w$}, or
	equivalently, \texttt{$TMin_w$ < -y <= $TMax_w$}. Then, \texttt{x + (-y)} causes
	positive overflow if \texttt{x > 0, -y > 0}, and \texttt{x + (-y) < 0}, which is
	equivalent to the first subtraction overflow condition. Similarly,
	\texttt{x + (-y)} causes negative overflow if \texttt{x < 0, -y < 0}, and \texttt{x + (-y) > 0},
	which is precisely the second condition.
	
	\
	However, suppose that \texttt{y} is $TMin_w$. Then \texttt{-y} is unchanged. Recalling
	that the bit-level representation for two's-complement numbers is the same as
	unsigned, we could get the negated value by converting to unsigned, negating, and
	converting back to two's-complement. In converting to unsigned, \texttt{y} becomes
	$-TMin_w$ (which is a positive value in the range of unsigned numbers), and then
	applying the inverse operation \texttt{-} means we compute $2^w - y$, which remains
	unchanged because $-TMin_w=2^{w-1}$, so $2^w-y=2^w-2^{w-1}=2^{w-1}=-TMin_w$. Converting
	back to signed, we are back with the same number we started; that is,
	\texttt{y == -y}. But now:
	\begin{enumerate}[label=(\roman*)]
		\item If \texttt{x} is 0, we get \texttt{tadd\_ok(0, -y)}, which gives 1 because
		that addition does not overflow. However, the result of \texttt{0 - y} should
		be a positive number, so the \texttt{tsub\_ok} ends up reporting the wrong value.
		\item If \texttt{x} is positive, then \texttt{tadd\_ok(x, -y)} reports 1 again,
		because there is no problem with adding a positive number and $TMin_w$.
		However, this is incorrect once again, because $x>0$, $y<0$, and $x-y < 0$,
		so the output should be 0, indicating overflow happens.
		\item If \texttt{x} is negative, then \texttt{tadd\_ok} receives a negative
		number being added to $TMin_w$, so the sum is positive and it reports
		overflow. However, that's incorrect also; for example $-1 - (TMin_w + 1)$ is a
		valid expression that returns $TMax_w$ (as it should).
	\end{enumerate}
	
	In summary, it works correctly when \texttt{y} is not $TMin_w$.
	Suppose \texttt{y} is not $TMin_w$. Then 
\end{sol}

\begin{ex}{2.33}
	We can represent a bit pattern of length $w=4$ with a single hex digit. For a
	two's-complement interpretation of these digits, fill in the following table to
	determine the additive inverses of the digits shown:
	\begin{center}
		\begin{tabular}{cccc}
			\multicolumn{2}{c}{$x$} & \multicolumn{2}{c}{$-^t_4x$}\\
			Hex & Decimal & Decimal & Hex\\
			\hline
			\texttt{0} &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} \\
			\texttt{5} &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill} \\
			\texttt{8} &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill} \\
			\texttt{D} &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill} \\
			\texttt{F} &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill}  &  \makebox[1cm]{\hrulefill} 
		\end{tabular}
	\end{center}
	What do you observe about the bit patterns generated by two's-complement
	and unsigned (Problem 2.28) negation?
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{cccc}
			\multicolumn{2}{c}{$x$} & \multicolumn{2}{c}{$-^t_4x$}\\
			Hex & Decimal & Decimal & Hex\\
			\hline
			\texttt{0} &  0  &  0 & \texttt{0x0}\\
			\texttt{5} &  5 & -5 & \texttt{0xB} \\
			\texttt{8} & -8 & -8 & \texttt{0x8}\\
			\texttt{D} & -3 & 3 & \texttt{0x3} \\
			\texttt{F} & -1 & 1 & \texttt{0x1}
		\end{tabular}
	\end{center}
	The bit patterns are the same obtained when doing unsigned negation.
\end{sol}

\begin{ex}{2.34}
	Fill in the following table showing the results of multiplying different 3-bit
	numbers, in the style of Figure 2.27 (of the book):
	\begin{center}
		\begin{tabular}{ccccccccc}
			Mode & \multicolumn{2}{c}{$x$} & \multicolumn{2}{c}{$y$} & \multicolumn{2}{c}{$x\cdot y$}
			& \multicolumn{2}{c}{Truncated $x\cdot y$}\\
			\hline
			Unsigned &  \makebox[1cm]{\hrulefill} & [100] &  \makebox[1cm]{\hrulefill} & [101]
			&  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} \\
			Two's complement &  \makebox[1cm]{\hrulefill} & [100] &  \makebox[1cm]{\hrulefill} & [101]
			&  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} \\
			Unsigned &  \makebox[1cm]{\hrulefill} & [010] &  \makebox[1cm]{\hrulefill} & [111]
			&  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} \\
			Two's complement &  \makebox[1cm]{\hrulefill} & [010] &  \makebox[1cm]{\hrulefill} & [111]
			&  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} \\
			Unsigned &  \makebox[1cm]{\hrulefill} & [110] &  \makebox[1cm]{\hrulefill} & [110]
			&  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} \\
			Two's complement &  \makebox[1cm]{\hrulefill} & [110] &  \makebox[1cm]{\hrulefill} & [110]
			&  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill} &  \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{ccccccccc}
			Mode & \multicolumn{2}{c}{$x$} & \multicolumn{2}{c}{$y$} & \multicolumn{2}{c}{$x\cdot y$}
			& \multicolumn{2}{c}{Truncated $x\cdot y$}\\
			\hline
			Unsigned &  4 & [100] &  5 & [101] & 20 & [10100] &  4 &  [100] \\
			Two's complement &  -4 & [100] &  -3 & [101] & 12 &  [01100] & -4 &  [100] \\
			Unsigned &  2 & [010] &  7 & [111] & 14 &  [01110] & 6 &  [110] \\
			Two's complement & 2 & [010] & -1 & [111] & -2 & [11110]  &  -2 &  [110] \\
			Unsigned & 6 & [110] & 6 & [110] & 36 & [100100] & 4 & [100] \\
			Two's complement &  -2 & [110] & -2 & [110] & 4 & [00100] &  -4 &  [100]
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.35}
	You are given the assignment to develop code for a function \texttt{tmult\_ok}
	that will determine whether two arguments can be multiplied without causing
	overflow. Here is your solution:
	
	\begin{lstlisting}
/* Determine whether arguments can be multiplied without overflow */
int tmult_ok(int x, int y) {
	int p = x*y;
	/* Either x is zero, or diving p by x gives y */
	return !x || p/x = y;
}
	\end{lstlisting}
	You test this code for a number of values of \texttt{x} and \texttt{y}, and it
	seems to work properly. Your coworker challenges you, saying ``If I can't use
	subtraction to test whether addition has overflowed (see Problem 2.31), then how
	can you  use division to test whether multiplication has overflowed?"
	
	Devise a mathematical justification of your approach, along the following lines.
	First, argue the case $x=0$ is handled correctly. Otherwise, consider
	$w$-bit numbers $x$ $(x\neq 0)$, $y$, $p$, and $q$, where $p$ is the result of
	performing two's-complement multiplication on $x$ and $y$, and $q$ is the
	result of dividing $p$ by $x$.
	\begin{enumerate}
		\item Show that $x\cdot y$, the integer product of $x$ and $y$, can be written
		in the form $x\cdot y=p+t2^w$, where $t\neq 0$ if and only if the computation
		of $p$ overflows.
		\item Show that $p$ can be written in the form $p=x\cdot q+r$, where $|r|<|x|$.
		\item Show that $q=y$ if and only if $r=t=0$.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	If $x=0$, then the product is 0 regardless of the value of $y$, so there is no
	overflow because $x$ is in the valid range for two's-complement numbers.
	Now suppose that $x\neq 0$ and $y$ are $w$-bit two's-complement numbers.
	\begin{enumerate}
		\item Since $p$ is the result of the unsigned two's-complement
		multiplication of $x$ and $y$, we have
		\[
		p=x*_w^ty=U2T_w((x\cdot y)\mod 2^w)
		\]
		In particular, $u=(x\cdot y)\mod 2^w$ is in the range $[0, 2^w-1]$,
		where $u=(x\cdot y)+s 2^w$ form some $s$, by the definition of modulo
		arithmetic. Then $U2T_w(u)=-u_{w-1}2^w+u$, where $u_{w-1}$ is its
		most significant bit. Thus
		\[
		p=U2T_w(u)=-u_{w-1}2^{w}+u=(x\cdot y)+(s-u_{w-1})2^w=(x\cdot y)+t2^w
		\]
		where we have let $t=(x-u_{w-1})$. If $p$ overflows, then $x\cdot y$ is outside the range that can be represented by $w$ bits, and
		since $x\cdot y = p - t2^w$, this happens if and only if $t\neq 0$,
		for if $t=0$, the $x\cdot y=p$, which means they both belong to
		the range $[TMin_w, TMax_w]$.
		\item Since $q$ is the quotient of $p$ and $x$, there are two cases:
		if $x$ evenly divides $p$, the $q=p/x$, and hence,
		$p=x\cdot q+0$, with $|0|<|x|$ since $x\neq 0$. On the other hand,
		if there is a remainder when dividing $p$ by $x$, then
		$p=x\cdot q + r$. 
		\item Combining both equations, we have
		\[
		x\cdot y = x\cdot q + r + t2^w
		\]
		If $q=y$, then the equation reduces to
		\[
		r=-t2^w
		\]
		However, since $|r|<|x|$ and $|x|<2^w$, this equation does not
		have a solution unless $r=t=0$. On the other hand, if we are
		given that $r=t=0$, then the equation becomes
		\[
		x(y-q)=0
		\]
		Since we know that $x\neq 0$, it follows that $y-q=0$, so
		$y=q$.
	\end{enumerate}
\end{sol}

\begin{ex}{2.36}
	For the case where data type \texttt{int} has 32 bits, devise a
	version of \texttt{tmult\_ok} (Problem 2.35) that uses the
	64-bit precision of \texttt{int64\_t}, without using division.
\end{ex}

\begin{sol}
	\
	We declare a variable \texttt{p} of type \texttt{uint64\_t} to hold
	the result of the product. However, that is not enough; if we compute
	the product of the two 32-bit int values, a 32-bit two's-complement
	multiplication takes place, and the result is simply sign-extended
	into the result variable. Instead, we need to ensure multiplication
	occurs as a 64-bit multiplication. To achieve this, we cast the operands
	to \texttt{uint64\_t}. It's enough to cast one operand, e.g., \texttt{x},
	since $C$ will implicitly promote the other to be of the larger
	width. Now, overflows does not occur 32 most significant bits are all
	0. If we compare the product \texttt{p} to its 32-bit truncated
	version, we can conclude that no truncation happens if their
	values are the same. 
	
	\
	See code listing for \texttt{./36-signed-multiplication-overflow/tmultof.c}:
	\lstinputlisting{./36-signed-multiplication-overflow/tmultof.c}
\end{sol}

\begin{ex}{2.37}
	You are given the task of patching the vulnerability in the XDR code
	shown in the aside on page 100 for the case where both data types
	\texttt{int} and \texttt{size\_t} are 32 bits. You decide to eliminate
	the possibility of the multiplication overflowing by computing the
	number of bytes to allocate using data type \texttt{uint64\_t}.
	You replace the original call to \texttt{malloc} (line 9) as follows:
	\begin{lstlisting}
uint64_t asize = ele_cnt * (uint64_t) ele_size;
void *result = malloc(asize);
	\end{lstlisting}
	Recall that the argument to \texttt{malloc} has type \texttt{size\_t}.
	\begin{enumerate}
		\item Does your code provide any improvement over the original?
		\item How would you change the code to eliminate the
		vulnerability?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Since the variables of type \texttt{int} and \texttt{size\_t}
		are both 32 bits, their product fits in a 64-bit number. By using a
		local variable \texttt{uint64\_t} and casting the \texttt{size\_t}
		operand to \texttt{untin64\_t}, a zero-extension occurs while a
		sign-extension occurs for the \texttt{int}. In any case, the product
		perfectly fits, without multiplication overflow occurring.
		However, since \texttt{malloc} expects a \texttt{size\_t}
		which has 32 bits, and we are passing \texttt{asize} which has
		64 bits, truncation happens, so there is still a risk that the overflow
		causes the allocated structure to be shorter in length than
		the argument \texttt{ele\_cnt} that controls our iteration.
		Hence, the risk remains.
		\item To begin, I would change the parameter of type \texttt{int}
		to also be of type \texttt{size\_t}. I would compute the product with 64 bit precision as in
		the previous part. But rather than immediately calling \texttt{malloc},
		I would attempt to detect overflow, either via a downcast,
		such as \texttt{asize == (size\_t) asize}, which would indicate
		that the most significant 32 bits are 0, or by the method of
		Problem 2.35, where ensure the quotient of \texttt{asize}
		and \texttt{ele\_cnt} equals \texttt{ele\_size}.
		In the scenario that it does not match, I would exit the function early,
		perhaps by returning \texttt{NULL} just like what happens for the
		check after the call to \texttt{malloc}.
 	\end{enumerate}
\end{sol}

\begin{ex}{2.38}
	As we will see in Chapter 3, the \texttt{LEA} instruction can perform computations of
	the form \texttt{(a<<k) + b}, where \texttt{k} is either 0, 1, 2, or 3, and \texttt{b}
	is either 0 or some program value. The compiler uses this instruction to perform multiplications
	by constant factors. For example, we can compute \texttt{3*a} as \texttt{(a<<1) + a}.
	\
	Considering cases where \texttt{b} is either 0 or equal to \texttt{a}, and all possible values
	of \texttt{k}, what multiples of \texttt{a} can be computed with a single \texttt{LEA}
	instruction?
\end{ex}

\begin{sol}
	\
	The possible multiples are:
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{a*1}: This is \texttt{(a<<0) + a}, or just \texttt{a}.
		\item \texttt{a*2}: \texttt{(a<<1)+0}.
		\item \texttt{a*3}: \texttt{(a<<1)+a}.
		\item \texttt{a*4}: \texttt{(a<<2)+0}.
		\item \texttt{a*5}: \texttt{(a<<2)+a}.
		\item \texttt{a*8}: \texttt{(a<<3)+0}.
		\item \texttt{a*9}: \texttt{(a<<3)+a}
	\end{enumerate}
	Note that \texttt{(a<<0)} is just \texttt{a}, 
\end{sol}

\begin{ex}{2.39}
	According to the text, given a binary representation of $K$ as an alternating
	sequence of zeros and ones:
	\[
	[(0\ldots0)(1\ldots1)(0\ldots0)\cdots(1\ldots1)]
	\]
	and letting $n$ and $m$ be bit positions representing the start and end, respectively,
	of a run of ones, then we can compute the effect of these bits on the product
	using either of the following two forms:
	\begin{align*}
		\text{Form A: }&\texttt{(x<<n)(x<<(n-1))$+\cdots+$(x<<n)}\\
		\text{Form B: }&\texttt{(x<<(n+1))-(x<<m)}
	\end{align*}
	For example, 14 can be written as $[(0\ldots0)(111)(0)]$.
	\
	How could we modify the expression for form B for the case where bit position $n$
	is the most significant bit?
\end{ex}

\begin{sol}
	\
	If bit position $n$ is the most significant bit, then a shift by $(n+1)$ in form B
	results in 0, since all of the values are bits are shifted out. We can therefore
	replace that value with 0, amending form B to: \texttt{-(x<<m)}.
\end{sol}

\begin{ex}{2.40}
	For each of the following values of $K$, find ways to express \texttt{x*$K$} using
	only the specified number of operations, where we consider both additions and subtractions
	to have comparable cost. You may need to use some tricks beyond form A and B rules
	we have considered so far.
	\begin{center}
		\begin{tabular}{cccc}
			$K$ & Shifts & Add/Subs & Expression\\
			\hline
			6 & 2 & 1 & \makebox[1cm]{\hrulefill}\\
			31 & 1 & 1 & \makebox[1cm]{\hrulefill}\\
			-6 & 2 & 1 & \makebox[1cm]{\hrulefill}\\
			55 & 2 & 2 & \makebox[1cm]{\hrulefill}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	Note that $55=64-9=2^6-2^3-1$, so \texttt{x*55 = x*(64) - x*(8) - x}:
	\begin{center}
		\begin{tabular}{ccccc}
			$K$ (Decimal) Binary & & Shifts & Add/Subs & Expression\\
			\hline
			6 & 110 & 2 & 1 & \texttt{(x<<2) + (x<<1)}\\
			31 & 11111  & 1 & 1 & \texttt{(x<<5) - x}\\
			-6 & 1010 & 2 & 1 & \texttt{-(x<<3) + (x<<1)}\\
			55 & 110111 & 2 & 2 & \texttt{(x<<6) - (x<<3) - x}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.41}
	For a run of ones starting at bit position $n$ down to bit position $m$ ($n\geq m$), we
	saw that we can generate two forms of code, A and B. How should the compiler decide
	which form to use?
\end{ex}

\begin{sol}
	\
	Assuming that the cost of addition and subtraction are comparable, and that every
	left shift is comparable (regardless of the shift amount), then whenever
	$n-m\geq 2$, meaning there is at least 3 shifts in Form A, then form B should
	be preferred.
\end{sol}

\begin{ex}{2.42}
	Writ a function \texttt{div16} that returns the value \texttt{x/16} for integer
	arguments \texttt{x}. Your function should not use division, modulus, multiplication,
	any conditions (\texttt{if} or \texttt{?:}), any comparison operators (e.g., \texttt{<},
	\texttt{>}, or \texttt{==}), or any loops. You may assume that data type \texttt{int}
	is 32 bits long, and uses a two's-complement representation, and that right shifts
	are performed arithmetically.
\end{ex}

\begin{sol}
	\
	My implementation uses bit operations to see if the value is positive or negative, that
	way I can decide whether biasing is necessary. See code listing for \texttt{./42-div16/div16.c}:
	\lstinputlisting{./42-div16/div16.c}
\end{sol}

\begin{ex}{2.43}
	In the following code, we have omitted the definitions of constants \texttt{M} and \texttt{N}:
	\begin{lstlisting}
#define M	/* Mystery number 1 */
#define N	/* Mystery number 2 */
int arith(int x, int y) {
	int result = 0;
	result = x*M + y/N;	/* M and N are mystery numbers */
	return result;
}
	\end{lstlisting}
	We compiled this code for particular values of \texttt{M} and \texttt{N}. The compiler
	optimized the multiplication and division using the methods we have discussed. The
	following is a translation of the generated machine code back into C:
	
	\begin{lstlisting}
/* Translation of assembly code for arith */
int optarith(int x, int y) {
	int t = x;
	x <<= 5;
	x -= t;
	if (y<0) y += 7;
	y >>= 3;  /* Arithmetic shift */
	return x+y;
}
	\end{lstlisting}
	What are the values of \texttt{M} and \texttt{N}?
\end{ex}

\begin{sol}
	\
	Here, \texttt{x} was replaced by \texttt{x << 5 - x}, so \texttt{M = } $2^5-2^0=31$.
	Meanwhile, \texttt{y} was replaced by \texttt{y>>3} if it's positive, or by
	\texttt{(y+7)>>3} if it's negative. In this case, it means division by 8, so
	\texttt{N = } $2^3=8$.
\end{sol}

\begin{ex}{2.44}
	Assume data type \texttt{int} is 32 bits long and uses two's-complement representation
	for signed values. Right shifts are performed arithmetically for signed values and
	logically for unsigned values. The variables are declared and initialized as follows:
	\begin{lstlisting}
int x = foo();		/* Arbitrary value */
int y = bar();		/* Arbitrary value */

unsigned ux = x;
unsigned uy = y;
	\end{lstlisting}
	For each of the following C expressions, either (1) argue that it is true (evaluates to 1)
	for all vales of \texttt{x} and \texttt{y}, or (2) give values of \texttt{x} and \texttt{y}
	for which it is false (evaluates to 0):
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{(x > 0) || (x-1 < 0)}
		\item \texttt{(x \& 7) != 7 || (x << 29 < 0)}
		\item \texttt{(x * x) >= 0}
		\item \texttt{x < 0 || -x <= 0}
		\item \texttt{x > 0 || -x >= 0}
		\item \texttt{x+y == uy+ux}
		\item \texttt{x*\~{}y + uy*ux == -x}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The statement is false when \texttt{x} is $TMin_w$, the smallest number
		that may be represented with a two's-complement integer. The expression
		\texttt{x > 0} is false because its value, $-2^{w-1}$. The expression
		\texttt{x-1} causes a negative overflow, resulting in a position number,
		and making the expression \texttt{x-1 < 0} false. The overall expression
		is false. The correct way to do this test is: \texttt{x>0 || x<1}.
		\item Recall that $7_{10}=111_2$. Therefore, \texttt{(x \& 7)} sets all
		but the three least significant bits to 0. Therefore, if the expression
		\texttt{(x \& 7) != 7} is false, then it means at least one of the three
		least significant bits is 0. Meanwhile, the expression \texttt{x << 29}
		shifts all bits in \texttt{x} by 29 places to the left, meaning that
		the three least significant bits become the three most significant bits.
		Now, the way to get the expression to evaluate to false is clear:
		let \texttt{x} be any number whose value at bit position 2 is 0. The simplest
		example is 0, because \texttt{x \& 7} is 0, so the first expression is false, and
		\texttt{x << 29} is 0, so the second expression is also false. For a less trivial
		example, let \texttt{x} be $3_{10}=011$. Then \texttt{x \& 7} is 3, which is
		not equal to 7. Meanwhile, \texttt{x << 29} has a 0 as a most significant bit,
		so the result is not negative.
		\item The result is flows when the square of \texttt{x} overflows. For example,
		recall that $TMax_{32}$ is $2^{31}-1$. If \texttt{x} is $2^{16}$, then
		\texttt{x * x} is $2^{32}$, which results in positive overflow, and hence
		evaluates to a negative value, making the expression false. In general, any
		integer value of \texttt{x} such that $\texttt{x} > \sqrt{2^{31}-1}$ will cause
		overflow.
		\item This is true for all \texttt{x}. If \texttt{x} is $TMin_w$, then
		the expression is true because its value is less than 0. If \texttt{x} is
		not equal to $TMin_w$ but is negative, then the expression is true by
		\texttt{x < 0}. If \texttt{x} is non-negative, then its inverse \texttt{-x}
		is a number in the range $TMin_w\leq \texttt{x} \leq 0$, so the second expression
		is true.
		\item If \texttt{x} is $TMin_w$, then \texttt{-x} is unchanged because it is its own
		inverse in two's-complement. Therefore, both \texttt{x > 0} and \texttt{-x >= 0} is
		false.
		\item True. By definition, two's-complement addition consists of converting the arguments
		to unsigned, performing unsigned addition, and then converting to back to two's-complement.
		Hence, \texttt{x+y} and \texttt{uy+ux} have the same binary representation. Therefore,
		since \texttt{x+y} is a compared to the unsigned quantity \text{uy+ux}, its type
		gets promoted to unsigned, and the equivalent bit representations cause the expression
		to result in true.
		\item Recall that a number can be negated by inverting its bits and adding 1.
		That is, \texttt{-y == \texttt{\~{}y + 1}}. Therefore, \texttt{\~{}y == -y - 1}.
		This means that \texttt{x*\~{}y} is equivalent to \texttt{x*-y - x}. Since
		\texttt{x*y} and \texttt{ux*uy} are equal (noting that \texttt{x*y} has the same
		representation and gets cast to unsigned), the result is \texttt{-x}.
	\end{enumerate}
\end{sol}

\begin{ex}{2.45}
	Fill in the missing information in the following table.
	\begin{center}
		\begin{tabular}{ccc}
			Fractional value & Binary representation & Decimal representation \\
			\hline
			$\frac{1}{8}$ &  $0.001$ & $0.125$\\
			$\frac{3}{4}$ & \makebox[1cm]{\hrulefill}& \makebox[1cm]{\hrulefill}\\
			$\frac{5}{16}$ & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & $10.1011$ & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & $1.001$ & \makebox[1cm]{\hrulefill}\\
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $5.875$\\
			\makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $3.1875$
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	We can multiply (shift left) to
	get a whole number, convert to binary, and then shift right by the original
	amount. For example, shifting since $16=2^4$, in converting $\frac{5}{16}$
	we can shift left by 4 bits to get a value of $5_{10}$ convert to binary $101_2$,
	then then shift right by 4 bits to get $0.0101_2$.
	\begin{center}
		\def\arraystretch{1.25}%  1 is the default, change whatever you need
		\begin{tabular}{ccc}
			Fractional value & Binary representation & Decimal representation \\
			\hline
			$\frac{1}{8}$ &  $0.001$ & $0.125$\\
			$\frac{3}{4}$ & 0.11& $0.75$\\
			$\frac{5}{16}$ & 0.0101 & 0.3125\\
			$\frac{43}{16}$ & $10.1011$ & 2.6875\\
			$\frac{9}{8}$ & $1.001$ & 1.125\\
			$\frac{47}{8}$ & 101.111 & $5.875$\\
			$\frac{51}{16}$ & 11.0011 & $3.1875$
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.46}
	The imprecision of floating-point arithmetic can have disastrous effects. On
	February 25, 1991, during the first Gulf War, an American Patriot Missile battery
	in Dharan, Saudi Arabia, failed to intercept an incoming Iraqi Scud missile. The
	Scud struck an American Army barracks and killed 28 soldiers. The US General
	Accounting Office (GAO) conducted a detailed analysis of the failure and determined
	that the underlying cause was an imprecision in a numeric calculation. In this
	exercise, you will reproduce part of the GAO's analysis.
	\
	The Patriot system contains an internal clock, implemented as a counter that is
	incremented every 0.1 seconds. To determine the time in seconds, the program would
	multiply the value of this counter by a 24-bit quantity that was a fractional
	binary approximation to $\frac{1}{10}$. In particular, the binary representation
	of $\frac{1}{10}$ is the nonterminating sequence $0.000110011[0011]\cdots_2$,
	where the portion in brackets is repeating indefinitely. The program approximated
	$0.1$, as a value $x$, by considering just the first 23 bits of the sequence to
	the right of the binary point: $x=0.000 1100 1100 1100 1100 1100$. (See Problem 2.51
	for a discussion of how they could have approximated 0.1 more precisely).
	\begin{enumerate}[label=(\alph*)]
		\item What is the binary representation of $0.1-x$?
		\item What is the approximate decimal value of $0.1-x$?
		\item The clock starts at 0 when the system is first powered up, and keeps
		counting up from there. In this case, the system had been running for around
		100 hours. What was the difference between the actual time and the time
		computed by the software?
		\item The system predicts where an incoming missile will appear based on its
		velocity and the time of the last radar detection. Given that a Scud travels
		at around 2,000 meters per second, how far off was its prediction?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item In expanding the binary representation and taking the difference, the
		23 bits just to the right of the binary point cancel, and we get:
		$0.1-x$ is $0.000 0000 0000 0000 0000 0000 [0011]\cdots_2$.
		\item The decimal gives about $9.53674316\times 10^{-8}$.
		\item 100 hours is equivalent to 360,000 seconds, and since the value incremented
		every 0.1 seconds, the value must have incremented, 3,600,000 million times.
		The discrepancy is around 0.343322753926234 seconds.
		\item It was $\approx2000\times 0.34=680$ meters off.
	\end{enumerate}
\end{sol}

\begin{ex}{2.47}
	Consider a 5-bit floating-point representation based on the IEEE floating-point
	format, with one sign bit, two exponent bits ($k=2$), and two fraction bits ($n=2$).
	The exponent bias is $2^{2-1}-1=1$.
	\
	The table that follows enumerates the entire nonnegative range for this 5-bit
	floating point representation. Fill in the blank table entries using the following
	directions:
	\begin{itemize}
		\item $e$: The value represented by  considering the exponent field to be an
		unsigned integer.
		\item $E$: The value fo the exponent after biasing.
		\item $2^E$: The numeric weight of the exponent.
		\item $f$: The value of the fraction.
		\item $M$: The value of the significand.
		\item $2^E\times M$: The (unreduced) fractional value of the number.
		\item $V$: The reduced fractional value of the number.
		\item Decimal: The decimal representation of the number.
	\end{itemize}
	\begin{center}
		\begin{tabular}{ccccccccc}
			Bits  & $e$ & $E$ & $2^E$ & $f$ & $M$ & $2^E\times M$ &  $V$ & Decimal\\
			\hline
			\texttt{0 00 00} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 00 01} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 00 10} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 00 11} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 01 00} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 01 10} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 01 11} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 10 00} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 10 01} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 10 10} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 10 11} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 11 00} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 11 01} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 11 10} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
			\texttt{0 11 11} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} \\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	Recall that $+\infty$ has all 1s for the exponent field, all zeros
	for the fraction field, and $s=0$. If $s=1$, then we instead have
	$-\infty$.
	\begin{center}
		\def\arraystretch{1.25}
		\begin{tabular}{ccccccccc}
			Bits  & $e$ & $E$ & $2^E$ & $f$ & $M$ & $2^E\times M$ &  $V$ & Decimal\\
			\hline
			\texttt{0 00 00} & 0 & 0 & $1$ & 0 & $0$ & 0 & $0$ & $0.0$ \\
			
			\texttt{0 00 01} & 0 & 0 & $1$ & $\frac{1}{4}$ & $\frac{1}{4}$ & 
			$\frac{1}{4}$& $\frac{1}{4}$ & $0.25$ \\
			
			\texttt{0 00 10} & 0 & 0 & $1$ & $\frac{2}{4}$ & $\frac{1}{2}$ & 
			$\frac{1}{2}$ & $\frac{1}{2}$ & $0.50$ \\
			
			\texttt{0 00 11} & 0 & 0 & $1$ & $\frac{3}{4}$ & $\frac{3}{4}$ & 
			$\frac{3}{4}$ & $\frac{3}{4}$ & $0.75$ \\
			
			\texttt{0 01 00} & 1 & 0 & 1 & $0$ & $1$ & $1$ & $1$ & $1.0$ \\
			
			\texttt{0 01 01} & 1 & 0 & 1 & $\frac{1}{4}$ & $\frac{5}{4}$ & $\frac{5}{4}$ & $\frac{5}{4}$ & $1.25$ \\
			
			\texttt{0 01 10} & 1 & 0 & 1 & $\frac{2}{4}$ & $\frac{6}{4}$ & $\frac{6}{4}$ & 
			$\frac{3}{2}$ & $1.5$ \\
			
			\texttt{0 01 11} & 1 & 0 & 1 & $\frac{3}{4}$ & $\frac{7}{4}$ & $\frac{7}{4}$ & $\frac{7}{4}$ & $1.75$ \\
			
			\texttt{0 10 00} & 2 & 1 & $2$ & $0$ & $1$& $2$ & $2$ & $2.0$ \\
			
			\texttt{0 10 01} & 2 & 1 & $2$ & $\frac{1}{4}$ & $\frac{5}{4}$ & $\frac{10}{4}$ & $\frac{5}{2}$ & $2.5$ \\
			
			\texttt{0 10 10} & 2 & 1 & $2$ & $\frac{2}{4}$ & $\frac{6}{4}$ & $\frac{12}{4}$ & $3$ & $3.0$ \\
			
			\texttt{0 10 11} & 2 & 1 & $2$ & $\frac{3}{4}$ & $\frac{7}{4}$ & $\frac{14}{4}$ & $\frac{7}{2}$ & $3.5$ \\
			
			\texttt{0 11 00} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & $\infty$ & \makebox[1cm]{\hrulefill} \\
			
			\texttt{0 11 01} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & NaN & \makebox[1cm]{\hrulefill} \\
			
			\texttt{0 11 10} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & NaN & \makebox[1cm]{\hrulefill} \\
			
			\texttt{0 11 11} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & NaN & \makebox[1cm]{\hrulefill} \\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.48}
	As mentioned in Problem 2.6, the integer $3,510,593$ has a hexadecimal representation
	\texttt{0x00359141}, while the single-precision representation floating-point
	number  $3,510,593.0$ has hexadecimal representation \texttt{0x4A564504}. Derive
	this floating-point representation and explain the correlation between the bits of the
	integer and floating-point representations.
\end{ex}

\begin{sol}
	\
	First we convert the hexadecimal to binary:
	\begin{align*}
		\texttt{0000 0000 0011 0101 1001 0001 0100 0001}
	\end{align*}
	Then we shift a binary point starting from the right until the leading 1,
	a total of 21 places:
	\begin{align*}
		\texttt{1.101011001000101000001}\times 2^{21}
	\end{align*}
	We drop the leading 1, and add sufficient zeros to the end to ensure there are 23
	fractional bits:
	\begin{align*}
		f=\texttt{10101100100010100000100}
	\end{align*}
	Then we bias the exponent by adding $2^{8-1}-1=2^7-1=127$ to the $21$ exponent,
	giving $148$:
	\begin{align*}
		E=148_{10}=10010100_2
	\end{align*}
	Then since the number is positive, the sign bit is $s=0$. The full binary representation
	is now:
	\begin{align*}
		\texttt{0 10010100 10101100100010100000100}
	\end{align*}
	We can convert it to hexadecimal by grouping bits into groups of 4:
	\begin{align*}
		\texttt{0100 1010 0101 0110 0100 0101 0000 0100}\\
	\end{align*}
	which has hexadecimal representation \texttt{0x4A56504}. To see the relationship
	between the two binary representations, we shift them relative to each other:
	\begin{align*}
		00&000000001\textbf{101011001000101000001}\\
		  &010010100\textbf{101011001000101000001}00
	\end{align*}
	The lower significant bits of the integer match the high order bits of the fraction
	part of the floating point representation, except that the implicit leading 1 is not
	included in the floating point representation.
\end{sol}

\begin{ex}{2.49}
	\
	\begin{enumerate}[label=(\alph*)]
		\item For a floating-point format with an $n$-bit fraction, give a formula
		for the smallest positive integer that cannot be represented exactly (because
		it would require an $(n+1)$-bit fraction to be exact). Assume the exponent
		field size $k$ is large enough that the range of representable exponents does
		not provide a limitation for this problem.
		\item What is the numeric value of this integer for single-precision format
		$(n=23)$?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The number would require moving the binary point to the left $n+1$ times.
		For example, $1011$ requires moving the decimal left 3 times, so it can be
		represented by a 3-bit fraction, as in $1.011\times 2^3$. If we have an
		$n$-bit fraction, then we have $1.f_{n-1},f_{n-2}\cdots f_1f_{0}\times 2^{n}$ because
		of the implicit leading 1. If we have, say
		\begin{align*}
			1f_{n-1}f_{n-2}\cdots f_1f_0b
		\end{align*}
		where $b$ is an $(n+1)$-th bit after the leading 1, then re-writing this requires
		\begin{align*}
			1.f_{n-1}f_{n-2}\cdots f_1f_0b\times 2^{n+1}
		\end{align*}
		Since there are only $n+1$ fraction bits available, we must drop $b$, and hence,
		approximate the exact number by $1.f_{n-1}f_{n-2}\cdots f_1f_0\times 2^{n+1}$.
		If $b$ is 0, then the approximation matches the exact value. If $b$ is 1, then
		the approximation is not exact. Hence, the formula for the smallest value that
		cannot be represented exactly requires $b=1$. We make it as small as possible
		by setting the rest of the fraction bits to 0:
		\begin{align*}
			1.00\cdots 01\times 2^{n+1}
		\end{align*}
		so the smallest number that cannot be represented is $2^{n+1}+1$.
		\item With $n=23$, we have $2^{24}+1=16,777,217_{10}$.
	\end{enumerate}
\end{sol}

\begin{ex}{2.50}
	Show how the following binary fractional values would be rounded to the nearest
	half (1 bit to the right of the binary point), according to the round-to-even
	rule. In each case, show the numeric values, both before and after rounding.
	\begin{enumerate}[label=(\alph*)]
		\item $10.010_2$
		\item $10.011_2$
		\item $10.110_2$
		\item $11.001_2$
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	Recall that if we have a bit pattern of the form $XX\cdots X.YY\cdots Y100\cdots$,
	where $X$ and $Y$ denote arbitrary bit values with the rightmost $Y$ being the
	position to which we wish to round, then only bit patterns of this form denote
	values that are halfway between two possible results (with the $100\cdots$ after $Y$).
	\begin{enumerate}[label=(\alph*)]
		\item The given number is $2\frac{1}{4}$. We see $10$ after the half, so
		we are halfway between two values, which means we round-to-even, that is, we
		round-to-even by rounding down, to retain the rightmost 0, and hence get
		an ``even" result: $10.0_2$. The result afterwards is $2_{10}$. As you can 
		see, $2\frac{1}{4}$ is halfway between $2$ and $2\frac{1}{2}$.
		\item The starting value is $2.375$. This time we do not have a number
		halfway between values. We round up and get $10.100_2$, or equivalently, $2.5_{10}$.
		\item The starting value is $2.75_{10}$. Here we have $10_2$ after the 1 on the
		half position, so we round-to-even by rounding up so that we end up with an
		``even result". We get $11.000_2$ and obtain $3.0_{10}$.
		\item The starting value is $3.125_{10}$. It is not halfway between two
		numbers so we round down towards $11.0_2$, or equivalently, $3.0$
	\end{enumerate}
\end{sol}

\begin{ex}{2.51}
	We saw in Problem 2.46 that the Patriot missile software approximated 0.1 as
	$x=0.00011001100110011001100_2$. Suppose instead that they had used IEEE round-to-even
	mode to determine an approximation $x'$ to 0.1 with 23 bits to the right of the
	binary point.
	\begin{enumerate}[label=(\alph*)]
		\item What is the binary representation of $x'$?
		\item What is the approximate decimal value of $x'-0.1$?
		\item How far off would the computed clock have been after 100 hours of
		operation?
		\item How far off would the program's prediction of the position of the
		Scud missile have been?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Recall that $0.1$ has a non-terminating binary representation
		$0.000110011[0011]\cdots_2$. Below we show the number with 23 bits
		after binary point as bold:
		\[
		0.\textbf{00011001100110011001100}1100[1100]\cdots
		\]
		Since it is not halfway between two values, and the value right of the 23rd
		fractional bit is 1, we round up and get
		\begin{align*}
			x'=0.00011001100110011001101_2
		\end{align*}
		\item The value of $x'-0.1$ involves evaluating the subtraction
		\begin{align*}
			&0.\textbf{00011001100110011001101}_2-0.\textbf{00011001100110011001100}1100[1100]\cdots_2\\
			&=0.\textbf{00000000000000000000001}_2-0.\textbf{0000000000000000000000}[1100]\cdots_2
		\end{align*}
		We can replace the sequence terminating in 1 at the 23rd place with a non-terminating
		sequence with all 1s starting at the 24th place. After subtracting, we get
		\begin{align*}
			0.\textbf{00000000000000000000000}00[1100]\cdots_2
		\end{align*}
		Looking back at the original representation of 0.1, this is a shift of it by 22 places
		to the right. Therefore, the value of $x'-1$ is
		$\frac{1}{10}\times 2^{-22}\approx 2.38\times 10^{-8}$.
		\item Since 100 hours is $100\cdot 60\cdot 60=360,000$ seconds, and it increments once
		every $0.1$ seconds, it means that it incremented $3,600,000$ times, so
		$2.38\times 10^{-8}\times 3,600,000\approx 0.0858$.
		\item The discrepancy would have been approximately $0.858\cdot 2000\approx 172$ meters.
	\end{enumerate}
\end{sol}

\begin{ex}{2.52}
	Consider the following two 7-bit floating-point representations based on the IEEE
	floating-point format. Neither has a sign bit --- they can only represent non-negative
	numbers.
	\begin{enumerate}
		\item Format A:
		\begin{itemize}
			\item There are $k=3$ exponent bits. The exponent bias is 3.
			\item There are $n=4$ fraction bits.
		\end{itemize}
		\item Format B:
		\begin{itemize}
			\item There are $k=4$ exponent bits. The exponent bias is 7.
			\item There are $n=3$ fraction bits.
		\end{itemize}
	\end{enumerate}
	Below, you are given some bit patterns in format A, and your task is to convert them
	to the closest value in format B. If necessary, you should apply the round-to-even
	rounding rule. In addition, give the values of numbers given by the format A and format
	B bit patterns. Give these as whole numbers (e.g., 17) or as fractions (e.g., 17/64).
	\begin{center}
		\begin{tabular}{cc|cc}
			\multicolumn{2}{c}{Format A} & \multicolumn{2}{c}{Format B}\\
			\hline
			Bits & Value & Bits & Value\\
			\hline
			\texttt{011 0000} & 1 & \texttt{0111 000} & 1 \\
			
			\texttt{101 1110} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			\texttt{010 1001} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			\texttt{110 1111} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
			
			\texttt{000 0001} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill} & \makebox[1cm]{\hrulefill}\\
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	First we fill the entries under Format A.
	\begin{itemize}
		\item \texttt{101 1110}: The exponent
		is $e=\texttt{101}_2$, so $e=5$, and it is a normalized value so $E=e-Bias$,
		or $E=5-3=2$. Then $f=\texttt{0.1110}_2=\frac{7}{8}$, so $M=1+f=\frac{15}{8}$.
		The value is $2^E\cdot M=2^{2}\cdot \frac{15}{8}=\frac{15}{2}$.
		\item \texttt{010 1001}: we have $e=010_2=2_{10}$ and $f=0.1001_2=\frac{9}{16}$.
		Now $M=1+f=\frac{25}{16}$, and $E=2-3=-1$, so 
		$V=2^E\times M=2^{-1}\cdot \frac{25}{16}=\frac{25}{32}$.
		\item \texttt{110 1111}: Here $e=110_2=6_{10}$ and $f=0.1111_2=\frac{15}{16}$.
		Now $M=1+f=\frac{31}{16}$ and $E=6-3=3$, so $V=2^{3}\cdot \frac{31}{16}=\frac{31}{2}$.
		\item Since the exponent is all 0s, this is a denormalized value. The fraction
		is $f=0.0001_2=\frac{1}{16}$, and $M=f$. Since $e=0$, we have $E=1-bias=1-3=-2$,
		so $V=2^{E}\cdot M=2^{-2}\cdot \frac{1}{16}=\frac{1}{64}$. 
	\end{itemize}
	We now attempt to convert them to format B:
	\begin{itemize}
		\item $\frac{15}{2}$: The representation for $15$ is $1111.0_2$, so by shifting
		the binary place right we obtain the representation for $\frac{15}{2}$, namely,
		$111.10_2=111.1_2=1.111\times 2^2$. The exponent is $2$, so we add the bias of
		$7$ to get $e=9_{10}=1001_2$. We drop the leading 1, and we end up with
		\[
		\texttt{0 1001 111}
		\]
		\item $\frac{25}{32}$: The representation of $25$ is $11001_2$. Since $\frac{1}{32}$
		is $2^{-5}$, we shift left 5 times to get $0.11001_2=1.1001\times 2^{-1}$. Since
		we only have 3 fraction bits available, we must round $1.1001$ to even, so
		we round down to $1.100_2$. Hence, we have
		\[\frac{25}{32}\approx 1.100\cdot 2^{-1}=\frac{1}{2}+\frac{1}{4}=\frac{3}{4}\]
		We add the bias of $7$ to get $e=-1+7=6=0110_2$. We drop the leading 1, and end up with
		\[
		\texttt{0 0110 100}_2
		\]
		\item $\frac{31}{2}$: The representation of $31$ is $11111_2$. Since $\frac{1}{2}=2^{-1}$,
		we shift the binary point left 1 time to get $1111.1_2$. We shift left until there is only
		one digit before the binary point, yielding $1.1111_2\cdot 2^{3}$. Since we only have
		3 fraction bits, we must round $1.1111_2$, which rounds up to $10.000_2$. Hence,
		we now have
		\[
		\frac{31}{2}\approx 10.000_2\cdot 2^{3}=1.000_2\cdot 2^{4}=16
		\]
		We add the bias of $7$ to get $e=4+7=11=1011_2$ We drop the leading 1, and end
		up with
		\[
		\texttt{0 1011 000}_2
		\]
		\item $\frac{1}{64}$: This value is $2^{-6}$, so the binary representation
		is $1.0\times 2^{-6}$. Here, $e=-6+7=1$, and after dropping the leading 1, we get
		\[
		\texttt{0 0001 000}
		\]
	\end{itemize}
	The table below summarizes all values.
	\begin{center}
		\def\arraystretch{1.25}
		\begin{tabular}{cc|cc}
			\multicolumn{2}{c}{Format A} & \multicolumn{2}{c}{Format B}\\
			\hline
			Bits & Value & Bits & Value\\
			\hline
			\texttt{011 0000} & 1 & \texttt{0111 000} & 1 \\
			
			\texttt{101 1110} & $\frac{15}{2}$ & \texttt{0 1001 111} & $\frac{15}{2}$\\
			
			\texttt{010 1001} & $\frac{25}{32}$ & \texttt{0 0110 100} & $\frac{3}{4}$\\
			
			\texttt{110 1111} & $\frac{31}{2}$ & \texttt{0 1011 000} & 16\\
			
			\texttt{000 0001} & $\frac{1}{64}$ & \texttt{0 0001 000} & $\frac{1}{64}$\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{2.53}
	Fill in the following macro definitions to generate the double-precision values $+\infty$,
	$-\infty$, and $-0$:
	
	\begin{lstlisting}
#define POS_INFINITY
#define NEG_INFINITY
#define NEG_ZERO
	\end{lstlisting}
	You cannot use any include files (such as \texttt{math.h}), but you can make use of
	the fact that the largest finite number that can be represented with double precision
	is around $1.8\times 10^{308}$.
\end{ex}

\begin{sol}
	\
	See code listing \texttt{./53-special-doubles/special.h}.
	\lstinputlisting{./53-special-doubles/special.h}
\end{sol}

\begin{ex}{2.54}
	Assume variables \texttt{x}, \texttt{f}, and \texttt{d} are of type \texttt{int},
	\texttt{float}, and \texttt{double}, respectively. Their values are arbitrary,
	except that neither \texttt{f} nor \texttt{d} equals $+\infty, -\infty$, or
	\emph{NaN}. For each of the following C expressions, either argue that it will
	always be true (i.e., evaluates to 1) or give a value for the variables such that
	it is not true (i.e., evaluates to 0).
	\begin{enumerate}[label=(\alph*)]
		\item \texttt{x == (int)(double) x}
		\item \texttt{x == (int)(float) x}
		\item \texttt{d == (double)(float) d}
		\item \texttt{f == (float)(double) f}
		\item \texttt{f == -(-f)}
		\item \texttt{1.0/2 == 1/2.0}
		\item \texttt{d*d >= 0.0}
		\item \texttt{(f+d)-f == d}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item Since \texttt{x} is an \texttt{int}, its value is preserved when cast to
		a \texttt{double}, and back to an \texttt{int}. This expression is always true.
		\item Due to the limited precision of \texttt{float}, rounding may occur. For
		example, we explored how the smallest value that cannot be represented by a
		\texttt{float} is $2^{24}+1$. If \texttt{int} is 32-bit, then its values
		ranged from $-2^{-31}$ to $2^{31}-1$, so it can attain $2^{24}+1$ as a value.
		In the event this happens, the rounding alters the value of \texttt{x},
		and so will the cast back from \texttt{float} to \texttt{int}. The expression
		is will be false.
		\item If \texttt{d} is a value beyond $3.4\times 10^{38}$, then cast to a
		\texttt{float} will overflow to $+\infty$. The expression leads to false.
		\item This is always true because \texttt{d} can hold any \texttt{float}.
		Therefore when cast back to \texttt{float}, it remains unchanged.
		\item This is always true; the sign bit flips.
		\item True because 2 is cast to a \texttt{float} in \texttt{1.0/2} and 1 is
		cast to a \texttt{float} in \texttt{1/2.0}.
		\item Since \texttt{int} to \texttt{float} cannot overflow, we are assured
		that the number will be non-negative.
		\item  Let \texttt{f} be $3.4e38$, the largest normalized value, and let
		\texttt{d} be 1. Then \texttt{f + d} overflows to $+\infty$, and now
		$\infty-\texttt{f}$ does not equal \texttt{d}.
	\end{enumerate}
\end{sol}

\begin{ex}{2.55}
	Compile and run the sample code that uses \texttt{show\_bytes} (file
	\texttt{show-bytes.c}) on different machines to which you have access.
	Determine the byte ordering used by these machines.
\end{ex}

\begin{sol}
	See the \texttt{./55-show-bytes/README.md}.
\end{sol}


\end{document}