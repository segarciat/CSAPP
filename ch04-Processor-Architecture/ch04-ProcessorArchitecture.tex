%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Welcome to the MAT320 Homework template on Overleaf -- just edit your
% LaTeX on the left, and we'll compile it for you on the right.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --------------------------------------------------------------
% Based on a homework template by Dana Ernst.
% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------

\documentclass[12pt]{article}

\usepackage{graphicx}
\graphicspath{{./images/}}
\usepackage{textcomp} % cent symbol, such as \textcent
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{cancel}
\usepackage{mathtools} % ceiling function
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
% https://tex.stackexchange.com/questions/146306/how-to-make-horizontal-lists
\usepackage[inline]{enumitem} % allows using letters in enumerate list environment

% source: https://stackoverflow.com/questions/3175105/inserting-code-in-this-latex-document-with-indentation

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=C, % language for code listing
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=4
}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

\newenvironment{ex}[2][Exercise]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\newenvironment{sol}[1][Solution]{\begin{trivlist}
		\item[\hskip \labelsep {\bfseries #1:}]}{\end{trivlist}}


\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

\noindent Sergio Garcia Tapia \hfill

\noindent{\small Computer Systems: A Programmer's Perspective, by Bryant and O'Hallaron} \hfill

\noindent{\small Chapter 4: Processor Architecture}
\noindent\today

\subsection*{Practice Problems}

\begin{ex}{4.1}
	Determine the byte encoding of the Y86-64 instruction sequence that follows.
	The line \texttt{.pos 0x100} indicates that the starting address of the object
	code should be \texttt{0x100}.
	
	\begin{lstlisting}[language={}]
.pos 0x100	# Start code at address 0x100
	irmovq	$15,%rbx
	rrmovq	%rbx,%rcx
loop:
	rmmovq	%rcx,-3(%rbx)
	addq	%rbx,%rcsx
	jmp		loop
	\end{lstlisting}
\end{ex}

\begin{sol}
	\
	The \texttt{irmovq} instruction has a code part of \texttt{0x3}
	and control part of \texttt{0x0}, which we put together as
	\texttt{0x30}. Its instruction format does not use a source register, and
	a \texttt{0x15} indicates; the destination register \texttt{\%rbx} is
	encoded as \texttt{0x3}. Finally, \text{\$15} is hexadecimal \texttt{0xf},
	which after extending to 64 bits gives \texttt{0x000000000000000f};
	we reserve the byte orders to get \texttt{0f00000000000000} for the
	encoding of the instruction. Altogether this  takes up 10 bytes, so
	the next instruction has address \texttt{0x10A}, an offset of \texttt{.pos}
	by 10.
	
	\
	The \texttt{rrmovq} is encodded as \texttt{0x20}. Its source register
	is \texttt{\%rbx} with encoding \texttt{0x3}, and its destination
	\texttt{\%rcx} with encoding \texttt{0x1}. Overall, this instruction
	takes up \texttt{2 bytes}, so the next instruction has address \texttt{0x10C}.
	
	\
	The \texttt{loop} is a placeholder for an address, so it will be
	replaced by the address \texttt{0x1c}.
	
	\
	The \texttt{rmmovq} has encoding \texttt{0x40}. Its source register is 
	\texttt{\%rcx} with \texttt{0x1}, and the destination is a memory
	reference with base address given by register \texttt{\%rbx} with
	encoding \texttt{0x3}, and offset \texttt{-3}, which is given by
	\texttt{0xfffffffffffffffd}. We reverse it to \texttt{0xfdffffffffffffff}
	for the instruction encoding. This instruction takes up 10 bytes, so the
	next one starts at address \texttt{0x116}.
	
	\
	The \texttt{addq} has encoding \texttt{0x60}. Its source and destination
	registers have encodings \texttt{0x3} and \texttt{0x1}, respectively.
	The whole instruction takes up 2 bytes, so the next starting address
	is \texttt{0x118}.
	
	\
	The \texttt{jmp} is encoded as \texttt{0x70}, and \texttt{loop} is
	replaced by the address \texttt{0x010c}, whose bytes we reverse to
	\texttt{0c01000000000000}. The entire translation is:
	\begin{lstlisting}[language={}]
0x100: 30 f3 0f00000000000000
0x10A: 20 31
0x10C: 40 13 fdffffffffffffff
0x116: 60 31
0x118: 70 0c01000000000000
	\end{lstlisting}
\end{sol}

\begin{ex}{4.2}
	For each byte sequence listed, determine the Y86-64 instruction
	sequence it encodes. IF there is some invalid byte in the sequence,
	show the instruction sequence up to that point, and indicate where
	the invalid byte occurs. For each sequence, we show the starting
	address then a colon, and then the byte sequence.
	\begin{enumerate}[label=(\alph*)]
		\item
			\texttt{0x100: 30f3fcffffffffffffff40630008000000000000}
		
		\item 
			\texttt{0x200: a06f800c020000000000000030f30a00000000000000}
		\item 
			\texttt{0x300: 5054070000000000000010f0b01f}
		\item 
			\texttt{0x400: 611373000400000000000000}
		\item 
			\texttt{0x500: 6362a0f0}
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The initial \texttt{30} makes this a \texttt{irmovq}
		instruction. The following \texttt{f} represents that a source
		is not needed, and the \texttt{3} that the destination register
		is \texttt{\%rbx}. The 8-byte value is \texttt{fcffffffffffffff},
		which is \texttt{-4} in decimal. This instruction takes up 10 bytes.
		
		The \texttt{40} that follows means
		we have a \texttt{rmmovq} instruction expecting two registers an
		an offset. The \texttt{6} means the source is \texttt{\%rsi},
		and the \texttt{3} , means the destination if \texttt{\%rbx}.
		The \texttt{00080000000000} reverses to \texttt{00000000008000},
		completing the instruction and taking up 9 bytes.
		The last two \texttt{00} indicate the \texttt{halt} instruction.
		Altogether, we have:
		\begin{lstlisting}[language={}]
0x100: irmovq -4,%rbx
0x10C: rmmovq %rsi0x800(%rbx)
0x115: halt
		\end{lstlisting}
		\item The \texttt{a0} makes this a \texttt{pushq} instruction,
		the following \texttt{6} is source register \texttt{\%rsi}, and the
		following \texttt{f} that there is no destination register.
		
		Starting at \texttt{80}, we have the start of the encoding for
		a \texttt{call} instruction. The destination is encoded by
		the 8 bytes \texttt{0c02000000000000}, which we reverse to
		\texttt{000000000000020c}, or simply \texttt{0x020c}.
		
		The next \texttt{0x00} indicates a \texttt{halt} instruction.
		
		\
		The next \texttt{30} means we are parsing a \texttt{irmovq} command,
		with no source register instructed by the \texttt{f} and destination
		register \texttt{3} which is \texttt{\%rbx}. The constant in reverse
		is given by \texttt{0x0a00000000000000}, so we reverse it to
		\texttt{000000000000000a}. The program is:
		\begin{lstlisting}[language={}]
0x200:	pushq %rsi
0x202:	call 0x000000000000020c
0x20b:	halt
0x20c:	irmovq $10,%rbx
		\end{lstlisting} 
		\item The initial \texttt{50} makes this a \texttt{mrmovq}
		instruction. The following byte \texttt{54} means that the
		source and destination registers are \texttt{\%rsp} and
		\texttt{\%rbp}, respectively. The source is a memory reference
		with a an offset given by the following 8 bytes\texttt{0x0700000000000000},
		which we reverse to \texttt{0x0000000000000007}, or decimal \texttt{7}.
		
		\
		The \texttt{10} means we have a \texttt{nop}. The \texttt{f0}
		is an invalid byte. \texttt{b01f} means \texttt{popq} \texttt{\%rcx}.
		Altogether we have:
		\begin{lstlisting}[language={}]
0x300: mrmovq 7(%rsp),%rbp
0x30a: nop
0x30b: # invalid
0x30c: popq %rcx
		\end{lstlisting}
		
	
		\item The \texttt{61} makes this a \texttt{subq} instruction,
		with source register \texttt{\%rcx} and destination register
		\texttt{\%rbx}, as given by \texttt{0x13}. The instruction is
		\texttt{subq \%rcx, \%rbx}.
		
		000400000000000000
		The \texttt{73} that follows indicates a \texttt{je} instruction,
		followed by the reversed constant address \texttt{0004000000000000},
		which we reverse to \texttt{0000000000000400}. The last \texttt{00}
		indicates a \texttt{halt}:
		\begin{lstlisting}[language={}]
0x400: subq %rcx, %rbx
0x402: je 0x0000000000000400
0x40b: halt
		\end{lstlisting}
		\item The \texttt{63} makes this a \texttt{xorq} instruction,
		with source register \texttt{\%rsi} and destination register
		\texttt{\%rdx}, as indicated by the \texttt{62}. The instruction
		is \texttt{xorq \%rsi, \%rdx}. We then have \texttt{a0} for
		a \texttt{pushq} instruction, but the \texttt{f} says that
		there is no source register, which is invalid:
		\begin{lstlisting}[language={}]
0x500: xorq %rsi, %rdx
0x502: pushq f0 # invalid byte register f0
		\end{lstlisting}
	\end{enumerate}
\end{sol}

\begin{ex}{4.3}
	One common pattern in machine-level programs is to add a constant value to
	a register. With the Y86-64 presented thus far, this requires first using
	an \texttt{irmovq} to set a register to the constant, then an \texttt{addq}
	instruction to add this value to the destination register. Suppose we now
	want to add a new instruction \texttt{iaddq} with the following format:
	\begin{center}
		\begin{tabular}{l|l|l|l|l|llllllll}
			Byte & \texttt{0} & {} & \texttt{1} & {} & \texttt{2} & \texttt{3} & \texttt{4} & \texttt{5} & \texttt{6} & \texttt{7} & \texttt{8} & \texttt{9}\\
			\hline
			\texttt{iddq V, rB} & \texttt{C} & \texttt{0} & \texttt{F} & \texttt{rB} & \multicolumn{8}{c}{\texttt{V}}\\
			\hline
		\end{tabular}
	\end{center}
	This instruction adds the constant value \texttt{V} to register \texttt{rB}.
	\
	
	Re-write the Y86-64 \texttt{sum} function of Figure 4.6 to make use of the
	\texttt{iaddq} instruction. In the original version, we dedicate registers
	\texttt{\%r8} and \texttt{\%r9} to hold constant values. Now, we can avoid
	using those registers altogether.
\end{ex}

\begin{sol}
	\
	\begin{lstlisting}[language={}]
	long sum(long *start, long count)
	start in %rdi, count in %rsi
sum:
	xorq	%rax,%rax	# sum = 0
	andq	%rsi,%rsi	# Set condition code
	jmp test
loop:
	mrmovq	(%rdi),%r10	# Get *start
	addq	%r10,%rax	# Add to sum
	iaddq	$1,%rdi		# start++
	iaddq	$-1,%rsi	# count--, set condition code
test:
	jne		loop		# Stop when 0
	ret
	\end{lstlisting}
\end{sol}

\begin{ex}{4.4}
	Write Y86-64 code to implement a recursive sum function \texttt{rsum},
	based on the following code:
	
	\begin{lstlisting}
long rsum(long *start, long count)
{
	if (count <= 0)
		return 0;
	return *start + rsum(start+1, coount-1);
}
	\end{lstlisting}
	Use the same argument passing and register saving conventions as x86-64
	code does. You might find it helpful to compile the C code on an
	x86-64 machine and then translate the instructions to Y86-64.
\end{ex}

\begin{sol}
	I compiled \texttt{rsum.c} with the flags: \texttt{gcc -S -O1 rsum.c},
	and got the following x86-64 output:
	\lstinputlisting[language={}]{./04-recursive-sum/rsum.s}
	I used it as the based for the following Y86-64 code, which I have annotated:
	\begin{lstlisting}[language={}]
	long rsum(long *start, long count)
	start in %rdi, count in %rsi
rsum:
	irmovq	$0,%rax		# Set return value to 0
	iaddq	$0,%rsi		# Set condition code
	jle		.L5:		# if <= 0 goto .L5
	pushq	%rbx		# Callee-saved register
	rrmovq	%rdi,%rbx	# save start (memory address)
	iaddq	$1,%rsi		# count--
	iaddq	$8,%rdi		# start++ (add 8 bytes to pointer, pointing to next)
	call rsum			# rsum(start++, count--)
	mrmovq	(%rbx),%rax	# add *start to return value
	popq	%rbx		# restore register
	ret					# return
.L5:					
	ret					# return
	\end{lstlisting}	
\end{sol}

\begin{ex}{4.5}
	Modify the Y86-64 code for the \texttt{sum} function (Figure 4.6) to
	implement a function \texttt{absSum} that computes the sum of absolute
	values of an array. Use a \emph{conditional jump} instruction within your
	inner loop.
\end{ex}

\begin{sol}
	\
	My implementation uses the fact that if \texttt{x} is negative, then
	\texttt{\~{}x + 1} negates it, making it positive.
	\begin{lstlisting}[language={}]
	long absSum(long *start, long count)
	start in %rdi, count in %rsi
absSum:
	irmovq	$-1,%r11		# Constant -1
	xorq	%rax,%rax	# sum = 0
	andq	%rsi,%rsi	# Set condition code
	jmp test
loop:
	mrmovq	(%rdi),%r10	# Get *start
	iadd0	$0,%r10		# Set condition code
	jge		.nonneg		# if >= goto .nonneg
	xorq	%r11,%r10	# -1 XOR *start
	iaddq	$1,%r10		# finish computing abs(*start)
.nonneg:
	addq	%r10,%rax	# Add to sum
	iaddq	$1,%rdi		# start++
	iaddq	$-1,%rsi	# count--, set condition code
test:
	jne		loop		# Stop when 0
	ret
	\end{lstlisting}
\end{sol}

\begin{ex}{4.6}
	Modify the Y86-64 code for the \texttt{sum} function (Figure 4.6) to
	implement a function \texttt{absSum} that computes the sum of absolute
	values of an array. Use a \emph{conditional move} instruction within your
	inner loop.
\end{ex}

\begin{sol}
	\
	My implementation uses the fact that if \texttt{x} is negative, then
	\texttt{\~{}x + 1} negates it, making it positive.
\begin{lstlisting}[language={}]
		long absSum(long *start, long count)
		start in %rdi, count in %rsi
absSum:
		irmovq	$-1,%r11		# Constant -1
		xorq	%rax,%rax	# sum = 0
		andq	%rsi,%rsi	# Set condition code
		jmp test
loop:
		mrmovq	(%rdi),%r10	# Get *start
		xorq	%r10,%r11	# -1 XOR *start
		iaddq	$1,%r11		# Finishes computing -*start
		cmovge	%r11,%r10	# if %r11 is positive, then %r10 was negative
		addq	%r10,%rax	# Add to sum
		iaddq	$1,%rdi		# start++
		iaddq	$-1,%rsi	# count--, set condition code
		test:
		jne		loop		# Stop when 0
		ret
	\end{lstlisting}
\end{sol}

\begin{ex}{4.7}
	Let us determine the behavior of the instruction \texttt{pushq \%rsp}
	for an x86-64 processor. We could try reading the Intel documentation
	on this instruction, but a simpler approach is to conduct an experiment
	on an actual machine. The C compiler would not normally generate this
	instruction, so we must use hand-generated assembly code for this task.
	Here is a test function we have written (Web Aside ASM:EASM on page
	178 describes how to write programs that combine C code with handwritten
	assembly code):
	\begin{lstlisting}[language={}]
	.text
.global pushtest
pushtest:
	movq	%rsp,%rax	# Copy stack pointer
	pushq	%rsp		# Push stack pointer
	popq	%rdx		# Pop it back
	subq	%rdx,%rax	# Return 0 or 4
	ret
	\end{lstlisting}
	In our experiments, we find that \texttt{pushtest} always returns 0.
	What does this imply about the behavior of the instruction
	\texttt{pushq \%rsp} under x86-64?
\end{ex}

\begin{sol}
	\
	The first instruction stores the old value of the pointer in \texttt{\%rax}
	Since the output is always 0, this means that \texttt{pushq \%rsp}
	pushes the original value of \texttt{\%rsp}.
\end{sol}

\begin{ex}{4.8}
	The following assembly-code function lets us determine the behavior of
	\texttt{popq \%rsp} on x86-64:
	\begin{lstlisting}[language={}]
	.text
.global poptest
poptest:
	movq	%rsp,%rdi	# Save stack pointer
	pushq	$0xabcd		# Push test value
	popq	%rsp		# Pop to stack pointer
	movq	%rsp,%rax	# Set popped value as returned value
	movq	%rdi,%rsp	# Restore stack pointer
	ret
	\end{lstlisting}
	We find this function always returns \texttt{0xabcd}. What does this imply
	about the behavior of \texttt{pop \%rsp}? What other Y86-64 instruction would
	have the same behavior?
\end{ex}

\begin{sol}
	\
	It implies that \texttt{pop \%rsp} sets the stack pointer to the
	value read from memory. We could use \texttt{mrmovq} to read this
	value instead. This would give the correct return value; however,
	the value we pushed would remain on the stack, and would therefore
	point to a lower address than the \texttt{popq} approach.
\end{sol}

\begin{ex}{4.9}
	Write an HCL expression for a signal \texttt{xor}, equal to the
	\emph{exclusive-or} of inputs \texttt{a} and \texttt{b}. What is
	the relation between the signals \texttt{xor} and \texttt{eq} defined
	above?
\end{ex}

\begin{sol}
	\
	If we let $\oplus$ be the XOR symbol, we can define it to mean
	\begin{center}
	\texttt{a $\oplus$ b} = (\texttt{a \&\& !b}) \texttt{||} (\texttt{!a \&\& b})	
	\end{center}
	\texttt{xor} and \texttt{eq} are negations of one another, because
	\texttt{xor} is 1 when \texttt{a} and \texttt{b} are distinct, and 0
	otherwise. Meanwhile, \texttt{eq} is 1 when \texttt{a} and \texttt{b}
	are equal, and 0 otherwise.
\end{sol}

\begin{ex}{4.10}
	Suppose you want to implement a word-level equality circuit using the
	\emph{EXCLUSIVE-OR} circuits from Problem 4.9 rather than bit-level
	equality circuits. Design such a circuit for a 64-bit \emph{EXCLUSIVE-OR}
	circuits and two additional logic gates.
\end{ex}

\begin{sol}
	\
	The circuit will have two 64-bit buses \texttt{A} and \texttt{B} as inputs.
	We use a total of 64 bit-level \emph{EXCLUSIVE-OR} circuits operating in parallel.
	If \emph{any} of them outputs 1, then the two inputs are distinct, and the
	overall output should be 0. If all of the bit-level XORs output 0, then the
	circuit should output 1. We therefore feed the outputs of of the bit-level XORs
	into a 64-bit OR gate, and pass its output through an inverter.
\end{sol}

\begin{ex}{4.11}
	The HCL code for computing the minimum of three words contains four comparison
	expressions of th form $X$ <= $Y$. Rewrite the code to compute the same result,
	but using only three comparisons.
\end{ex}

\begin{sol}
	\
	The given HCL was:
	\begin{lstlisting}[language={}]
word Min3 = [
	A <= B && A <= C: A;
	B <= A && B <= C: B;
	1				: C;
];
	\end{lstlisting}
	If the first inequality fails, then \texttt{A} is not the minimum.
	Therefore either \texttt{B} or \texttt{C} is the minimum. This means
	it's enough to check that \texttt{B} <= C:
		\begin{lstlisting}[language={}]
word Min3 = [
	A <= B && A <= C: A;
	B <= C			: B;
	1				: C;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.12}
	Write HCL code describing a circuit that for word inputs \texttt{A}, \texttt{B},
	and \texttt{C} selects the \emph{median} of the three values. That is, the output
	equals the word lying between the minimum and the maximum of the three inputs.
\end{ex}

\begin{sol}
	\
	\begin{lstlisting}[language={}]
word Median = [
	A <= B && C <= A || (A <= C && B <= A): A;
	A <= B && 
	1				: C;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.13}
	Fill in the right-hand column of the following table to the describe the processing
	of the \texttt{irmovq} on line 4 of the object code in Figure 4.17:
	\begin{center}
		\begin{tabular}{ccc}
			\multicolumn{2}{r}{Generic} & Specific\\
			Stage & \texttt{irmovq V, rB} & \texttt{irmovq \$128,\%rsp}\\
			\hline
			Fetch 	&	icode:ifun $\leftarrow$ $\text{M}_1\text{[PC]}$ & {}\\
			{}		&	\texttt{rA:rB} $\leftarrow\text{M}_1\text{[PC + 1]}$ &\\
			{}		&	\texttt{valC} $\leftarrow$ $\text{M}_8\text{[PC + 2]}$ &\\
			{}		&	\texttt{valP} $\leftarrow$ $\text{PC+ 10}$ & \\
			Decode & {} & {}\\
			Execute & \texttt{valE} $\leftarrow$ 0 + \texttt{valC}&{}\\
			Memory & {} & {}\\
			Write back & \texttt{R[rB]} $\leftarrow$ \texttt{valE} & {}\\
			PC update & \texttt{PC} $ \leftarrow$ \texttt{valP} & {}\\
		\end{tabular}
	\end{center}
	How does this instruction execution modify the registers and the PC?
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{ccc}
			\multicolumn{2}{r}{Generic} & Specific\\
			Stage & \texttt{irmovq V, rB} & \texttt{irmovq \$128,\%rsp}\\
			\hline
			Fetch 	&	icode:ifun $\leftarrow$ $\text{M}_1\text{[PC]}$ & 
			$\texttt{M}_1\texttt{[0x00a] = 3:0}$\\
			
			{}		&	\texttt{rA:rB} $\leftarrow\text{M}_1\text{[PC + 1]}$ &
			\texttt{rA:rB} $\leftarrow\text{M}_1\texttt{[0x00b] = f:3}$\\
			
			{}		&	\texttt{valC} $\leftarrow$ $\text{M}_8\text{[PC + 2]}$ &
			\texttt{valC} $\leftarrow$ $\text{M}_8\texttt{[0x00c] = 0x15}$\\
			
			{}		&	\texttt{valP} $\leftarrow$ $\text{PC+ 10}$ & 
			\texttt{valP} $\leftarrow$ \texttt{0x00a} + 10 = \texttt{0x014}\\
			
			Decode & {} & {}\\
			
			Execute & \texttt{valE} $\leftarrow$ 0 + \texttt{valC}&
			\texttt{valE} $\leftarrow$ 0 + \texttt{0x15}\\
			
			Memory & {} & {}\\
			Write back & \texttt{R[rB]} $\leftarrow$ \texttt{valE} &
			\texttt{R[rB]} $\leftarrow$ \texttt{valE = \texttt{0x15}}\\
			PC update & \texttt{PC} $ \leftarrow$ \texttt{valP} & 
			\texttt{PC} $ \leftarrow$ \texttt{valP = 0x014} \\
		\end{tabular}
	\end{center}
		The stack pointer \texttt{\%rsp} is updated with the value
		\texttt{0x15}, and the PC is updated with the value \texttt{0x014}.
\end{sol}

\begin{ex}{4.14}
	Fill in the right-hand column of the following table to describe the processing
	of the \texttt{popq} instruction on line 7 of the object in Figure 4.17.
	\begin{center}
		\begin{tabular}{ccc}
			\multicolumn{2}{r}{Generic} & Specific\\
			Stage & \texttt{popq rA} & \texttt{popq \%rax}\\
			\hline
			Fetch &  icode:ifun $\leftarrow$ $\texttt{M}_1\texttt{[PC]}$ & {}\\
			{} & \texttt{rA:rB} $ \leftarrow$ $\texttt{M}_1\texttt{[PC+1]}$ & {}\\
			{} & \texttt{valP} $ \leftarrow$ \texttt{PC} + 2 & \\
			Decode & \texttt{valA}  $\leftarrow$ \texttt{R[\%rsp]} & {}\\
			{} & \texttt{valB}  $\leftarrow$ \texttt{R[\%rsp]} & {}\\
			Execute & \texttt{valE} $\leftarrow$  \texttt{valB} + 8 & {}\\
			Memory & \texttt{valM} $\leftarrow$ $\texttt{M}_8\texttt{[valA]}$ & {}\\
			Write back & \texttt{R[\%rsp]} $ \leftarrow$ \texttt{valE} & \\
			{} & \texttt{R[rA]} $\leftarrow$ \texttt{valM}&{}\\
			PC update & \texttt{PC} $\leftarrow$ \texttt{valP}
		\end{tabular}
	\end{center}
	What effect does this instruction have on the registers and the PC?
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{ccc}
			\multicolumn{2}{r}{Generic} & Specific\\
			Stage & \texttt{popq rA} & \texttt{popq \%rax}\\
			\hline
			Fetch &  icode:ifun $\leftarrow$ $\texttt{M}_1\texttt{[PC]}$ & 
			icode:ifun $\leftarrow$ $\texttt{M}_1\texttt{[PC] = b:0}$ \\
			
			{} & \texttt{rA:rB} $ \leftarrow$ $\texttt{M}_1\texttt{[PC+1]}$ & 
			\texttt{rA:rB} $ \leftarrow$ $\texttt{M}_1\texttt{[PC+1] = 0:f}$\\
			{} & \texttt{valP} $ \leftarrow$ \texttt{PC} + 2 &
			\texttt{valP} $ \leftarrow$ \texttt{PC} + 2 = \texttt{0x02e}\\
			
			Decode & \texttt{valA}  $\leftarrow$ \texttt{R[\%rsp]} &
			\texttt{valA}  $\leftarrow$ \texttt{R[\%rsp] = 128}\\
			
			{} & \texttt{valB}  $\leftarrow$ \texttt{R[\%rsp]} &
			\texttt{valA}  $\leftarrow$ \texttt{R[\%rsp] = 128}\\
			
			
			Execute & \texttt{valE} $\leftarrow$  \texttt{valB} + 8 & 
			\texttt{valE} $\leftarrow$  \texttt{valB} + 8 = 136\\
			Memory & \texttt{valM} $\leftarrow$ $\texttt{M}_8\texttt{[valA]}$ &
			\texttt{valM} $\leftarrow$ $\texttt{M}_8\texttt{[valA] = 9}$\\
			
			Write back & \texttt{R[\%rsp]} $ \leftarrow$ \texttt{valE} &
			\texttt{R[\%rsp]} $ \leftarrow$ \texttt{valE} = 136\\
			{} & \texttt{R[rA]} $\leftarrow$ \texttt{valM}&
			\texttt{R[rA]} $\leftarrow$ \texttt{valM} = 9\\
			
			PC update & \texttt{PC} $\leftarrow$ \texttt{valP} &
			 \texttt{PC} $\leftarrow$ \texttt{valP} = \texttt{0x02e}\\
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{4.15}
	What would be the effect of the instruction \texttt{push \%rsp} according to
	the steps listed in Figure 4.20? Does this conform to the desired behavior for
	Y86-64, as determined in Problem 4.7?
\end{ex}

\begin{sol}
	\
	During the \emph{Decode} step, \texttt{valA} and \texttt{valB} would both
	receive the value \texttt{R[\%rsp]}, which is the address currently stored
	at the top of the stack. Since the \emph{Memory} step occurs before the
	\emph{Write back} step, we see that the old value in \texttt{\%rsp} is
	written to the memory location stored at the new address and then the new
	address is stored at \texttt{\%rsp}. This is consistent with Problem 4.7
\end{sol}

\begin{ex}{4.16}
	Assume the two register writes in the write-back stage for \texttt{popq} occur
	in the order listed in Figure 4.20. What would be the effect of executing
	\texttt{popq \%rsp}? Does this conform to the desired behavior for Y86-64,
	as determined in Problem 4.8?
\end{ex}

\begin{sol}
	\
	The \emph{Decode} reads two copies of the address stored in \texttt{\%rsp},
	stored in \texttt{valA} and \texttt{valB}
	In the \emph{Execute} step, the newly computed stack pointer is computed as
	\texttt{valB + 8}, but the stack pointer is not updated yet.
	In the \emph{Memory} step, the value at that address is extracted into
	\texttt{valM}, but not assigned to anything yet. In the \emph{Write back} step, the
	stack pointer \texttt{\%rsp} is first updated to \texttt{valB + 8}, meaning that
	its address is being incremented by 8 bytes. Then, the value \texttt{valM}
	computed previously is stored at the stack pointer. The result is that the
	stack pointer address has been increased by 8, and the value at its new location
	is updated to \texttt{valM}, the value referred to by the old memory address
	of \texttt{\%rsp}.
\end{sol}

\begin{ex}{4.17}
	We can see by the instruction encodings (Figure 4.2 and 4.3) that the
	\texttt{rmovq} instruction is the unconditional version of a more general
	class of instructions that include the conditional moves. Show how you would
	modify the steps for the \texttt{rrmovq} instruction below to also handle the
	six conditional move instructions. You may find it useful to see how the
	implementation of the \texttt{jXX} instructions (Figure 4.21) handles conditional
	behavior.
	\begin{center}
		\begin{tabular}{cc}
			Stage & \texttt{cmovXX rA, rB}\\
			\hline
			Fetch & icode:ifun $\leftarrow$ $\texttt{M}_1$\texttt{[PC]}\\
			{} & \texttt{rA:rB} $\leftarrow$ $\texttt{M}_1$\texttt{[PC+1]}\\
			{} & \texttt{valP} $\leftarrow$ \texttt{PC} + 2\\
			Decode & \texttt{valA} $\leftarrow$ \texttt{R[rA]}\\
			Execute & \texttt{valE} $\leftarrow$ 0 + \texttt{valA}\\
			Memory & {}\\
			Write back & \texttt{R[rB]} $\leftarrow$ \texttt{valE}\\
			PC update & \texttt{PC} $\leftarrow$ \texttt{valP}
		\end{tabular}
	\end{center}
\end{ex}

\begin{sol}
	\
	During the \emph{Fetch} step, the \texttt{ifun} specifies the function
	that will be applied to the condition code to decide if the move should
	occur. Then, in the \emph{Execute} step we compute Cnd as Cond(CC,ifun),
	meaning that the condition codes will be used as an input to the decoded
	function, producing a signal Cnd that is 1 or 0. In the \emph{Write back}
	step, this signal is used to assign either \texttt{valA} or \texttt{valB}
	to \texttt{rB}.
	\begin{center}
		\begin{tabular}{cc}
			Stage & \texttt{cmovXX rA, rB}\\
			\hline
			Fetch & icode:ifun $\leftarrow$ $\texttt{M}_1$\texttt{[PC]}\\
			{} & \texttt{rA:rB} $\leftarrow$ $\texttt{M}_1$\texttt{[PC+1]}\\
			{} & \texttt{valP} $\leftarrow$ \texttt{PC} + 2\\
			Decode & \texttt{valA} $\leftarrow$ \texttt{R[rA]}\\
			{} & \texttt{valB} $ \leftarrow$ \texttt{R[rB]}\\
			Execute & \texttt{Cnd} $ \leftarrow$ \texttt{Cond(CC, ifun)}\\
			Memory & {}\\
			Write back & \texttt{R[rB]} $\leftarrow$ Cnd ? \texttt{valA}: \texttt{valB}\\
			PC update & \texttt{PC} $\leftarrow$ \texttt{valP}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{4.18}
	Fill in the right-hand column of the following table to describe the processing
	of the \texttt{call} instruction on line 9 of the object code in Figure 4.17:
	\begin{center}
		\begin{tabular}{ccc}
			\multicolumn{2}{r}{Generic} & Specific\\
			Stage & \texttt{call} Dest & \texttt{call 0x041}\\
			\hline
			Fetch & icode:ifun $\leftarrow$ $\texttt{M}_1$\texttt{[PC]}&{}\\
			{} & \texttt{valC} $\leftarrow$ $\texttt{M}_8$ \texttt{[PC+1]}& \\
			{} & \texttt{valP} $\leftarrow$ \texttt{PC} + 9 & {}\\
			Decode & \texttt{valB} $\leftarrow$ \texttt{R[\%rsp]} & {}\\
			Execute & \texttt{valE} $\leftarrow$ $\texttt{valB} + (-8)$ & {}\\
			Memory & $\texttt{M}_8[\texttt{valE}]$ $\leftarrow$ \texttt{valP} &{}\\
			Write back & \texttt{R[\%rsp]} $\leftarrow$ \texttt{valE} & {}\\
			PC update& \texttt{PC} $\leftarrow$ \texttt{valC} & {}
		\end{tabular}
	\end{center}
	What effect would this instruction execution have on the registers, the
	PC, and the memory?
\end{ex}

\begin{sol}
	\
	\begin{center}
		\begin{tabular}{ccc}
			\multicolumn{2}{r}{Generic} & Specific\\
			Stage & \texttt{call} Dest & \texttt{call 0x041}\\
			\hline
			Fetch & icode:ifun $\leftarrow$ $\texttt{M}_1$\texttt{[PC]}&
			 icode:ifun $\leftarrow$ $\texttt{M}_1$\texttt{[\texttt{0x037}]} = \texttt{8:0}\\
			
			{}&\texttt{valC} $\leftarrow$ $\texttt{M}_8$ \texttt{[PC+1]} & \texttt{valC} $\leftarrow$ $\texttt{M}_8$ \texttt{[0x038]} = 
			\texttt{0x0000000000000041}
			\\
			
			{} & \texttt{valP} $\leftarrow$ \texttt{PC} + 9 &
			\texttt{valP} $\leftarrow$ \texttt{0x040}\\
			
			Decode & \texttt{valB} $\leftarrow$ \texttt{R[\%rsp]} &
			\texttt{valB} $\leftarrow$ \texttt{128}\\
			 
			Execute & \texttt{valE} $\leftarrow$ $\texttt{valB} + (-8)$ &
			\texttt{valE} $\leftarrow$ 120\\
			
			Memory & $\texttt{M}_8\texttt{[valE]}$ $\leftarrow$ \texttt{valP} &
			$\texttt{M}_8$\texttt{[120]} $\leftarrow$ \texttt{0x040}\\
			
			Write back & \texttt{R[\%rsp]} $\leftarrow$ \texttt{valE} &
			\texttt{R[\%rsp]} $\leftarrow$ 120\\
			
			PC update& \texttt{PC} $\leftarrow$ \texttt{valC} &
			\texttt{PC} $\leftarrow$ \texttt{0x0000000000000041}
		\end{tabular}
	\end{center}
\end{sol}

\begin{ex}{4.19}
	Write HCL code  for the signal \texttt{need\_valC} in the SEQ  
	implementation?
\end{ex}

\begin{sol}
	\
	The \texttt{irmovq} instruction places the constant provided in
	the source into the destination. The \texttt{rmmovq} instruction
	requires specifying an  offset to the destination memory address.
	The \texttt{mrmovq} instruction requires specifying an offset to
	the source memory address. The jump instructions, \texttt{jXX}, require specifying
	a label that corresponds to the address of instruction to execute
	after the jump. Finally, the \texttt{call} instruction requires specifying
	a label corresponding to the first instruction in the procedure being
	called.
	\begin{lstlisting}[language={}]
bool need_valC = 
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ IJXX, ICALL};
	\end{lstlisting}
\end{sol}

\begin{ex}{4.20}
	The register signal \texttt{srcB}  indicates which register should be read
	to generate the signal \texttt{valB}. The desired value is shown as the second
	step in the double stage in Figures 4.18 to 4.21. Write HCL code for \texttt{srcB}.
\end{ex}

\begin{sol}
	\
	We need \texttt{srcB} in \texttt{rmmovq} because the second register gives the
	base address in a memory reference. For \texttt{mrmovq}, register \texttt{rB}
	is in the first position, where once again its address is used to compute the
	base memory address, as seen in Figure 4.19 on page 389.
	For \texttt{OPq}, \texttt{srcB} is the second integer operand.
	
	\
	For \texttt{pushq}, \texttt{srcB} gives the value of the stack pointer,
	which is use to compute the new stack pointer address \texttt{popq},
	\texttt{valB} once again holds the stack pointer value, and
	same for \texttt{call}  and \texttt{ret} (see Figure 4.20 and 4.21
	in pages 391 and 393).
	\begin{lstlisting}[language={}]
word srcB = [
	icode in { IRMMOVQ, IRMMOVQ, IOPQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET };
	1:  RNONE; # Don't need register
]
	\end{lstlisting}
\end{sol}

\begin{ex}{4.21}
	Register ID \texttt{dstM} indicates the destination register for write port
	\texttt{M}, where \texttt{valM}, the value read from memory, is stored. This is shown in Figures 4.18 to 4.21 as the second step in the write-back stage. Write
	HCL code for \texttt{dstM}.
\end{ex}

\begin{sol}
	\
	From the figures we see that the value read from memory is only ever stored
	into \texttt{rA}.
	\begin{lstlisting}[language={}]
word destM = [
	icode in { IMRMOVQ, IPOPQ }: rA;
	1: RNONE;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.22}
	Only the \texttt{popq} instruction uses both register file write ports
	simultaneously. For the instruction \texttt{pop \%rsp}, the same address
	will be used for both \texttt{E} and \texttt{M} write ports, but with
	different data. To handle this conflict, we must stablish a \emph{priority}
	among the two write ports so that when both attempt tow rite the same register
	on the same cycle, only the write from the higher-priority port takes places.
	Which of the two ports should be given priority in order to implement the
	desired behavior, as determined in Practice Problem 4.8?
\end{ex}

\begin{sol}
	\
	In Practice Problem 4.8 we determined that the resulting value is that which
	was read from memory, so port \texttt{M} should be given priority in order
	to be consistent with that.
\end{sol}

\begin{ex}{4.23}
	Based on the first operand of the first step of the execute stage in Figures
	4.18 to 4.21, write an HCL description for the signal \texttt{aluB} in
	SEQ.
\end{ex}

\begin{sol}
	\
	In \texttt{IOPQ}, the value \texttt{valB} is the second operand. It's
	also used in \texttt{mrmovq} and \texttt{rmmovq} to represent the base address of a memory reference, and in \texttt{pushq}, \texttt{popq}, \texttt{call},
	and \texttt{ret} for the stack pointer value that we either add or decrement.
	In \texttt{rrmovq}, the first operand is \texttt{valA} and the second is
	\texttt{0}, the goal is to compute \texttt{valA} to store in the destination
	register. Therefore, \texttt{aluB} is 0 here. For \texttt{irrmovq}, \texttt{aluA}
	is \texttt{valC} while \texttt{aluB} is 0.
	\begin{lstlisting}[language={}]
word aluB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ, IPUSHQ, IPOPQ, ICALL, IRET } : valB;
	icode in { IRRMOVQ, IIRMOVQ} : 0;
	1 : IRNONE;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.24}
	The conditional move instructions, abbreviated \texttt{cmovXX}, have
	instruction code \texttt{IRRMOVQ}. As Figure 4.28 shows, we can implement
	these instructions by making use of the \texttt{Cnd} signal, generated in
	the execute stage. Modify the HCL code for \texttt{dstE} to implement these
	instructions.
\end{ex}

\begin{sol}
	\
	For \texttt{cmovXX}, we only ever write to the destination register,
	\texttt{rB}, if \texttt{Cnd} is asserted. 
	\begin{lstlisting}[language={}]
word destE = [
	Cnd && icode in { IRRMOVQ } : rB;
	icode in { IRRMOVQ } : rB;
	icode in { IIRMOVQ, IOPQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.25}
	Looking at memory operations for the different instructions shown in Figures
	4.18 to 4.21, we can see that the data for memory writes are always either
	\texttt{valA} or \texttt{valP}. Write HCL code for the signal \texttt{mem\_data}
	in \texttt{SEQ}.
\end{ex}

\begin{sol}
	\
	\begin{lstlisting}[language={}]
word mem_data = [
	icode in { IRMMOVQ, IPUSHQ} : valA;
	icode == ICALL : valP;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.26}
	We want to control the signal \texttt{mem\_write} only for instructions that
	write data to memory. Write HCL code for the signal \texttt{mem\_write} in
	SEQ.
\end{ex}

\begin{sol}
	\
	The instructions that write data to memory are precisely those named
	in Exercise 4.25:
	\begin{lstlisting}[language={}]
bool mem_write = icode in { IRMMOVQ, IPUSHQ, ICALL };
	\end{lstlisting}
\end{sol}

\begin{ex}{4.27}
	Write HCL code for \texttt{Stat}, generating the four status \texttt{SAOK},
	\texttt{SADR}, \texttt{SINS}, and \texttt{SHLT}.
\end{ex}

\begin{sol}
	\
	\begin{lstlisting}[language={}]
Stat = [
	imem_error || dmem_error: SADDR;
	!instr_valid : SINS;
	icode == IHALT : SHALT;
	1: SAOK;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.28}
	Suppose we analyze the combinational logic of Figure 4.32 and determine that it
	can be separated into a sequence of six blocks, named A to F, having delays
	of 80, 30, 60, 50, 70, and 10 ps, respectively, illustrated as follows:
	
	We can create pipelined versions of this design by inserting pipeline registers
	between pairs of these blocks. Different combinations of pipeline depth (how
	many stages) and maximum throughput arise, depending on where we insert the
	pipeline registers. Assume that pipeline register has a delay of 20 ps.
	\begin{enumerate}[label=(\alph*)]
		\item Inserting a single register gives a two-stage pipeline. Where should
		the register be inserted to maximize throughput? What would be the throughput
		and latency?
		\item Where should two registers be inserted to maximize throughput of a
		three-stage pipeline? What should be the throughput and latency?
		\item Where should three registers be inserted to maximize the throughput
		of a 4-stage pipeline? What would be the throughput and latency?
		\item What is the maximum number of stages that would yield a design
		with the maximum achievable throughput? Describe this design, its throughput,
		and its latency.
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The sum of the delays of all the blocks is still 300 ps. If
		we place the register between C and D, the first stage will have
		a delay of 170 ps, while the second stage has a delay of 130 ps.
		Since the registers have a delay of 20 ps, this means can cycle
		the clocks every 170 + 20 = 190 ps, yielding a throughput of
		around 5.26 GIPS. Since processing a full instruction requires 2 cycles,
		this means the latency is $2\times 190$ ps = 380 ps.
		\item We can place one register between B and C, and another
		register between D and E. Then the first stage will take up 110 ps,
		the second stage will take up 110 ps, and the last stage will take
		80 ps. Hence we can cycle the clocks every 110 + 20 ps = 130 ps,
		making the throughput 7.69 GIPS. The latency however is now
		$3\times130=$ 390 ps.
		\item Ideally we will place one between A and B, another between
		C and D, and one more between D and E. The slowest stage would
		then be given by the sum of the delay of components B and C,
		for a total of 90 ps. With the added 20 ps register delay, the
		throughput becomes around 9.09 GIPS. The delay latency is
		$4\times 9=$ 360 ps.
		\item Because the first component requires a delay of at least 80 ps
		and adding a register implies a delay of 20 ps, we know that
		we will be need to clock at least every 100 ps, for a maximum 
		throughput of 10 GIPS. To attain it, we require a register between
		A and B, between B and C,between C and D, and between D and E,
		for a total of 5 stages. The latency is $5\times 100=$ 500 ps. 
	\end{enumerate}
\end{sol}

\begin{ex}{4.29}
	Suppose we could take the system of Figure 4.32 and divide it into an arbitrary
	number of pipeline stages $k$, each having a delay of $300/k$, and with each
	pipeline register having a delay of 20 ps.
	\begin{enumerate}[label=(\alph*)]
		\item What would be the latency and the throughput of the system, as functions
		of $k$?
		\item What would be the ultimate limit on the throughput?
	\end{enumerate}
\end{ex}

\begin{sol}
	\
	\begin{enumerate}[label=(\alph*)]
		\item The throughput is given by $T(k)$, where
		\begin{align*}
			T(k)&=\frac{1}{\frac{300}{k}+20}\times 10^{12}\\
			&=\frac{1}{\frac{300+20k}{k}}\times 10^{12}\\
			&=\frac{k}{300+20k}\times 10^{12}
		\end{align*}
		in units of instructions per second. For example, if $k=1$, we get
		$3.125$ GIPS. The latency is given by $L(k)$, where
		\begin{align*}
			L(k)&=k\cdot \left(\frac{300}{k}+20\right)\times 10^{-12}\\
			&=(300+20k)\times 10^{-12}
		\end{align*}
		in units of seconds. For example, if $k=1$, then the latency is
		$300$ ps.
		\item We see that $\lim_{k\to\infty}T(k)=\frac{1}{20}\times 10^{12}$
		instructions per second, which equates 50 GIPS.
	\end{enumerate}
\end{sol}


\begin{ex}{4.30}
	Write HCL code for the signal \texttt{f\_stat}, providing the provisional status
	for the fetched instruction.
\end{ex}

\begin{sol}
	\
	This is largely the same as Exercise 4.27, but instead of \texttt{icode}, we use
	\texttt{f\_icode}, and we do not use the \texttt{dmem\_error} signal because that
	is handled in the Memory stage.
	
	\begin{lstlisting}[language={}]
word f_stat = [
	imem_error : SADR;
	!instr_valid : SINS;
	f_icode == SHLT : SHLT;
	1: SAOK;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.31}
	The block labeled ``dstE" in the decode stage generates the register ID for the
	E port of the register file, based on fields from the fetched instruction in pipeline
	register D. The resulting signal is named \texttt{d\_dstE} in the HCL description
	of PIPE. Write HCL code for this signal, based on the HCL description of the SEQ
	signal \texttt{dest\_E}. (See the code for SEQ in Section 4.3.4). Do not concern
	yourself with the logic to implement condition moves yet.
\end{ex}

\begin{sol}
	\
	In Section 4.3.4, the following HCL description was given for \texttt{dstE}
	\begin{lstlisting}[language={}]
# HCL for dstE signal in SEQ implementation of Y86-64
# WARNING: Conditional move not implemented correctly here
word dstE = [
	icode in { IRRMOVQ } : rB;
	icode in { IIRMOVQ, IOPQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE; # Don't write any register
];
	\end{lstlisting}
	Figure 4.58 shows the PIPE decode and write-back stage logic, indicating that
	block \texttt{destE} receives inputs \texttt{D\_icode} and \texttt{D\_rB}.
	Its output is the same after using the new signal names:
	\begin{lstlisting}[language={}]
word d_dstE = [
	D_icode in { IRRMOVQ } : D_rB;
	D_icode in { IIRMOVQ, IOPQ } : D_rB;
	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.32}
	Suppose the order of the third and fourth cases (the two forwarding sources from
	the memory stage) in the HCL code for \texttt{d\_valA} were reversed. Describe
	the resulting behavior of the \texttt{rrmovq} instruction (line 5) for the following
	program:
	\begin{lstlisting}[language={}]
irmovq	$5,	%rdx
irmovq	$0x100	%rsp
rmmovq	%rdx,0(%rsp)
popq	%rsp
rrmovq	%rsp,%rax
	\end{lstlisting}
\end{ex}

\begin{sol}
	\	
	The \texttt{rrmovq} on line 5 uses \%rsp as a source register, but the the \texttt{popq}
	instruction on line 4 read and writes its value for memory, leading to a load/use
	data hazard as described on page 439. To handle this, the processor stalls the
	\texttt{rrmovq} instruction in line 5 in the decode stage, allowing the
	\texttt{pop \%rsp} instruction to move on to the memory stage, at which point the value
	can be forwarded. However, the \texttt{popq \%rsp} instruction produces
	signals \texttt{M\_dstM} amd \texttt{M\_dstE}, both of which are \texttt{R[\%rsp]}
	(see Figure 4.20 on page 391),and hence they both match \texttt{d\_srcA}, the
	source operand to \texttt{rrmovq} on line 5. Since the order of the third
	and fourth cases is reversed in the HCL Logic for \texttt{d\_valA}, this
	causes the \texttt{M\_dstE} branch to be chosen, causing \texttt{d\_valA}
	to take on the value of \texttt{M\_valE}, the value read, which is the new
	value of the stack pointer (namely, \texttt{0x108}), which is what will
	be written to \texttt{\%rax}. However this is incorrect, because if the instructions
	were executed sequentially, then the instruction \texttt{pop \%rsp} would have
	the value \texttt{5}, which is precisely \texttt{m\_valM}, the value we would
	have chosen if we had not reversed the order.
\end{sol}

\begin{ex}{4.33}
	Suppose the order of the fifth and sixth cases (the two forwarding sources from
	the write-back stage) in the HCL code for \texttt{d\_valA} were reversed. Write a
	Y86-64 program that would be executed incorrectly. Describe how the error would occur
	and its effect on the program behavior.
\end{ex}

\begin{sol}
	\
	The following HCL code would execute incorrectly:
	\begin{lstlisting}[language={}]
irmovq 5, %rdx
irmovq 0x100, %rsp
rmmovq %rdx, 0(%rsp)
pop %rsp
nop
nop
rrmovq %rsp, %rax
	\end{lstlisting}
	The code sets \texttt{R[\%rdx]} to 5 and \texttt{R[\%rsp]} to \texttt{0x100}.
	It then loads \texttt{5} at $\texttt{M}_8\texttt{[\%rsp]}$. The \texttt{pushq}
	is meant to duplicate the value 5 at memory location \texttt{0x0F8}, the new
	memory location that \texttt{\%rsp} holds. When \texttt{rrmovq} reaches the
	decode stage, it receives the forwarded values from the \texttt{popq} instruction
	that is in the Write-back stage. Here, \texttt{W\_dstM} and \texttt{W\_dstE} are
	both \texttt{\%rsp}, and since the fifth and sixth cases are reversed,
	this means that the processor will take the action matching \texttt{W\_dstE},
	meaning that \texttt{d\_valA} will be set to \texttt{W\_valE}, which is
	the value \texttt{0x108}. However the intended behavior is to get the value
	5.
\end{sol}

\begin{ex}{4.34}
	Write HCL code for the signal \texttt{d\_valB}, giving thee value for source operand
	\texttt{valB} supplied to pipeline register E.
\end{ex}

\begin{sol}
	\
	The cases are largely the same as for \texttt{d\_valA}, but since \texttt{d\_valB}
	does not have the dual usage of holding instruction addresses, it's slightly simpler.
	All forwarded values take precedence, giving priority to values written to memory,
	and to upcoming instructions at an earlier stage (indicating the last change).
	\begin{lstlisting}[language={}]
word d_valB = [
	d_srcB == e_dstE : e_valE;
	d_srcB == M_dstM : m_valM;
	d_srcB == M_dstE : M_valE;
	d_srcB == W_dstM : W_valM;
	d_srcB == W_dstE : W_valE;
	1 : d_rvalB;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.35}
	Our second case in the HCL code for \texttt{d\_valA} uses signal \texttt{e\_dstE} to see
	whether to select the ALU output \texttt{e\_valE} as the forwarding source. Suppose instead
	that we use signal \texttt{E\_dstE}, the destination register ID in pipeline register E for
	this selection. Write a Y86-64 program that would give an incorrect result with this
	modified forwarding logic.
\end{ex}

\begin{sol}
	\
	Based on Figure 4.60, the diagram for the PIPE execute logic shows that the control logic
	block for \texttt{dstE} that produces \texttt{e\_dstE} accepts \texttt{e\_Cnd} and
	\texttt{E\_icode} as inputs. Therefore, the output \texttt{dstE} produced by
	\texttt{e\_dstE} takes care of conditional move operations issued by \texttt{cmovXX} instructions,
	which does not get accounted for when forwarding \texttt{E\_dstE}.
	Therefore, the following program would execute incorrectly:
	\begin{lstlisting}[language={}]
irmovq $-1, %rsi
irmovq $50, %rdx
irmovq $-50, %rbx
addq %rdx, %rbx # Set CC
cmovne %rsi, %rbx
rrmovq %rbx, %rax
	\end{lstlisting}
	The \texttt{addq} will turn off \texttt{ZF}, causing \texttt{e\_Cnd} to be on, because
	the addition yields 0. Because \texttt{E\_dstE} does not account for this, the \texttt{rrmovq}
	instruction receives the value that \texttt{\%rbx} would have had if the conditional move
	had succeeded -- namely, $-1$, the value of \texttt{\%rsi}. However, because the move
	failed, it should have used $-50$ from its register.
\end{sol}

\begin{ex}{4.36}
	In this stage, we can complete the computation of the status code \texttt{Stat} by detecting
	the case of an invalid address for the data memory. Write HCL code for the signal
	\texttt{m\_stat}.
\end{ex}

\begin{sol}
	\
	We can identify any existing errors due to an invalid memory address, and if none were
	detected, then forward the status we received.++
	\begin{lstlisting}[language={}]
word m_stat = [
	dmem_error : SADR;
	1 : M_stat;
];
	\end{lstlisting}
\end{sol}

\begin{ex}{4.37}
	Write a Y86-64 assembly-language program that causes combination A to arise and determines
	whether the control logic handles it correctly.
\end{ex}

\begin{sol}
	\
	Combination A involves a jump which, if taken, would have led to a return statement
	being executed early.
	\begin{lstlisting}[language={}]


irmovq $1, %rdx
irmovq $-1, %rax
add %rdx, %rax		# Set ZF to 1
jne .bad_input		# if != 0 goto .bad_input (not taken)
irmovq $32, %rax	# Should execute
ret
.bad_input:			# Should not execute, but if PIPE control logic is wrong, it will.
ret
	\end{lstlisting}
	Since the PIPE processor always takes jumps, the last \texttt{ret} instruction would cause
	the value 0 to be returned to the caller, but this instruction should be canceled
	because the branch is actually not taken and the \texttt{irmovq} should execute
	before returning. If the program behaves incorrectly, then \texttt{\%rax} will
	have the value 0, when it should be 32.
\end{sol}

\end{document}
